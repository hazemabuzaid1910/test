// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"three.module.min.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DstAlphaFactor = exports.DoubleSide = exports.DodecahedronGeometry = exports.DisplayP3ColorSpace = exports.DiscreteInterpolant = exports.DirectionalLightHelper = exports.DirectionalLight = exports.DetachedBindMode = exports.DepthTexture = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.DataUtils = exports.DataTextureLoader = exports.DataTexture = exports.DataArrayTexture = exports.Data3DTexture = exports.Cylindrical = exports.CylinderGeometry = exports.CustomToneMapping = exports.CustomBlending = exports.CurvePath = exports.Curve = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubicInterpolant = exports.CubicBezierCurve3 = exports.CubicBezierCurve = exports.CubeUVReflectionMapping = exports.CubeTextureLoader = exports.CubeTexture = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.CubeCamera = exports.ConstantColorFactor = exports.ConstantAlphaFactor = exports.ConeGeometry = exports.CompressedTextureLoader = exports.CompressedTexture = exports.CompressedCubeTexture = exports.CompressedArrayTexture = exports.ColorManagement = exports.ColorKeyframeTrack = exports.Color = exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CineonToneMapping = exports.CatmullRomCurve3 = exports.CapsuleGeometry = exports.CanvasTexture = exports.CameraHelper = exports.Camera = exports.Cache = exports.ByteType = exports.BufferGeometryLoader = exports.BufferGeometry = exports.BufferAttribute = exports.BoxHelper = exports.BoxGeometry = exports.Box3Helper = exports.Box3 = exports.Box2 = exports.BooleanKeyframeTrack = exports.Bone = exports.BatchedMesh = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AxesHelper = exports.AudioLoader = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.AttachedBindMode = exports.ArrowHelper = exports.ArrayCamera = exports.ArcCurve = exports.AnimationUtils = exports.AnimationObjectGroup = exports.AnimationMixer = exports.AnimationLoader = exports.AnimationClip = exports.AnimationAction = exports.AmbientLight = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlwaysCompare = exports.AlphaFormat = exports.AgXToneMapping = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LoadingManager = exports.LoaderUtils = exports.Loader = exports.LinearTransfer = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearInterpolant = exports.LinearFilter = exports.LinearEncoding = exports.LinearDisplayP3ColorSpace = exports.LineSegments = exports.LineLoop = exports.LineDashedMaterial = exports.LineCurve3 = exports.LineCurve = exports.LineBasicMaterial = exports.Line3 = exports.Line = exports.LightProbe = exports.Light = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessEqualCompare = exports.LessDepth = exports.LessCompare = exports.Layers = exports.LatheGeometry = exports.LOD = exports.KeyframeTrack = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.Interpolant = exports.InterleavedBufferAttribute = exports.InterleavedBuffer = exports.IntType = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.InstancedMesh = exports.InstancedInterleavedBuffer = exports.InstancedBufferGeometry = exports.InstancedBufferAttribute = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImageUtils = exports.ImageLoader = exports.ImageBitmapLoader = exports.IcosahedronGeometry = exports.HemisphereLightHelper = exports.HemisphereLight = exports.HalfFloatType = exports.Group = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterEqualCompare = exports.GreaterDepth = exports.GreaterCompare = exports.GLSL3 = exports.GLSL1 = exports.GLBufferAttribute = exports.Frustum = exports.FrontSide = exports.FramebufferTexture = exports.FogExp2 = exports.Fog = exports.FloatType = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.FileLoader = exports.ExtrudeGeometry = exports.EventDispatcher = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EqualCompare = exports.EllipseCurve = exports.EdgesGeometry = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = void 0;
exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.RED_RGTC1_Format = exports.RED_GREEN_RGTC2_Format = exports.QuaternionLinearInterpolant = exports.QuaternionKeyframeTrack = exports.Quaternion = exports.QuadraticBezierCurve3 = exports.QuadraticBezierCurve = exports.PropertyMixer = exports.PropertyBinding = exports.PositionalAudio = exports.PolyhedronGeometry = exports.PolarGridHelper = exports.PointsMaterial = exports.Points = exports.PointLightHelper = exports.PointLight = exports.PlaneHelper = exports.PlaneGeometry = exports.Plane = exports.PerspectiveCamera = exports.Path = exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.P3Primaries = exports.OrthographicCamera = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneMinusConstantColorFactor = exports.OneMinusConstantAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.ObjectSpaceNormalMap = exports.ObjectLoader = exports.Object3D = exports.NumberKeyframeTrack = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NotEqualCompare = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NeverCompare = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MeshToonMaterial = exports.MeshStandardMaterial = exports.MeshPhysicalMaterial = exports.MeshPhongMaterial = exports.MeshNormalMaterial = exports.MeshMatcapMaterial = exports.MeshLambertMaterial = exports.MeshDistanceMaterial = exports.MeshDepthMaterial = exports.MeshBasicMaterial = exports.Mesh = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.MathUtils = exports.MaterialLoader = exports.Material = void 0;
exports.WebGLCoordinateSystem = exports.WebGLArrayRenderTarget = exports.WebGL3DRenderTarget = exports.WebGL1Renderer = exports.VideoTexture = exports.VectorKeyframeTrack = exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.UniformsGroup = exports.Uniform = exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.UVMapping = exports.TubeGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TorusKnotGeometry = exports.TorusGeometry = exports.TextureLoader = exports.Texture = exports.TetrahedronGeometry = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StringKeyframeTrack = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StereoCamera = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpriteMaterial = exports.Sprite = exports.SpotLightHelper = exports.SpotLight = exports.SplineCurve = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereGeometry = exports.Sphere = exports.Source = exports.SkinnedMesh = exports.SkeletonHelper = exports.Skeleton = exports.ShortType = exports.ShapeUtils = exports.ShapePath = exports.ShapeGeometry = exports.Shape = exports.ShadowMaterial = exports.ShaderMaterial = exports.ShaderLib = exports.ShaderChunk = exports.Scene = exports.SRGBTransfer = exports.SRGBColorSpace = exports.SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = exports.RingGeometry = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.RenderTarget = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RectAreaLight = exports.Rec709Primaries = exports.Raycaster = exports.Ray = exports.RawShaderMaterial = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_SIGNED_Format = exports.RGBA_S3TC_DXT5_Format = void 0;
exports.WebGLRenderer = exports.WebGLRenderTarget = exports.WebGLMultipleRenderTargets = exports.WebGLCubeRenderTarget = void 0;
exports.WebGLUtils = Gl;
exports._SRGBAFormat = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WireframeGeometry = exports.WebGPUCoordinateSystem = void 0;
exports.createCanvasElement = ai;
exports.sRGBEncoding = void 0;
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e337) { throw _e337; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e338) { didErr = true; err = _e338; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
var t = exports.REVISION = "161",
  e = exports.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
  },
  n = exports.TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
  },
  i = exports.CullFaceNone = 0,
  r = exports.CullFaceBack = 1,
  s = exports.CullFaceFront = 2,
  a = exports.CullFaceFrontBack = 3,
  o = exports.BasicShadowMap = 0,
  l = exports.PCFShadowMap = 1,
  c = exports.PCFSoftShadowMap = 2,
  h = exports.VSMShadowMap = 3,
  u = exports.FrontSide = 0,
  d = exports.BackSide = 1,
  p = exports.DoubleSide = 2,
  m = exports.NoBlending = 0,
  f = exports.NormalBlending = 1,
  g = exports.AdditiveBlending = 2,
  _ = exports.SubtractiveBlending = 3,
  v = exports.MultiplyBlending = 4,
  x = exports.CustomBlending = 5,
  y = exports.AddEquation = 100,
  M = exports.SubtractEquation = 101,
  S = exports.ReverseSubtractEquation = 102,
  b = exports.MinEquation = 103,
  E = exports.MaxEquation = 104,
  T = exports.ZeroFactor = 200,
  w = exports.OneFactor = 201,
  A = exports.SrcColorFactor = 202,
  R = exports.OneMinusSrcColorFactor = 203,
  C = exports.SrcAlphaFactor = 204,
  P = exports.OneMinusSrcAlphaFactor = 205,
  L = exports.DstAlphaFactor = 206,
  I = exports.OneMinusDstAlphaFactor = 207,
  U = exports.DstColorFactor = 208,
  N = exports.OneMinusDstColorFactor = 209,
  D = exports.SrcAlphaSaturateFactor = 210,
  O = exports.ConstantColorFactor = 211,
  F = exports.OneMinusConstantColorFactor = 212,
  B = exports.ConstantAlphaFactor = 213,
  z = exports.OneMinusConstantAlphaFactor = 214,
  H = exports.NeverDepth = 0,
  V = exports.AlwaysDepth = 1,
  k = exports.LessDepth = 2,
  G = exports.LessEqualDepth = 3,
  W = exports.EqualDepth = 4,
  X = exports.GreaterEqualDepth = 5,
  j = exports.GreaterDepth = 6,
  q = exports.NotEqualDepth = 7,
  Y = exports.MultiplyOperation = 0,
  Z = exports.MixOperation = 1,
  J = exports.AddOperation = 2,
  K = exports.NoToneMapping = 0,
  $ = exports.LinearToneMapping = 1,
  Q = exports.ReinhardToneMapping = 2,
  tt = exports.CineonToneMapping = 3,
  et = exports.ACESFilmicToneMapping = 4,
  nt = exports.CustomToneMapping = 5,
  it = exports.AgXToneMapping = 6,
  rt = exports.AttachedBindMode = "attached",
  st = exports.DetachedBindMode = "detached",
  at = exports.UVMapping = 300,
  ot = exports.CubeReflectionMapping = 301,
  lt = exports.CubeRefractionMapping = 302,
  ct = exports.EquirectangularReflectionMapping = 303,
  ht = exports.EquirectangularRefractionMapping = 304,
  ut = exports.CubeUVReflectionMapping = 306,
  dt = exports.RepeatWrapping = 1e3,
  pt = exports.ClampToEdgeWrapping = 1001,
  mt = exports.MirroredRepeatWrapping = 1002,
  ft = exports.NearestFilter = 1003,
  gt = exports.NearestMipmapNearestFilter = 1004,
  _t = exports.NearestMipMapNearestFilter = 1004,
  vt = exports.NearestMipmapLinearFilter = 1005,
  xt = exports.NearestMipMapLinearFilter = 1005,
  yt = exports.LinearFilter = 1006,
  Mt = exports.LinearMipmapNearestFilter = 1007,
  St = exports.LinearMipMapNearestFilter = 1007,
  bt = exports.LinearMipmapLinearFilter = 1008,
  Et = exports.LinearMipMapLinearFilter = 1008,
  Tt = exports.UnsignedByteType = 1009,
  wt = exports.ByteType = 1010,
  At = exports.ShortType = 1011,
  Rt = exports.UnsignedShortType = 1012,
  Ct = exports.IntType = 1013,
  Pt = exports.UnsignedIntType = 1014,
  Lt = exports.FloatType = 1015,
  It = exports.HalfFloatType = 1016,
  Ut = exports.UnsignedShort4444Type = 1017,
  Nt = exports.UnsignedShort5551Type = 1018,
  Dt = exports.UnsignedInt248Type = 1020,
  Ot = exports.AlphaFormat = 1021,
  Ft = exports.RGBAFormat = 1023,
  Bt = exports.LuminanceFormat = 1024,
  zt = exports.LuminanceAlphaFormat = 1025,
  Ht = exports.DepthFormat = 1026,
  Vt = exports.DepthStencilFormat = 1027,
  kt = exports.RedFormat = 1028,
  Gt = exports.RedIntegerFormat = 1029,
  Wt = exports.RGFormat = 1030,
  Xt = exports.RGIntegerFormat = 1031,
  jt = exports.RGBAIntegerFormat = 1033,
  qt = exports.RGB_S3TC_DXT1_Format = 33776,
  Yt = exports.RGBA_S3TC_DXT1_Format = 33777,
  Zt = exports.RGBA_S3TC_DXT3_Format = 33778,
  Jt = exports.RGBA_S3TC_DXT5_Format = 33779,
  Kt = exports.RGB_PVRTC_4BPPV1_Format = 35840,
  $t = exports.RGB_PVRTC_2BPPV1_Format = 35841,
  Qt = exports.RGBA_PVRTC_4BPPV1_Format = 35842,
  te = exports.RGBA_PVRTC_2BPPV1_Format = 35843,
  ee = exports.RGB_ETC1_Format = 36196,
  ne = exports.RGB_ETC2_Format = 37492,
  ie = exports.RGBA_ETC2_EAC_Format = 37496,
  re = exports.RGBA_ASTC_4x4_Format = 37808,
  se = exports.RGBA_ASTC_5x4_Format = 37809,
  ae = exports.RGBA_ASTC_5x5_Format = 37810,
  oe = exports.RGBA_ASTC_6x5_Format = 37811,
  le = exports.RGBA_ASTC_6x6_Format = 37812,
  ce = exports.RGBA_ASTC_8x5_Format = 37813,
  he = exports.RGBA_ASTC_8x6_Format = 37814,
  ue = exports.RGBA_ASTC_8x8_Format = 37815,
  de = exports.RGBA_ASTC_10x5_Format = 37816,
  pe = exports.RGBA_ASTC_10x6_Format = 37817,
  me = exports.RGBA_ASTC_10x8_Format = 37818,
  fe = exports.RGBA_ASTC_10x10_Format = 37819,
  ge = exports.RGBA_ASTC_12x10_Format = 37820,
  _e = exports.RGBA_ASTC_12x12_Format = 37821,
  ve = exports.RGBA_BPTC_Format = 36492,
  xe = exports.RGB_BPTC_SIGNED_Format = 36494,
  ye = exports.RGB_BPTC_UNSIGNED_Format = 36495,
  Me = exports.RED_RGTC1_Format = 36283,
  Se = exports.SIGNED_RED_RGTC1_Format = 36284,
  be = exports.RED_GREEN_RGTC2_Format = 36285,
  Ee = exports.SIGNED_RED_GREEN_RGTC2_Format = 36286,
  Te = exports.LoopOnce = 2200,
  we = exports.LoopRepeat = 2201,
  Ae = exports.LoopPingPong = 2202,
  Re = exports.InterpolateDiscrete = 2300,
  Ce = exports.InterpolateLinear = 2301,
  Pe = exports.InterpolateSmooth = 2302,
  Le = exports.ZeroCurvatureEnding = 2400,
  Ie = exports.ZeroSlopeEnding = 2401,
  Ue = exports.WrapAroundEnding = 2402,
  Ne = exports.NormalAnimationBlendMode = 2500,
  De = exports.AdditiveAnimationBlendMode = 2501,
  Oe = exports.TrianglesDrawMode = 0,
  Fe = exports.TriangleStripDrawMode = 1,
  Be = exports.TriangleFanDrawMode = 2,
  ze = exports.LinearEncoding = 3e3,
  He = exports.sRGBEncoding = 3001,
  Ve = exports.BasicDepthPacking = 3200,
  ke = exports.RGBADepthPacking = 3201,
  Ge = exports.TangentSpaceNormalMap = 0,
  We = exports.ObjectSpaceNormalMap = 1,
  Xe = exports.NoColorSpace = "",
  je = exports.SRGBColorSpace = "srgb",
  qe = exports.LinearSRGBColorSpace = "srgb-linear",
  Ye = exports.DisplayP3ColorSpace = "display-p3",
  Ze = exports.LinearDisplayP3ColorSpace = "display-p3-linear",
  Je = exports.LinearTransfer = "linear",
  Ke = exports.SRGBTransfer = "srgb",
  $e = exports.Rec709Primaries = "rec709",
  Qe = exports.P3Primaries = "p3",
  tn = exports.ZeroStencilOp = 0,
  en = exports.KeepStencilOp = 7680,
  nn = exports.ReplaceStencilOp = 7681,
  rn = exports.IncrementStencilOp = 7682,
  sn = exports.DecrementStencilOp = 7683,
  an = exports.IncrementWrapStencilOp = 34055,
  on = exports.DecrementWrapStencilOp = 34056,
  ln = exports.InvertStencilOp = 5386,
  cn = exports.NeverStencilFunc = 512,
  hn = exports.LessStencilFunc = 513,
  un = exports.EqualStencilFunc = 514,
  dn = exports.LessEqualStencilFunc = 515,
  pn = exports.GreaterStencilFunc = 516,
  mn = exports.NotEqualStencilFunc = 517,
  fn = exports.GreaterEqualStencilFunc = 518,
  gn = exports.AlwaysStencilFunc = 519,
  _n = exports.NeverCompare = 512,
  vn = exports.LessCompare = 513,
  xn = exports.EqualCompare = 514,
  yn = exports.LessEqualCompare = 515,
  Mn = exports.GreaterCompare = 516,
  Sn = exports.NotEqualCompare = 517,
  bn = exports.GreaterEqualCompare = 518,
  En = exports.AlwaysCompare = 519,
  Tn = exports.StaticDrawUsage = 35044,
  wn = exports.DynamicDrawUsage = 35048,
  An = exports.StreamDrawUsage = 35040,
  Rn = exports.StaticReadUsage = 35045,
  Cn = exports.DynamicReadUsage = 35049,
  Pn = exports.StreamReadUsage = 35041,
  Ln = exports.StaticCopyUsage = 35046,
  In = exports.DynamicCopyUsage = 35050,
  Un = exports.StreamCopyUsage = 35042,
  Nn = exports.GLSL1 = "100",
  Dn = exports.GLSL3 = "300 es",
  On = exports._SRGBAFormat = 1035,
  Fn = exports.WebGLCoordinateSystem = 2e3,
  Bn = exports.WebGPUCoordinateSystem = 2001;
var zn = exports.EventDispatcher = /*#__PURE__*/function () {
  function zn() {
    _classCallCheck(this, zn);
  }
  return _createClass(zn, [{
    key: "addEventListener",
    value: function addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      var n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;
      var n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(t, e) {
      if (void 0 === this._listeners) return;
      var n = this._listeners[t];
      if (void 0 !== n) {
        var _t2 = n.indexOf(e);
        -1 !== _t2 && n.splice(_t2, 1);
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(t) {
      if (void 0 === this._listeners) return;
      var e = this._listeners[t.type];
      if (void 0 !== e) {
        t.target = this;
        var _n2 = e.slice(0);
        for (var _e2 = 0, _i2 = _n2.length; _e2 < _i2; _e2++) _n2[_e2].call(this, t);
        t.target = null;
      }
    }
  }]);
}();
var Hn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var Vn = 1234567;
var kn = Math.PI / 180,
  Gn = 180 / Math.PI;
function Wn() {
  var t = 4294967295 * Math.random() | 0,
    e = 4294967295 * Math.random() | 0,
    n = 4294967295 * Math.random() | 0,
    i = 4294967295 * Math.random() | 0;
  return (Hn[255 & t] + Hn[t >> 8 & 255] + Hn[t >> 16 & 255] + Hn[t >> 24 & 255] + "-" + Hn[255 & e] + Hn[e >> 8 & 255] + "-" + Hn[e >> 16 & 15 | 64] + Hn[e >> 24 & 255] + "-" + Hn[63 & n | 128] + Hn[n >> 8 & 255] + "-" + Hn[n >> 16 & 255] + Hn[n >> 24 & 255] + Hn[255 & i] + Hn[i >> 8 & 255] + Hn[i >> 16 & 255] + Hn[i >> 24 & 255]).toLowerCase();
}
function Xn(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function jn(t, e) {
  return (t % e + e) % e;
}
function qn(t, e, n) {
  return (1 - n) * t + n * e;
}
function Yn(t) {
  return 0 == (t & t - 1) && 0 !== t;
}
function Zn(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
function Jn(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return t / 4294967295;
    case Uint16Array:
      return t / 65535;
    case Uint8Array:
      return t / 255;
    case Int32Array:
      return Math.max(t / 2147483647, -1);
    case Int16Array:
      return Math.max(t / 32767, -1);
    case Int8Array:
      return Math.max(t / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Kn(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return Math.round(4294967295 * t);
    case Uint16Array:
      return Math.round(65535 * t);
    case Uint8Array:
      return Math.round(255 * t);
    case Int32Array:
      return Math.round(2147483647 * t);
    case Int16Array:
      return Math.round(32767 * t);
    case Int8Array:
      return Math.round(127 * t);
    default:
      throw new Error("Invalid component type.");
  }
}
var $n = exports.MathUtils = {
  DEG2RAD: kn,
  RAD2DEG: Gn,
  generateUUID: Wn,
  clamp: Xn,
  euclideanModulo: jn,
  mapLinear: function mapLinear(t, e, n, i, r) {
    return i + (t - e) * (r - i) / (n - e);
  },
  inverseLerp: function inverseLerp(t, e, n) {
    return t !== e ? (n - t) / (e - t) : 0;
  },
  lerp: qn,
  damp: function damp(t, e, n, i) {
    return qn(t, e, 1 - Math.exp(-n * i));
  },
  pingpong: function pingpong(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return e - Math.abs(jn(t, 2 * e) - e);
  },
  smoothstep: function smoothstep(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
  },
  smootherstep: function smootherstep(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
  },
  randInt: function randInt(t, e) {
    return t + Math.floor(Math.random() * (e - t + 1));
  },
  randFloat: function randFloat(t, e) {
    return t + Math.random() * (e - t);
  },
  randFloatSpread: function randFloatSpread(t) {
    return t * (.5 - Math.random());
  },
  seededRandom: function seededRandom(t) {
    void 0 !== t && (Vn = t);
    var e = Vn += 1831565813;
    return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296;
  },
  degToRad: function degToRad(t) {
    return t * kn;
  },
  radToDeg: function radToDeg(t) {
    return t * Gn;
  },
  isPowerOfTwo: Yn,
  ceilPowerOfTwo: function ceilPowerOfTwo(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  },
  floorPowerOfTwo: Zn,
  setQuaternionFromProperEuler: function setQuaternionFromProperEuler(t, e, n, i, r) {
    var s = Math.cos,
      a = Math.sin,
      o = s(n / 2),
      l = a(n / 2),
      c = s((e + i) / 2),
      h = a((e + i) / 2),
      u = s((e - i) / 2),
      d = a((e - i) / 2),
      p = s((i - e) / 2),
      m = a((i - e) / 2);
    switch (r) {
      case "XYX":
        t.set(o * h, l * u, l * d, o * c);
        break;
      case "YZY":
        t.set(l * d, o * h, l * u, o * c);
        break;
      case "ZXZ":
        t.set(l * u, l * d, o * h, o * c);
        break;
      case "XZX":
        t.set(o * h, l * m, l * p, o * c);
        break;
      case "YXY":
        t.set(l * p, o * h, l * m, o * c);
        break;
      case "ZYZ":
        t.set(l * m, l * p, o * h, o * c);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
    }
  },
  normalize: Kn,
  denormalize: Jn
};
var Qn = exports.Vector2 = /*#__PURE__*/function () {
  function Qn() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, Qn);
    Qn.prototype.isVector2 = !0, this.x = t, this.y = e;
  }
  return _createClass(Qn, [{
    key: "width",
    get: function get() {
      return this.x;
    },
    set: function set(t) {
      this.x = t;
    }
  }, {
    key: "height",
    get: function get() {
      return this.y;
    },
    set: function set(t) {
      this.y = t;
    }
  }, {
    key: "set",
    value: function set(t, e) {
      return this.x = t, this.y = e, this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(t) {
      return this.x = t, this.y = t, this;
    }
  }, {
    key: "setX",
    value: function setX(t) {
      return this.x = t, this;
    }
  }, {
    key: "setY",
    value: function setY(t) {
      return this.y = t, this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.x = t.x, this.y = t.y, this;
    }
  }, {
    key: "add",
    value: function add(t) {
      return this.x += t.x, this.y += t.y, this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(t) {
      return this.x += t, this.y += t, this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    }
  }, {
    key: "sub",
    value: function sub(t) {
      return this.x -= t.x, this.y -= t.y, this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(t) {
      return this.x -= t, this.y -= t, this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.x *= t.x, this.y *= t.y, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      return this.x *= t, this.y *= t, this;
    }
  }, {
    key: "divide",
    value: function divide(t) {
      return this.x /= t.x, this.y /= t.y, this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(t) {
      var e = this.x,
        n = this.y,
        i = t.elements;
      return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this;
    }
  }, {
    key: "min",
    value: function min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    }
  }, {
    key: "max",
    value: function max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    }
  }, {
    key: "clamp",
    value: function clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(t, e) {
      var n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
  }, {
    key: "floor",
    value: function floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
  }, {
    key: "round",
    value: function round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
  }, {
    key: "dot",
    value: function dot(t) {
      return this.x * t.x + this.y * t.y;
    }
  }, {
    key: "cross",
    value: function cross(t) {
      return this.x * t.y - this.y * t.x;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "angle",
    value: function angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
  }, {
    key: "angleTo",
    value: function angleTo(t) {
      var e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      var n = this.dot(t) / e;
      return Math.acos(Xn(n, -1, 1));
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(t) {
      var e = this.x - t.x,
        n = this.y - t.y;
      return e * e + n * n;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
  }, {
    key: "setLength",
    value: function setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.x === this.x && t.y === this.y;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.x = t[e], this.y = t[e + 1], this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this.x, t[e + 1] = this.y, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e) {
      return this.x = t.getX(e), this.y = t.getY(e), this;
    }
  }, {
    key: "rotateAround",
    value: function rotateAround(t, e) {
      var n = Math.cos(e),
        i = Math.sin(e),
        r = this.x - t.x,
        s = this.y - t.y;
      return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this;
    }
  }, {
    key: "random",
    value: function random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.x;
          case 2:
            _context.next = 4;
            return this.y;
          case 4:
          case "end":
            return _context.stop();
        }
      }, value, this);
    })
  }]);
}();
var ti = exports.Matrix3 = /*#__PURE__*/function () {
  function ti(t, e, n, i, r, s, a, o, l) {
    _classCallCheck(this, ti);
    ti.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, s, a, o, l);
  }
  return _createClass(ti, [{
    key: "set",
    value: function set(t, e, n, i, r, s, a, o, l) {
      var c = this.elements;
      return c[0] = t, c[1] = i, c[2] = a, c[3] = e, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      var e = this.elements,
        n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(t, e, n) {
      return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }
  }, {
    key: "setFromMatrix4",
    value: function setFromMatrix4(t) {
      var e = t.elements;
      return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.multiplyMatrices(this, t);
    }
  }, {
    key: "premultiply",
    value: function premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(t, e) {
      var n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        a = n[3],
        o = n[6],
        l = n[1],
        c = n[4],
        h = n[7],
        u = n[2],
        d = n[5],
        p = n[8],
        m = i[0],
        f = i[3],
        g = i[6],
        _ = i[1],
        v = i[4],
        x = i[7],
        y = i[2],
        M = i[5],
        S = i[8];
      return r[0] = s * m + a * _ + o * y, r[3] = s * f + a * v + o * M, r[6] = s * g + a * x + o * S, r[1] = l * m + c * _ + h * y, r[4] = l * f + c * v + h * M, r[7] = l * g + c * x + h * S, r[2] = u * m + d * _ + p * y, r[5] = u * f + d * v + p * M, r[8] = u * g + d * x + p * S, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      var e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8];
      return e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o;
    }
  }, {
    key: "invert",
    value: function invert() {
      var t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8],
        h = c * s - a * l,
        u = a * o - c * r,
        d = l * r - s * o,
        p = e * h + n * u + i * d;
      if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      var m = 1 / p;
      return t[0] = h * m, t[1] = (i * l - c * n) * m, t[2] = (a * n - i * s) * m, t[3] = u * m, t[4] = (c * e - i * o) * m, t[5] = (i * r - a * e) * m, t[6] = d * m, t[7] = (n * o - l * e) * m, t[8] = (s * e - n * r) * m, this;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var t;
      var e = this.elements;
      return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
    }
  }, {
    key: "getNormalMatrix",
    value: function getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
  }, {
    key: "transposeIntoArray",
    value: function transposeIntoArray(t) {
      var e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    }
  }, {
    key: "setUvTransform",
    value: function setUvTransform(t, e, n, i, r, s, a) {
      var o = Math.cos(r),
        l = Math.sin(r);
      return this.set(n * o, n * l, -n * (o * s + l * a) + s + t, -i * l, i * o, -i * (-l * s + o * a) + a + e, 0, 0, 1), this;
    }
  }, {
    key: "scale",
    value: function scale(t, e) {
      return this.premultiply(ei.makeScale(t, e)), this;
    }
  }, {
    key: "rotate",
    value: function rotate(t) {
      return this.premultiply(ei.makeRotation(-t)), this;
    }
  }, {
    key: "translate",
    value: function translate(t, e) {
      return this.premultiply(ei.makeTranslation(t, e)), this;
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(t, e) {
      return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
    }
  }, {
    key: "makeRotation",
    value: function makeRotation(t) {
      var e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeScale",
    value: function makeScale(t, e) {
      return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      var e = this.elements,
        n = t.elements;
      for (var _t3 = 0; _t3 < 9; _t3++) if (e[_t3] !== n[_t3]) return !1;
      return !0;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var _n3 = 0; _n3 < 9; _n3++) this.elements[_n3] = t[_n3 + e];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }]);
}();
var ei = new ti();
function ni(t) {
  for (var _e3 = t.length - 1; _e3 >= 0; --_e3) if (t[_e3] >= 65535) return !0;
  return !1;
}
var ii = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};
function ri(t, e) {
  return new ii[t](e);
}
function si(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
function ai() {
  var t = si("canvas");
  return t.style.display = "block", t;
}
var oi = {};
function li(t) {
  t in oi || (oi[t] = !0, console.warn(t));
}
var ci = new ti().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
  hi = new ti().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
  ui = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, qe, {
    transfer: Je,
    primaries: $e,
    toReference: function toReference(t) {
      return t;
    },
    fromReference: function fromReference(t) {
      return t;
    }
  }), je, {
    transfer: Ke,
    primaries: $e,
    toReference: function toReference(t) {
      return t.convertSRGBToLinear();
    },
    fromReference: function fromReference(t) {
      return t.convertLinearToSRGB();
    }
  }), Ze, {
    transfer: Je,
    primaries: Qe,
    toReference: function toReference(t) {
      return t.applyMatrix3(hi);
    },
    fromReference: function fromReference(t) {
      return t.applyMatrix3(ci);
    }
  }), Ye, {
    transfer: Ke,
    primaries: Qe,
    toReference: function toReference(t) {
      return t.convertSRGBToLinear().applyMatrix3(hi);
    },
    fromReference: function fromReference(t) {
      return t.applyMatrix3(ci).convertLinearToSRGB();
    }
  }),
  di = new Set([qe, Ze]),
  pi = exports.ColorManagement = {
    enabled: !0,
    _workingColorSpace: qe,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(t) {
      if (!di.has(t)) throw new Error("Unsupported working color space, \"".concat(t, "\"."));
      this._workingColorSpace = t;
    },
    convert: function convert(t, e, n) {
      if (!1 === this.enabled || e === n || !e || !n) return t;
      var i = ui[e].toReference;
      return (0, ui[n].fromReference)(i(t));
    },
    fromWorkingColorSpace: function fromWorkingColorSpace(t, e) {
      return this.convert(t, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function toWorkingColorSpace(t, e) {
      return this.convert(t, e, this._workingColorSpace);
    },
    getPrimaries: function getPrimaries(t) {
      return ui[t].primaries;
    },
    getTransfer: function getTransfer(t) {
      return t === Xe ? Je : ui[t].transfer;
    }
  };
function mi(t) {
  return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4);
}
function fi(t) {
  return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055;
}
var gi;
var _i = exports.ImageUtils = /*#__PURE__*/function () {
  function _i() {
    _classCallCheck(this, _i);
  }
  return _createClass(_i, null, [{
    key: "getDataURL",
    value: function getDataURL(t) {
      if (/^data:/i.test(t.src)) return t.src;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      var e;
      if (t instanceof HTMLCanvasElement) e = t;else {
        void 0 === gi && (gi = si("canvas")), gi.width = t.width, gi.height = t.height;
        var _n4 = gi.getContext("2d");
        t instanceof ImageData ? _n4.putImageData(t, 0, 0) : _n4.drawImage(t, 0, 0, t.width, t.height), e = gi;
      }
      return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png");
    }
  }, {
    key: "sRGBToLinear",
    value: function sRGBToLinear(t) {
      if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
        var _e4 = si("canvas");
        _e4.width = t.width, _e4.height = t.height;
        var _n5 = _e4.getContext("2d");
        _n5.drawImage(t, 0, 0, t.width, t.height);
        var _i3 = _n5.getImageData(0, 0, t.width, t.height),
          _r2 = _i3.data;
        for (var _t4 = 0; _t4 < _r2.length; _t4++) _r2[_t4] = 255 * mi(_r2[_t4] / 255);
        return _n5.putImageData(_i3, 0, 0), _e4;
      }
      if (t.data) {
        var _e5 = t.data.slice(0);
        for (var _t5 = 0; _t5 < _e5.length; _t5++) _e5 instanceof Uint8Array || _e5 instanceof Uint8ClampedArray ? _e5[_t5] = Math.floor(255 * mi(_e5[_t5] / 255)) : _e5[_t5] = mi(_e5[_t5]);
        return {
          data: _e5,
          width: t.width,
          height: t.height
        };
      }
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
    }
  }]);
}();
var vi = 0;
var xi = exports.Source = /*#__PURE__*/function () {
  function xi() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, xi);
    this.isSource = !0, Object.defineProperty(this, "id", {
      value: vi++
    }), this.uuid = Wn(), this.data = t, this.dataReady = !0, this.version = 0;
  }
  return _createClass(xi, [{
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && this.version++;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
      var n = {
          uuid: this.uuid,
          url: ""
        },
        i = this.data;
      if (null !== i) {
        var _t6;
        if (Array.isArray(i)) {
          _t6 = [];
          for (var _e6 = 0, _n6 = i.length; _e6 < _n6; _e6++) i[_e6].isDataTexture ? _t6.push(yi(i[_e6].image)) : _t6.push(yi(i[_e6]));
        } else _t6 = yi(i);
        n.url = _t6;
      }
      return e || (t.images[this.uuid] = n), n;
    }
  }]);
}();
function yi(t) {
  return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? _i.getDataURL(t) : t.data ? {
    data: Array.from(t.data),
    width: t.width,
    height: t.height,
    type: t.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
var Mi = 0;
var Si = exports.Texture = /*#__PURE__*/function (_zn) {
  function Si() {
    var _this;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Si.DEFAULT_IMAGE;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Si.DEFAULT_MAPPING;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1001;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1001;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1006;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1008;
    var a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1023;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1009;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Si.DEFAULT_ANISOTROPY;
    var c = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : "";
    _classCallCheck(this, Si);
    _this = _callSuper(this, Si), _this.isTexture = !0, Object.defineProperty(_assertThisInitialized(_this), "id", {
      value: Mi++
    }), _this.uuid = Wn(), _this.name = "", _this.source = new xi(t), _this.mipmaps = [], _this.mapping = e, _this.channel = 0, _this.wrapS = n, _this.wrapT = i, _this.magFilter = r, _this.minFilter = s, _this.anisotropy = l, _this.format = a, _this.internalFormat = null, _this.type = o, _this.offset = new Qn(0, 0), _this.repeat = new Qn(1, 1), _this.center = new Qn(0, 0), _this.rotation = 0, _this.matrixAutoUpdate = !0, _this.matrix = new ti(), _this.generateMipmaps = !0, _this.premultiplyAlpha = !1, _this.flipY = !0, _this.unpackAlignment = 4, "string" == typeof c ? _this.colorSpace = c : (li("THREE.Texture: Property .encoding has been replaced by .colorSpace."), _this.colorSpace = c === He ? je : Xe), _this.userData = {}, _this.version = 0, _this.onUpdate = null, _this.isRenderTargetTexture = !1, _this.needsPMREMUpdate = !1;
    return _this;
  }
  _inherits(Si, _zn);
  return _createClass(Si, [{
    key: "image",
    get: function get() {
      return this.source.data;
    },
    set: function set() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.source.data = t;
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      var n = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(t).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }, {
    key: "transformUv",
    value: function transformUv(t) {
      if (this.mapping !== at) return t;
      if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
        case dt:
          t.x = t.x - Math.floor(t.x);
          break;
        case pt:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case mt:
          1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
      }
      if (t.y < 0 || t.y > 1) switch (this.wrapT) {
        case dt:
          t.y = t.y - Math.floor(t.y);
          break;
        case pt:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case mt:
          1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
      }
      return this.flipY && (t.y = 1 - t.y), t;
    }
  }, {
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && (this.version++, this.source.needsUpdate = !0);
    }
  }, {
    key: "encoding",
    get: function get() {
      return li("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === je ? He : ze;
    },
    set: function set(t) {
      li("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = t === He ? je : Xe;
    }
  }]);
}(zn);
Si.DEFAULT_IMAGE = null, Si.DEFAULT_MAPPING = at, Si.DEFAULT_ANISOTROPY = 1;
var bi = exports.Vector4 = /*#__PURE__*/function () {
  function bi() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, bi);
    bi.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i;
  }
  return _createClass(bi, [{
    key: "width",
    get: function get() {
      return this.z;
    },
    set: function set(t) {
      this.z = t;
    }
  }, {
    key: "height",
    get: function get() {
      return this.w;
    },
    set: function set(t) {
      this.w = t;
    }
  }, {
    key: "set",
    value: function set(t, e, n, i) {
      return this.x = t, this.y = e, this.z = n, this.w = i, this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this.w = t, this;
    }
  }, {
    key: "setX",
    value: function setX(t) {
      return this.x = t, this;
    }
  }, {
    key: "setY",
    value: function setY(t) {
      return this.y = t, this;
    }
  }, {
    key: "setZ",
    value: function setZ(t) {
      return this.z = t, this;
    }
  }, {
    key: "setW",
    value: function setW(t) {
      return this.w = t, this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this;
    }
  }, {
    key: "add",
    value: function add(t) {
      return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    }
  }, {
    key: "sub",
    value: function sub(t) {
      return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = this.w,
        s = t.elements;
      return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
  }, {
    key: "setAxisAngleFromQuaternion",
    value: function setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      var e = Math.sqrt(1 - t.w * t.w);
      return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    }
  }, {
    key: "setAxisAngleFromRotationMatrix",
    value: function setAxisAngleFromRotationMatrix(t) {
      var e, n, i, r;
      var s = .01,
        a = .1,
        o = t.elements,
        l = o[0],
        c = o[4],
        h = o[8],
        u = o[1],
        d = o[5],
        p = o[9],
        m = o[2],
        f = o[6],
        g = o[10];
      if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {
        if (Math.abs(c + u) < a && Math.abs(h + m) < a && Math.abs(p + f) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        var _t7 = (l + 1) / 2,
          _o2 = (d + 1) / 2,
          _2 = (g + 1) / 2,
          _v = (c + u) / 4,
          _x = (h + m) / 4,
          _y = (p + f) / 4;
        return _t7 > _o2 && _t7 > _2 ? _t7 < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(_t7), i = _v / n, r = _x / n) : _o2 > _2 ? _o2 < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(_o2), n = _v / i, r = _y / i) : _2 < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(_2), n = _x / r, i = _y / r), this.set(n, i, r, e), this;
      }
      var _ = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c));
      return Math.abs(_) < .001 && (_ = 1), this.x = (f - p) / _, this.y = (h - m) / _, this.z = (u - c) / _, this.w = Math.acos((l + d + g - 1) / 2), this;
    }
  }, {
    key: "min",
    value: function min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    }
  }, {
    key: "max",
    value: function max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    }
  }, {
    key: "clamp",
    value: function clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(t, e) {
      var n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
  }, {
    key: "floor",
    value: function floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
  }, {
    key: "round",
    value: function round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
  }, {
    key: "dot",
    value: function dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e) {
      return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }
  }, {
    key: "random",
    value: function random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.x;
          case 2:
            _context2.next = 4;
            return this.y;
          case 4:
            _context2.next = 6;
            return this.z;
          case 6:
            _context2.next = 8;
            return this.w;
          case 8:
          case "end":
            return _context2.stop();
        }
      }, value, this);
    })
  }]);
}();
var Ei = exports.RenderTarget = /*#__PURE__*/function (_zn2) {
  function Ei() {
    var _this2;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, Ei);
    _this2 = _callSuper(this, Ei), _this2.isRenderTarget = !0, _this2.width = t, _this2.height = e, _this2.depth = 1, _this2.scissor = new bi(0, 0, t, e), _this2.scissorTest = !1, _this2.viewport = new bi(0, 0, t, e);
    var i = {
      width: t,
      height: e,
      depth: 1
    };
    void 0 !== n.encoding && (li("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === He ? je : Xe), n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: yt,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0
    }, n), _this2.texture = new Si(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), _this2.texture.isRenderTargetTexture = !0, _this2.texture.flipY = !1, _this2.texture.generateMipmaps = n.generateMipmaps, _this2.texture.internalFormat = n.internalFormat, _this2.depthBuffer = n.depthBuffer, _this2.stencilBuffer = n.stencilBuffer, _this2.depthTexture = n.depthTexture, _this2.samples = n.samples;
    return _this2;
  }
  _inherits(Ei, _zn2);
  return _createClass(Ei, [{
    key: "setSize",
    value: function setSize(t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
      var e = Object.assign({}, t.texture.image);
      return this.texture.source = new xi(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }]);
}(zn);
var Ti = exports.WebGLRenderTarget = /*#__PURE__*/function (_Ei) {
  function Ti() {
    var _this3;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, Ti);
    _this3 = _callSuper(this, Ti, [t, e, n]), _this3.isWebGLRenderTarget = !0;
    return _this3;
  }
  _inherits(Ti, _Ei);
  return _createClass(Ti);
}(Ei);
var wi = exports.DataArrayTexture = /*#__PURE__*/function (_Si) {
  function wi() {
    var _this4;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, wi);
    _this4 = _callSuper(this, wi, [null]), _this4.isDataArrayTexture = !0, _this4.image = {
      data: t,
      width: e,
      height: n,
      depth: i
    }, _this4.magFilter = ft, _this4.minFilter = ft, _this4.wrapR = pt, _this4.generateMipmaps = !1, _this4.flipY = !1, _this4.unpackAlignment = 1;
    return _this4;
  }
  _inherits(wi, _Si);
  return _createClass(wi);
}(Si);
var Ai = exports.WebGLArrayRenderTarget = /*#__PURE__*/function (_Ti) {
  function Ai() {
    var _this5;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    _classCallCheck(this, Ai);
    _this5 = _callSuper(this, Ai, [t, e, i]), _this5.isWebGLArrayRenderTarget = !0, _this5.depth = n, _this5.texture = new wi(null, t, e, n), _this5.texture.isRenderTargetTexture = !0;
    return _this5;
  }
  _inherits(Ai, _Ti);
  return _createClass(Ai);
}(Ti);
var Ri = exports.Data3DTexture = /*#__PURE__*/function (_Si2) {
  function Ri() {
    var _this6;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Ri);
    _this6 = _callSuper(this, Ri, [null]), _this6.isData3DTexture = !0, _this6.image = {
      data: t,
      width: e,
      height: n,
      depth: i
    }, _this6.magFilter = ft, _this6.minFilter = ft, _this6.wrapR = pt, _this6.generateMipmaps = !1, _this6.flipY = !1, _this6.unpackAlignment = 1;
    return _this6;
  }
  _inherits(Ri, _Si2);
  return _createClass(Ri);
}(Si);
var Ci = exports.WebGL3DRenderTarget = /*#__PURE__*/function (_Ti2) {
  function Ci() {
    var _this7;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    _classCallCheck(this, Ci);
    _this7 = _callSuper(this, Ci, [t, e, i]), _this7.isWebGL3DRenderTarget = !0, _this7.depth = n, _this7.texture = new Ri(null, t, e, n), _this7.texture.isRenderTargetTexture = !0;
    return _this7;
  }
  _inherits(Ci, _Ti2);
  return _createClass(Ci);
}(Ti);
var Pi = exports.WebGLMultipleRenderTargets = /*#__PURE__*/function (_Ti3) {
  function Pi() {
    var _this8;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    _classCallCheck(this, Pi);
    _this8 = _callSuper(this, Pi, [t, e, i]), _this8.isWebGLMultipleRenderTargets = !0;
    var r = _this8.texture;
    _this8.texture = [];
    for (var _t8 = 0; _t8 < n; _t8++) _this8.texture[_t8] = r.clone(), _this8.texture[_t8].isRenderTargetTexture = !0;
    return _this8;
  }
  _inherits(Pi, _Ti3);
  return _createClass(Pi, [{
    key: "setSize",
    value: function setSize(t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      if (this.width !== t || this.height !== e || this.depth !== n) {
        this.width = t, this.height = e, this.depth = n;
        for (var _i4 = 0, _r3 = this.texture.length; _i4 < _r3; _i4++) this.texture[_i4].image.width = t, this.texture[_i4].image.height = e, this.texture[_i4].image.depth = n;
        this.dispose();
      }
      this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.texture.length = 0;
      for (var _e7 = 0, _n7 = t.texture.length; _e7 < _n7; _e7++) this.texture[_e7] = t.texture[_e7].clone(), this.texture[_e7].isRenderTargetTexture = !0;
      return this;
    }
  }]);
}(Ti);
var Li = exports.Quaternion = /*#__PURE__*/function () {
  function Li() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Li);
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i;
  }
  return _createClass(Li, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(t) {
      this._x = t, this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(t) {
      this._y = t, this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(t) {
      this._z = t, this._onChangeCallback();
    }
  }, {
    key: "w",
    get: function get() {
      return this._w;
    },
    set: function set(t) {
      this._w = t, this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(t, e, n, i) {
      return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = t._x,
        i = t._y,
        r = t._z,
        s = t._order,
        a = Math.cos,
        o = Math.sin,
        l = a(n / 2),
        c = a(i / 2),
        h = a(r / 2),
        u = o(n / 2),
        d = o(i / 2),
        p = o(r / 2);
      switch (s) {
        case "XYZ":
          this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
          break;
        case "YXZ":
          this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
          break;
        case "ZXY":
          this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
          break;
        case "ZYX":
          this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
          break;
        case "YZX":
          this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
          break;
        case "XZY":
          this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s);
      }
      return !0 === e && this._onChangeCallback(), this;
    }
  }, {
    key: "setFromAxisAngle",
    value: function setFromAxisAngle(t, e) {
      var n = e / 2,
        i = Math.sin(n);
      return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(t) {
      var e = t.elements,
        n = e[0],
        i = e[4],
        r = e[8],
        s = e[1],
        a = e[5],
        o = e[9],
        l = e[2],
        c = e[6],
        h = e[10],
        u = n + a + h;
      if (u > 0) {
        var _t9 = .5 / Math.sqrt(u + 1);
        this._w = .25 / _t9, this._x = (c - o) * _t9, this._y = (r - l) * _t9, this._z = (s - i) * _t9;
      } else if (n > a && n > h) {
        var _t10 = 2 * Math.sqrt(1 + n - a - h);
        this._w = (c - o) / _t10, this._x = .25 * _t10, this._y = (i + s) / _t10, this._z = (r + l) / _t10;
      } else if (a > h) {
        var _t11 = 2 * Math.sqrt(1 + a - n - h);
        this._w = (r - l) / _t11, this._x = (i + s) / _t11, this._y = .25 * _t11, this._z = (o + c) / _t11;
      } else {
        var _t12 = 2 * Math.sqrt(1 + h - n - a);
        this._w = (s - i) / _t12, this._x = (r + l) / _t12, this._y = (o + c) / _t12, this._z = .25 * _t12;
      }
      return this._onChangeCallback(), this;
    }
  }, {
    key: "setFromUnitVectors",
    value: function setFromUnitVectors(t, e) {
      var n = t.dot(e) + 1;
      return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
    }
  }, {
    key: "angleTo",
    value: function angleTo(t) {
      return 2 * Math.acos(Math.abs(Xn(this.dot(t), -1, 1)));
    }
  }, {
    key: "rotateTowards",
    value: function rotateTowards(t, e) {
      var n = this.angleTo(t);
      if (0 === n) return this;
      var i = Math.min(1, e / n);
      return this.slerp(t, i), this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(0, 0, 0, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      return this.conjugate();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
  }, {
    key: "dot",
    value: function dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var t = this.length();
      return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.multiplyQuaternions(this, t);
    }
  }, {
    key: "premultiply",
    value: function premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
  }, {
    key: "multiplyQuaternions",
    value: function multiplyQuaternions(t, e) {
      var n = t._x,
        i = t._y,
        r = t._z,
        s = t._w,
        a = e._x,
        o = e._y,
        l = e._z,
        c = e._w;
      return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this;
    }
  }, {
    key: "slerp",
    value: function slerp(t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      var n = this._x,
        i = this._y,
        r = this._z,
        s = this._w;
      var a = s * t._w + n * t._x + i * t._y + r * t._z;
      if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
      var o = 1 - a * a;
      if (o <= Number.EPSILON) {
        var _t13 = 1 - e;
        return this._w = _t13 * s + e * this._w, this._x = _t13 * n + e * this._x, this._y = _t13 * i + e * this._y, this._z = _t13 * r + e * this._z, this.normalize(), this;
      }
      var l = Math.sqrt(o),
        c = Math.atan2(l, a),
        h = Math.sin((1 - e) * c) / l,
        u = Math.sin(e * c) / l;
      return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this;
    }
  }, {
    key: "slerpQuaternions",
    value: function slerpQuaternions(t, e, n) {
      return this.copy(t).slerp(e, n);
    }
  }, {
    key: "random",
    value: function random() {
      var t = Math.random(),
        e = Math.sqrt(1 - t),
        n = Math.sqrt(t),
        i = 2 * Math.PI * Math.random(),
        r = 2 * Math.PI * Math.random();
      return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i));
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e) {
      return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toArray();
    }
  }, {
    key: "_onChange",
    value: function _onChange(t) {
      return this._onChangeCallback = t, this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this._x;
          case 2:
            _context3.next = 4;
            return this._y;
          case 4:
            _context3.next = 6;
            return this._z;
          case 6:
            _context3.next = 8;
            return this._w;
          case 8:
          case "end":
            return _context3.stop();
        }
      }, value, this);
    })
  }], [{
    key: "slerpFlat",
    value: function slerpFlat(t, e, n, i, r, s, a) {
      var o = n[i + 0],
        l = n[i + 1],
        c = n[i + 2],
        h = n[i + 3];
      var u = r[s + 0],
        d = r[s + 1],
        p = r[s + 2],
        m = r[s + 3];
      if (0 === a) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = h);
      if (1 === a) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void (t[e + 3] = m);
      if (h !== m || o !== u || l !== d || c !== p) {
        var _t14 = 1 - a;
        var _e8 = o * u + l * d + c * p + h * m,
          _n8 = _e8 >= 0 ? 1 : -1,
          _i5 = 1 - _e8 * _e8;
        if (_i5 > Number.EPSILON) {
          var _r4 = Math.sqrt(_i5),
            _s2 = Math.atan2(_r4, _e8 * _n8);
          _t14 = Math.sin(_t14 * _s2) / _r4, a = Math.sin(a * _s2) / _r4;
        }
        var _r5 = a * _n8;
        if (o = o * _t14 + u * _r5, l = l * _t14 + d * _r5, c = c * _t14 + p * _r5, h = h * _t14 + m * _r5, _t14 === 1 - a) {
          var _t15 = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
          o *= _t15, l *= _t15, c *= _t15, h *= _t15;
        }
      }
      t[e] = o, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h;
    }
  }, {
    key: "multiplyQuaternionsFlat",
    value: function multiplyQuaternionsFlat(t, e, n, i, r, s) {
      var a = n[i],
        o = n[i + 1],
        l = n[i + 2],
        c = n[i + 3],
        h = r[s],
        u = r[s + 1],
        d = r[s + 2],
        p = r[s + 3];
      return t[e] = a * p + c * h + o * d - l * u, t[e + 1] = o * p + c * u + l * h - a * d, t[e + 2] = l * p + c * d + a * u - o * h, t[e + 3] = c * p - a * h - o * u - l * d, t;
    }
  }]);
}();
var Ii = exports.Vector3 = /*#__PURE__*/function () {
  function Ii() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    _classCallCheck(this, Ii);
    Ii.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n;
  }
  return _createClass(Ii, [{
    key: "set",
    value: function set(t, e, n) {
      return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this;
    }
  }, {
    key: "setX",
    value: function setX(t) {
      return this.x = t, this;
    }
  }, {
    key: "setY",
    value: function setY(t) {
      return this.y = t, this;
    }
  }, {
    key: "setZ",
    value: function setZ(t) {
      return this.z = t, this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    }
  }, {
    key: "add",
    value: function add(t) {
      return this.x += t.x, this.y += t.y, this.z += t.z, this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    }
  }, {
    key: "sub",
    value: function sub(t) {
      return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    }
  }, {
    key: "applyEuler",
    value: function applyEuler(t) {
      return this.applyQuaternion(Ni.setFromEuler(t));
    }
  }, {
    key: "applyAxisAngle",
    value: function applyAxisAngle(t, e) {
      return this.applyQuaternion(Ni.setFromAxisAngle(t, e));
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements,
        s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
      return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = t.x,
        s = t.y,
        a = t.z,
        o = t.w,
        l = 2 * (s * i - a * n),
        c = 2 * (a * e - r * i),
        h = 2 * (r * n - s * e);
      return this.x = e + o * l + s * h - a * c, this.y = n + o * c + a * l - r * h, this.z = i + o * h + r * c - s * l, this;
    }
  }, {
    key: "project",
    value: function project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
    }
  }, {
    key: "unproject",
    value: function unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize();
    }
  }, {
    key: "divide",
    value: function divide(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
  }, {
    key: "min",
    value: function min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    }
  }, {
    key: "max",
    value: function max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    }
  }, {
    key: "clamp",
    value: function clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(t, e) {
      var n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
  }, {
    key: "floor",
    value: function floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
  }, {
    key: "round",
    value: function round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
  }, {
    key: "dot",
    value: function dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
    }
  }, {
    key: "cross",
    value: function cross(t) {
      return this.crossVectors(this, t);
    }
  }, {
    key: "crossVectors",
    value: function crossVectors(t, e) {
      var n = t.x,
        i = t.y,
        r = t.z,
        s = e.x,
        a = e.y,
        o = e.z;
      return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this;
    }
  }, {
    key: "projectOnVector",
    value: function projectOnVector(t) {
      var e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      var n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    }
  }, {
    key: "projectOnPlane",
    value: function projectOnPlane(t) {
      return Ui.copy(this).projectOnVector(t), this.sub(Ui);
    }
  }, {
    key: "reflect",
    value: function reflect(t) {
      return this.sub(Ui.copy(t).multiplyScalar(2 * this.dot(t)));
    }
  }, {
    key: "angleTo",
    value: function angleTo(t) {
      var e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      var n = this.dot(t) / e;
      return Math.acos(Xn(n, -1, 1));
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(t) {
      var e = this.x - t.x,
        n = this.y - t.y,
        i = this.z - t.z;
      return e * e + n * n + i * i;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    }
  }, {
    key: "setFromSpherical",
    value: function setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
  }, {
    key: "setFromSphericalCoords",
    value: function setFromSphericalCoords(t, e, n) {
      var i = Math.sin(e) * t;
      return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this;
    }
  }, {
    key: "setFromCylindrical",
    value: function setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
  }, {
    key: "setFromCylindricalCoords",
    value: function setFromCylindricalCoords(t, e, n) {
      return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
    }
  }, {
    key: "setFromMatrixPosition",
    value: function setFromMatrixPosition(t) {
      var e = t.elements;
      return this.x = e[12], this.y = e[13], this.z = e[14], this;
    }
  }, {
    key: "setFromMatrixScale",
    value: function setFromMatrixScale(t) {
      var e = this.setFromMatrixColumn(t, 0).length(),
        n = this.setFromMatrixColumn(t, 1).length(),
        i = this.setFromMatrixColumn(t, 2).length();
      return this.x = e, this.y = n, this.z = i, this;
    }
  }, {
    key: "setFromMatrixColumn",
    value: function setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e);
    }
  }, {
    key: "setFromMatrix3Column",
    value: function setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e);
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(t) {
      return this.x = t._x, this.y = t._y, this.z = t._z, this;
    }
  }, {
    key: "setFromColor",
    value: function setFromColor(t) {
      return this.x = t.r, this.y = t.g, this.z = t.b, this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e) {
      return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }
  }, {
    key: "random",
    value: function random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
  }, {
    key: "randomDirection",
    value: function randomDirection() {
      var t = 2 * (Math.random() - .5),
        e = Math.random() * Math.PI * 2,
        n = Math.sqrt(1 - Math.pow(t, 2));
      return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.x;
          case 2:
            _context4.next = 4;
            return this.y;
          case 4:
            _context4.next = 6;
            return this.z;
          case 6:
          case "end":
            return _context4.stop();
        }
      }, value, this);
    })
  }]);
}();
var Ui = new Ii(),
  Ni = new Li();
var Di = exports.Box3 = /*#__PURE__*/function () {
  function Di() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii(1 / 0, 1 / 0, 1 / 0);
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii(-1 / 0, -1 / 0, -1 / 0);
    _classCallCheck(this, Di);
    this.isBox3 = !0, this.min = t, this.max = e;
  }
  return _createClass(Di, [{
    key: "set",
    value: function set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
  }, {
    key: "setFromArray",
    value: function setFromArray(t) {
      this.makeEmpty();
      for (var _e9 = 0, _n9 = t.length; _e9 < _n9; _e9 += 3) this.expandByPoint(Fi.fromArray(t, _e9));
      return this;
    }
  }, {
    key: "setFromBufferAttribute",
    value: function setFromBufferAttribute(t) {
      this.makeEmpty();
      for (var _e10 = 0, _n10 = t.count; _e10 < _n10; _e10++) this.expandByPoint(Fi.fromBufferAttribute(t, _e10));
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(t) {
      this.makeEmpty();
      for (var _e11 = 0, _n11 = t.length; _e11 < _n11; _e11++) this.expandByPoint(t[_e11]);
      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(t, e) {
      var n = Fi.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
  }, {
    key: "setFromObject",
    value: function setFromObject(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      return this.makeEmpty(), this.expandByObject(t, e);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
  }, {
    key: "getCenter",
    value: function getCenter(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
    }
  }, {
    key: "getSize",
    value: function getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
  }, {
    key: "expandByObject",
    value: function expandByObject(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      t.updateWorldMatrix(!1, !1);
      var n = t.geometry;
      if (void 0 !== n) {
        var _i6 = n.getAttribute("position");
        if (!0 === e && void 0 !== _i6 && !0 !== t.isInstancedMesh) for (var _e12 = 0, _n12 = _i6.count; _e12 < _n12; _e12++) !0 === t.isMesh ? t.getVertexPosition(_e12, Fi) : Fi.fromBufferAttribute(_i6, _e12), Fi.applyMatrix4(t.matrixWorld), this.expandByPoint(Fi);else void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(), Bi.copy(t.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), Bi.copy(n.boundingBox)), Bi.applyMatrix4(t.matrixWorld), this.union(Bi);
      }
      var i = t.children;
      for (var _t16 = 0, _n13 = i.length; _t16 < _n13; _t16++) this.expandByObject(i[_t16], e);
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    }
  }, {
    key: "containsBox",
    value: function containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    }
  }, {
    key: "getParameter",
    value: function getParameter(t, e) {
      return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      return this.clampPoint(t.center, Fi), Fi.distanceToSquared(t.center) <= t.radius * t.radius;
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(t) {
      var e, n;
      return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
    }
  }, {
    key: "intersectsTriangle",
    value: function intersectsTriangle(t) {
      if (this.isEmpty()) return !1;
      this.getCenter(Xi), ji.subVectors(this.max, Xi), zi.subVectors(t.a, Xi), Hi.subVectors(t.b, Xi), Vi.subVectors(t.c, Xi), ki.subVectors(Hi, zi), Gi.subVectors(Vi, Hi), Wi.subVectors(zi, Vi);
      var e = [0, -ki.z, ki.y, 0, -Gi.z, Gi.y, 0, -Wi.z, Wi.y, ki.z, 0, -ki.x, Gi.z, 0, -Gi.x, Wi.z, 0, -Wi.x, -ki.y, ki.x, 0, -Gi.y, Gi.x, 0, -Wi.y, Wi.x, 0];
      return !!Zi(e, zi, Hi, Vi, ji) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Zi(e, zi, Hi, Vi, ji) && (qi.crossVectors(ki, Gi), e = [qi.x, qi.y, qi.z], Zi(e, zi, Hi, Vi, ji)));
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return this.clampPoint(t, Fi).distanceTo(t);
    }
  }, {
    key: "getBoundingSphere",
    value: function getBoundingSphere(t) {
      return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(Fi).length()), t;
    }
  }, {
    key: "intersect",
    value: function intersect(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    }
  }, {
    key: "union",
    value: function union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      return this.isEmpty() || (Oi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Oi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Oi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Oi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Oi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Oi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Oi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Oi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Oi)), this;
    }
  }, {
    key: "translate",
    value: function translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }]);
}();
var Oi = [new Ii(), new Ii(), new Ii(), new Ii(), new Ii(), new Ii(), new Ii(), new Ii()],
  Fi = new Ii(),
  Bi = new Di(),
  zi = new Ii(),
  Hi = new Ii(),
  Vi = new Ii(),
  ki = new Ii(),
  Gi = new Ii(),
  Wi = new Ii(),
  Xi = new Ii(),
  ji = new Ii(),
  qi = new Ii(),
  Yi = new Ii();
function Zi(t, e, n, i, r) {
  for (var _s3 = 0, _a2 = t.length - 3; _s3 <= _a2; _s3 += 3) {
    Yi.fromArray(t, _s3);
    var _a3 = r.x * Math.abs(Yi.x) + r.y * Math.abs(Yi.y) + r.z * Math.abs(Yi.z),
      _o3 = e.dot(Yi),
      _l2 = n.dot(Yi),
      _c2 = i.dot(Yi);
    if (Math.max(-Math.max(_o3, _l2, _c2), Math.min(_o3, _l2, _c2)) > _a3) return !1;
  }
  return !0;
}
var Ji = new Di(),
  Ki = new Ii(),
  $i = new Ii();
var Qi = exports.Sphere = /*#__PURE__*/function () {
  function Qi() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    _classCallCheck(this, Qi);
    this.isSphere = !0, this.center = t, this.radius = e;
  }
  return _createClass(Qi, [{
    key: "set",
    value: function set(t, e) {
      return this.center.copy(t), this.radius = e, this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(t, e) {
      var n = this.center;
      void 0 !== e ? n.copy(e) : Ji.setFromPoints(t).getCenter(n);
      var i = 0;
      for (var _e13 = 0, _r6 = t.length; _e13 < _r6; _e13++) i = Math.max(i, n.distanceToSquared(t[_e13]));
      return this.radius = Math.sqrt(i), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.radius < 0;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      var e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return t.intersectsSphere(this);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(t, e) {
      var n = this.center.distanceToSquared(t);
      return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(t) {
      return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
    }
  }, {
    key: "translate",
    value: function translate(t) {
      return this.center.add(t), this;
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(t) {
      if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
      Ki.subVectors(t, this.center);
      var e = Ki.lengthSq();
      if (e > this.radius * this.radius) {
        var _t17 = Math.sqrt(e),
          _n14 = .5 * (_t17 - this.radius);
        this.center.addScaledVector(Ki, _n14 / _t17), this.radius += _n14;
      }
      return this;
    }
  }, {
    key: "union",
    value: function union(t) {
      return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : ($i.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Ki.copy(t.center).add($i)), this.expandByPoint(Ki.copy(t.center).sub($i))), this);
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var tr = new Ii(),
  er = new Ii(),
  nr = new Ii(),
  ir = new Ii(),
  rr = new Ii(),
  sr = new Ii(),
  ar = new Ii();
var or = exports.Ray = /*#__PURE__*/function () {
  function or() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii(0, 0, -1);
    _classCallCheck(this, or);
    this.origin = t, this.direction = e;
  }
  return _createClass(or, [{
    key: "set",
    value: function set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
  }, {
    key: "at",
    value: function at(t, e) {
      return e.copy(this.origin).addScaledVector(this.direction, t);
    }
  }, {
    key: "lookAt",
    value: function lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
  }, {
    key: "recast",
    value: function recast(t) {
      return this.origin.copy(this.at(t, tr)), this;
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      var n = e.dot(this.direction);
      return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
  }, {
    key: "distanceSqToPoint",
    value: function distanceSqToPoint(t) {
      var e = tr.subVectors(t, this.origin).dot(this.direction);
      return e < 0 ? this.origin.distanceToSquared(t) : (tr.copy(this.origin).addScaledVector(this.direction, e), tr.distanceToSquared(t));
    }
  }, {
    key: "distanceSqToSegment",
    value: function distanceSqToSegment(t, e, n, i) {
      er.copy(t).add(e).multiplyScalar(.5), nr.copy(e).sub(t).normalize(), ir.copy(this.origin).sub(er);
      var r = .5 * t.distanceTo(e),
        s = -this.direction.dot(nr),
        a = ir.dot(this.direction),
        o = -ir.dot(nr),
        l = ir.lengthSq(),
        c = Math.abs(1 - s * s);
      var h, u, d, p;
      if (c > 0) {
        if (h = s * o - a, u = s * a - o, p = r * c, h >= 0) {
          if (u >= -p) {
            if (u <= p) {
              var _t18 = 1 / c;
              h *= _t18, u *= _t18, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l;
            } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
          } else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
        } else u <= -p ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
      } else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
      return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(er).addScaledVector(nr, u), d;
    }
  }, {
    key: "intersectSphere",
    value: function intersectSphere(t, e) {
      tr.subVectors(t.center, this.origin);
      var n = tr.dot(this.direction),
        i = tr.dot(tr) - n * n,
        r = t.radius * t.radius;
      if (i > r) return null;
      var s = Math.sqrt(r - i),
        a = n - s,
        o = n + s;
      return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
  }, {
    key: "distanceToPlane",
    value: function distanceToPlane(t) {
      var e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      var n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(t, e) {
      var n = this.distanceToPlane(t);
      return null === n ? null : this.at(n, e);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(t) {
      var e = t.distanceToPoint(this.origin);
      if (0 === e) return !0;
      return t.normal.dot(this.direction) * e < 0;
    }
  }, {
    key: "intersectBox",
    value: function intersectBox(t, e) {
      var n, i, r, s, a, o;
      var l = 1 / this.direction.x,
        c = 1 / this.direction.y,
        h = 1 / this.direction.z,
        u = this.origin;
      return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r), (s < i || isNaN(i)) && (i = s), h >= 0 ? (a = (t.min.z - u.z) * h, o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, o = (t.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return null !== this.intersectBox(t, tr);
    }
  }, {
    key: "intersectTriangle",
    value: function intersectTriangle(t, e, n, i, r) {
      rr.subVectors(e, t), sr.subVectors(n, t), ar.crossVectors(rr, sr);
      var s,
        a = this.direction.dot(ar);
      if (a > 0) {
        if (i) return null;
        s = 1;
      } else {
        if (!(a < 0)) return null;
        s = -1, a = -a;
      }
      ir.subVectors(this.origin, t);
      var o = s * this.direction.dot(sr.crossVectors(ir, sr));
      if (o < 0) return null;
      var l = s * this.direction.dot(rr.cross(ir));
      if (l < 0) return null;
      if (o + l > a) return null;
      var c = -s * ir.dot(ar);
      return c < 0 ? null : this.at(c / a, r);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var lr = exports.Matrix4 = /*#__PURE__*/function () {
  function lr(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
    _classCallCheck(this, lr);
    lr.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f);
  }
  return _createClass(lr, [{
    key: "set",
    value: function set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
      var g = this.elements;
      return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new lr().fromArray(this.elements);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      var e = this.elements,
        n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
    }
  }, {
    key: "copyPosition",
    value: function copyPosition(t) {
      var e = this.elements,
        n = t.elements;
      return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
    }
  }, {
    key: "setFromMatrix3",
    value: function setFromMatrix3(t) {
      var e = t.elements;
      return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(t, e, n) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
    }
  }, {
    key: "makeBasis",
    value: function makeBasis(t, e, n) {
      return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "extractRotation",
    value: function extractRotation(t) {
      var e = this.elements,
        n = t.elements,
        i = 1 / cr.setFromMatrixColumn(t, 0).length(),
        r = 1 / cr.setFromMatrixColumn(t, 1).length(),
        s = 1 / cr.setFromMatrixColumn(t, 2).length();
      return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }
  }, {
    key: "makeRotationFromEuler",
    value: function makeRotationFromEuler(t) {
      var e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z,
        s = Math.cos(n),
        a = Math.sin(n),
        o = Math.cos(i),
        l = Math.sin(i),
        c = Math.cos(r),
        h = Math.sin(r);
      if ("XYZ" === t.order) {
        var _t19 = s * c,
          _n15 = s * h,
          _i7 = a * c,
          _r7 = a * h;
        e[0] = o * c, e[4] = -o * h, e[8] = l, e[1] = _n15 + _i7 * l, e[5] = _t19 - _r7 * l, e[9] = -a * o, e[2] = _r7 - _t19 * l, e[6] = _i7 + _n15 * l, e[10] = s * o;
      } else if ("YXZ" === t.order) {
        var _t20 = o * c,
          _n16 = o * h,
          _i8 = l * c,
          _r8 = l * h;
        e[0] = _t20 + _r8 * a, e[4] = _i8 * a - _n16, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -a, e[2] = _n16 * a - _i8, e[6] = _r8 + _t20 * a, e[10] = s * o;
      } else if ("ZXY" === t.order) {
        var _t21 = o * c,
          _n17 = o * h,
          _i9 = l * c,
          _r9 = l * h;
        e[0] = _t21 - _r9 * a, e[4] = -s * h, e[8] = _i9 + _n17 * a, e[1] = _n17 + _i9 * a, e[5] = s * c, e[9] = _r9 - _t21 * a, e[2] = -s * l, e[6] = a, e[10] = s * o;
      } else if ("ZYX" === t.order) {
        var _t22 = s * c,
          _n18 = s * h,
          _i10 = a * c,
          _r10 = a * h;
        e[0] = o * c, e[4] = _i10 * l - _n18, e[8] = _t22 * l + _r10, e[1] = o * h, e[5] = _r10 * l + _t22, e[9] = _n18 * l - _i10, e[2] = -l, e[6] = a * o, e[10] = s * o;
      } else if ("YZX" === t.order) {
        var _t23 = s * o,
          _n19 = s * l,
          _i11 = a * o,
          _r11 = a * l;
        e[0] = o * c, e[4] = _r11 - _t23 * h, e[8] = _i11 * h + _n19, e[1] = h, e[5] = s * c, e[9] = -a * c, e[2] = -l * c, e[6] = _n19 * h + _i11, e[10] = _t23 - _r11 * h;
      } else if ("XZY" === t.order) {
        var _t24 = s * o,
          _n20 = s * l,
          _i12 = a * o,
          _r12 = a * l;
        e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = _t24 * h + _r12, e[5] = s * c, e[9] = _n20 * h - _i12, e[2] = _i12 * h - _n20, e[6] = a * c, e[10] = _r12 * h + _t24;
      }
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }
  }, {
    key: "makeRotationFromQuaternion",
    value: function makeRotationFromQuaternion(t) {
      return this.compose(ur, t, dr);
    }
  }, {
    key: "lookAt",
    value: function lookAt(t, e, n) {
      var i = this.elements;
      return fr.subVectors(t, e), 0 === fr.lengthSq() && (fr.z = 1), fr.normalize(), pr.crossVectors(n, fr), 0 === pr.lengthSq() && (1 === Math.abs(n.z) ? fr.x += 1e-4 : fr.z += 1e-4, fr.normalize(), pr.crossVectors(n, fr)), pr.normalize(), mr.crossVectors(fr, pr), i[0] = pr.x, i[4] = mr.x, i[8] = fr.x, i[1] = pr.y, i[5] = mr.y, i[9] = fr.y, i[2] = pr.z, i[6] = mr.z, i[10] = fr.z, this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.multiplyMatrices(this, t);
    }
  }, {
    key: "premultiply",
    value: function premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(t, e) {
      var n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        a = n[4],
        o = n[8],
        l = n[12],
        c = n[1],
        h = n[5],
        u = n[9],
        d = n[13],
        p = n[2],
        m = n[6],
        f = n[10],
        g = n[14],
        _ = n[3],
        v = n[7],
        x = n[11],
        y = n[15],
        M = i[0],
        S = i[4],
        b = i[8],
        E = i[12],
        T = i[1],
        w = i[5],
        A = i[9],
        R = i[13],
        C = i[2],
        P = i[6],
        L = i[10],
        I = i[14],
        U = i[3],
        N = i[7],
        D = i[11],
        O = i[15];
      return r[0] = s * M + a * T + o * C + l * U, r[4] = s * S + a * w + o * P + l * N, r[8] = s * b + a * A + o * L + l * D, r[12] = s * E + a * R + o * I + l * O, r[1] = c * M + h * T + u * C + d * U, r[5] = c * S + h * w + u * P + d * N, r[9] = c * b + h * A + u * L + d * D, r[13] = c * E + h * R + u * I + d * O, r[2] = p * M + m * T + f * C + g * U, r[6] = p * S + m * w + f * P + g * N, r[10] = p * b + m * A + f * L + g * D, r[14] = p * E + m * R + f * I + g * O, r[3] = _ * M + v * T + x * C + y * U, r[7] = _ * S + v * w + x * P + y * N, r[11] = _ * b + v * A + x * L + y * D, r[15] = _ * E + v * R + x * I + y * O, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      var e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var t = this.elements,
        e = t[0],
        n = t[4],
        i = t[8],
        r = t[12],
        s = t[1],
        a = t[5],
        o = t[9],
        l = t[13],
        c = t[2],
        h = t[6],
        u = t[10],
        d = t[14];
      return t[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - i * s * d + i * l * c - r * o * c) + t[11] * (+e * l * h - e * a * d - r * s * h + n * s * d + r * a * c - n * l * c) + t[15] * (-i * a * c - e * o * h + e * a * u + i * s * h - n * s * u + n * o * c);
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var t = this.elements;
      var e;
      return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
    }
  }, {
    key: "setPosition",
    value: function setPosition(t, e, n) {
      var i = this.elements;
      return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this;
    }
  }, {
    key: "invert",
    value: function invert() {
      var t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8],
        h = t[9],
        u = t[10],
        d = t[11],
        p = t[12],
        m = t[13],
        f = t[14],
        g = t[15],
        _ = h * f * l - m * u * l + m * o * d - a * f * d - h * o * g + a * u * g,
        v = p * u * l - c * f * l - p * o * d + s * f * d + c * o * g - s * u * g,
        x = c * m * l - p * h * l + p * a * d - s * m * d - c * a * g + s * h * g,
        y = p * h * o - c * m * o - p * a * u + s * m * u + c * a * f - s * h * f,
        M = e * _ + n * v + i * x + r * y;
      if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      var S = 1 / M;
      return t[0] = _ * S, t[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * S, t[2] = (a * f * r - m * o * r + m * i * l - n * f * l - a * i * g + n * o * g) * S, t[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * S, t[4] = v * S, t[5] = (c * f * r - p * u * r + p * i * d - e * f * d - c * i * g + e * u * g) * S, t[6] = (p * o * r - s * f * r - p * i * l + e * f * l + s * i * g - e * o * g) * S, t[7] = (s * u * r - c * o * r + c * i * l - e * u * l - s * i * d + e * o * d) * S, t[8] = x * S, t[9] = (p * h * r - c * m * r - p * n * d + e * m * d + c * n * g - e * h * g) * S, t[10] = (s * m * r - p * a * r + p * n * l - e * m * l - s * n * g + e * a * g) * S, t[11] = (c * a * r - s * h * r - c * n * l + e * h * l + s * n * d - e * a * d) * S, t[12] = y * S, t[13] = (c * m * i - p * h * i + p * n * u - e * m * u - c * n * f + e * h * f) * S, t[14] = (p * a * i - s * m * i - p * n * o + e * m * o + s * n * f - e * a * f) * S, t[15] = (s * h * i - c * a * i + c * n * o - e * h * o - s * n * u + e * a * u) * S, this;
    }
  }, {
    key: "scale",
    value: function scale(t) {
      var e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z;
      return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this;
    }
  }, {
    key: "getMaxScaleOnAxis",
    value: function getMaxScaleOnAxis() {
      var t = this.elements,
        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, i));
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(t, e, n) {
      return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(t) {
      var e = Math.cos(t),
        n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeRotationY",
    value: function makeRotationY(t) {
      var e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeRotationZ",
    value: function makeRotationZ(t) {
      var e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeRotationAxis",
    value: function makeRotationAxis(t, e) {
      var n = Math.cos(e),
        i = Math.sin(e),
        r = 1 - n,
        s = t.x,
        a = t.y,
        o = t.z,
        l = r * s,
        c = r * a;
      return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeScale",
    value: function makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "makeShear",
    value: function makeShear(t, e, n, i, r, s) {
      return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
    }
  }, {
    key: "compose",
    value: function compose(t, e, n) {
      var i = this.elements,
        r = e._x,
        s = e._y,
        a = e._z,
        o = e._w,
        l = r + r,
        c = s + s,
        h = a + a,
        u = r * l,
        d = r * c,
        p = r * h,
        m = s * c,
        f = s * h,
        g = a * h,
        _ = o * l,
        v = o * c,
        x = o * h,
        y = n.x,
        M = n.y,
        S = n.z;
      return i[0] = (1 - (m + g)) * y, i[1] = (d + x) * y, i[2] = (p - v) * y, i[3] = 0, i[4] = (d - x) * M, i[5] = (1 - (u + g)) * M, i[6] = (f + _) * M, i[7] = 0, i[8] = (p + v) * S, i[9] = (f - _) * S, i[10] = (1 - (u + m)) * S, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this;
    }
  }, {
    key: "decompose",
    value: function decompose(t, e, n) {
      var i = this.elements;
      var r = cr.set(i[0], i[1], i[2]).length();
      var s = cr.set(i[4], i[5], i[6]).length(),
        a = cr.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], hr.copy(this);
      var o = 1 / r,
        l = 1 / s,
        c = 1 / a;
      return hr.elements[0] *= o, hr.elements[1] *= o, hr.elements[2] *= o, hr.elements[4] *= l, hr.elements[5] *= l, hr.elements[6] *= l, hr.elements[8] *= c, hr.elements[9] *= c, hr.elements[10] *= c, e.setFromRotationMatrix(hr), n.x = r, n.y = s, n.z = a, this;
    }
  }, {
    key: "makePerspective",
    value: function makePerspective(t, e, n, i, r, s) {
      var a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 2e3;
      var o = this.elements,
        l = 2 * r / (e - t),
        c = 2 * r / (n - i),
        h = (e + t) / (e - t),
        u = (n + i) / (n - i);
      var d, p;
      if (a === Fn) d = -(s + r) / (s - r), p = -2 * s * r / (s - r);else {
        if (a !== Bn) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        d = -s / (s - r), p = -s * r / (s - r);
      }
      return o[0] = l, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
    }
  }, {
    key: "makeOrthographic",
    value: function makeOrthographic(t, e, n, i, r, s) {
      var a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 2e3;
      var o = this.elements,
        l = 1 / (e - t),
        c = 1 / (n - i),
        h = 1 / (s - r),
        u = (e + t) * l,
        d = (n + i) * c;
      var p, m;
      if (a === Fn) p = (s + r) * h, m = -2 * h;else {
        if (a !== Bn) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        p = r * h, m = -1 * h;
      }
      return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = m, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      var e = this.elements,
        n = t.elements;
      for (var _t25 = 0; _t25 < 16; _t25++) if (e[_t25] !== n[_t25]) return !1;
      return !0;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var _n21 = 0; _n21 < 16; _n21++) this.elements[_n21] = t[_n21 + e];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
    }
  }]);
}();
var cr = new Ii(),
  hr = new lr(),
  ur = new Ii(0, 0, 0),
  dr = new Ii(1, 1, 1),
  pr = new Ii(),
  mr = new Ii(),
  fr = new Ii(),
  gr = new lr(),
  _r = new Li();
var vr = exports.Euler = /*#__PURE__*/function () {
  function vr() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vr.DEFAULT_ORDER;
    _classCallCheck(this, vr);
    this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i;
  }
  return _createClass(vr, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(t) {
      this._x = t, this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(t) {
      this._y = t, this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(t) {
      this._z = t, this._onChangeCallback();
    }
  }, {
    key: "order",
    get: function get() {
      return this._order;
    },
    set: function set(t) {
      this._order = t, this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(t, e, n) {
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._order;
      return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      var i = t.elements,
        r = i[0],
        s = i[4],
        a = i[8],
        o = i[1],
        l = i[5],
        c = i[9],
        h = i[2],
        u = i[6],
        d = i[10];
      switch (e) {
        case "XYZ":
          this._y = Math.asin(Xn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-Xn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(Xn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
          break;
        case "ZYX":
          this._y = Math.asin(-Xn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
          break;
        case "YZX":
          this._z = Math.asin(Xn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
          break;
        case "XZY":
          this._z = Math.asin(-Xn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
      }
      return this._order = e, !0 === n && this._onChangeCallback(), this;
    }
  }, {
    key: "setFromQuaternion",
    value: function setFromQuaternion(t, e, n) {
      return gr.makeRotationFromQuaternion(t), this.setFromRotationMatrix(gr, e, n);
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
      return this.set(t.x, t.y, t.z, e);
    }
  }, {
    key: "reorder",
    value: function reorder(t) {
      return _r.setFromEuler(this), this.setFromQuaternion(_r, t);
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    }
  }, {
    key: "_onChange",
    value: function _onChange(t) {
      return this._onChangeCallback = t, this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this._x;
          case 2:
            _context5.next = 4;
            return this._y;
          case 4:
            _context5.next = 6;
            return this._z;
          case 6:
            _context5.next = 8;
            return this._order;
          case 8:
          case "end":
            return _context5.stop();
        }
      }, value, this);
    })
  }]);
}();
vr.DEFAULT_ORDER = "XYZ";
var xr = exports.Layers = /*#__PURE__*/function () {
  function xr() {
    _classCallCheck(this, xr);
    this.mask = 1;
  }
  return _createClass(xr, [{
    key: "set",
    value: function set(t) {
      this.mask = (1 << t | 0) >>> 0;
    }
  }, {
    key: "enable",
    value: function enable(t) {
      this.mask |= 1 << t | 0;
    }
  }, {
    key: "enableAll",
    value: function enableAll() {
      this.mask = -1;
    }
  }, {
    key: "toggle",
    value: function toggle(t) {
      this.mask ^= 1 << t | 0;
    }
  }, {
    key: "disable",
    value: function disable(t) {
      this.mask &= ~(1 << t | 0);
    }
  }, {
    key: "disableAll",
    value: function disableAll() {
      this.mask = 0;
    }
  }, {
    key: "test",
    value: function test(t) {
      return 0 != (this.mask & t.mask);
    }
  }, {
    key: "isEnabled",
    value: function isEnabled(t) {
      return 0 != (this.mask & (1 << t | 0));
    }
  }]);
}();
var yr = 0;
var Mr = new Ii(),
  Sr = new Li(),
  br = new lr(),
  Er = new Ii(),
  Tr = new Ii(),
  wr = new Ii(),
  Ar = new Li(),
  Rr = new Ii(1, 0, 0),
  Cr = new Ii(0, 1, 0),
  Pr = new Ii(0, 0, 1),
  Lr = {
    type: "added"
  },
  Ir = {
    type: "removed"
  };
var Ur = exports.Object3D = /*#__PURE__*/function (_zn3) {
  function Ur() {
    var _this9;
    _classCallCheck(this, Ur);
    _this9 = _callSuper(this, Ur), _this9.isObject3D = !0, Object.defineProperty(_assertThisInitialized(_this9), "id", {
      value: yr++
    }), _this9.uuid = Wn(), _this9.name = "", _this9.type = "Object3D", _this9.parent = null, _this9.children = [], _this9.up = Ur.DEFAULT_UP.clone();
    var t = new Ii(),
      e = new vr(),
      n = new Li(),
      i = new Ii(1, 1, 1);
    e._onChange(function () {
      n.setFromEuler(e, !1);
    }), n._onChange(function () {
      e.setFromQuaternion(n, void 0, !1);
    }), Object.defineProperties(_this9, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new lr()
      },
      normalMatrix: {
        value: new ti()
      }
    }), _this9.matrix = new lr(), _this9.matrixWorld = new lr(), _this9.matrixAutoUpdate = Ur.DEFAULT_MATRIX_AUTO_UPDATE, _this9.matrixWorldAutoUpdate = Ur.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, _this9.matrixWorldNeedsUpdate = !1, _this9.layers = new xr(), _this9.visible = !0, _this9.castShadow = !1, _this9.receiveShadow = !1, _this9.frustumCulled = !0, _this9.renderOrder = 0, _this9.animations = [], _this9.userData = {};
    return _this9;
  }
  _inherits(Ur, _zn3);
  return _createClass(Ur, [{
    key: "onBeforeShadow",
    value: function onBeforeShadow() {}
  }, {
    key: "onAfterShadow",
    value: function onAfterShadow() {}
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender() {}
  }, {
    key: "onAfterRender",
    value: function onAfterRender() {}
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
  }, {
    key: "setRotationFromAxisAngle",
    value: function setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
  }, {
    key: "setRotationFromEuler",
    value: function setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }
  }, {
    key: "setRotationFromMatrix",
    value: function setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
  }, {
    key: "setRotationFromQuaternion",
    value: function setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
  }, {
    key: "rotateOnAxis",
    value: function rotateOnAxis(t, e) {
      return Sr.setFromAxisAngle(t, e), this.quaternion.multiply(Sr), this;
    }
  }, {
    key: "rotateOnWorldAxis",
    value: function rotateOnWorldAxis(t, e) {
      return Sr.setFromAxisAngle(t, e), this.quaternion.premultiply(Sr), this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(t) {
      return this.rotateOnAxis(Rr, t);
    }
  }, {
    key: "rotateY",
    value: function rotateY(t) {
      return this.rotateOnAxis(Cr, t);
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(t) {
      return this.rotateOnAxis(Pr, t);
    }
  }, {
    key: "translateOnAxis",
    value: function translateOnAxis(t, e) {
      return Mr.copy(t).applyQuaternion(this.quaternion), this.position.add(Mr.multiplyScalar(e)), this;
    }
  }, {
    key: "translateX",
    value: function translateX(t) {
      return this.translateOnAxis(Rr, t);
    }
  }, {
    key: "translateY",
    value: function translateY(t) {
      return this.translateOnAxis(Cr, t);
    }
  }, {
    key: "translateZ",
    value: function translateZ(t) {
      return this.translateOnAxis(Pr, t);
    }
  }, {
    key: "localToWorld",
    value: function localToWorld(t) {
      return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
    }
  }, {
    key: "worldToLocal",
    value: function worldToLocal(t) {
      return this.updateWorldMatrix(!0, !1), t.applyMatrix4(br.copy(this.matrixWorld).invert());
    }
  }, {
    key: "lookAt",
    value: function lookAt(t, e, n) {
      t.isVector3 ? Er.copy(t) : Er.set(t, e, n);
      var i = this.parent;
      this.updateWorldMatrix(!0, !1), Tr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? br.lookAt(Tr, Er, this.up) : br.lookAt(Er, Tr, this.up), this.quaternion.setFromRotationMatrix(br), i && (br.extractRotation(i.matrixWorld), Sr.setFromRotationMatrix(br), this.quaternion.premultiply(Sr.invert()));
    }
  }, {
    key: "add",
    value: function add(t) {
      if (arguments.length > 1) {
        for (var _t26 = 0; _t26 < arguments.length; _t26++) this.add(arguments[_t26]);
        return this;
      }
      return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Lr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
    }
  }, {
    key: "remove",
    value: function remove(t) {
      if (arguments.length > 1) {
        for (var _t27 = 0; _t27 < arguments.length; _t27++) this.remove(arguments[_t27]);
        return this;
      }
      var e = this.children.indexOf(t);
      return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Ir)), this;
    }
  }, {
    key: "removeFromParent",
    value: function removeFromParent() {
      var t = this.parent;
      return null !== t && t.remove(this), this;
    }
  }, {
    key: "clear",
    value: function clear() {
      return this.remove.apply(this, _toConsumableArray(this.children));
    }
  }, {
    key: "attach",
    value: function attach(t) {
      return this.updateWorldMatrix(!0, !1), br.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), br.multiply(t.parent.matrixWorld)), t.applyMatrix4(br), this.add(t), t.updateWorldMatrix(!1, !0), this;
    }
  }, {
    key: "getObjectById",
    value: function getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
  }, {
    key: "getObjectByName",
    value: function getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
  }, {
    key: "getObjectByProperty",
    value: function getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (var _n22 = 0, _i13 = this.children.length; _n22 < _i13; _n22++) {
        var _i14 = this.children[_n22].getObjectByProperty(t, e);
        if (void 0 !== _i14) return _i14;
      }
    }
  }, {
    key: "getObjectsByProperty",
    value: function getObjectsByProperty(t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      this[t] === e && n.push(this);
      var i = this.children;
      for (var _r13 = 0, _s4 = i.length; _r13 < _s4; _r13++) i[_r13].getObjectsByProperty(t, e, n);
      return n;
    }
  }, {
    key: "getWorldPosition",
    value: function getWorldPosition(t) {
      return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
    }
  }, {
    key: "getWorldQuaternion",
    value: function getWorldQuaternion(t) {
      return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Tr, t, wr), t;
    }
  }, {
    key: "getWorldScale",
    value: function getWorldScale(t) {
      return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Tr, Ar, t), t;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      var e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
  }, {
    key: "raycast",
    value: function raycast() {}
  }, {
    key: "traverse",
    value: function traverse(t) {
      t(this);
      var e = this.children;
      for (var _n23 = 0, _i15 = e.length; _n23 < _i15; _n23++) e[_n23].traverse(t);
    }
  }, {
    key: "traverseVisible",
    value: function traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      var e = this.children;
      for (var _n24 = 0, _i16 = e.length; _n24 < _i16; _n24++) e[_n24].traverseVisible(t);
    }
  }, {
    key: "traverseAncestors",
    value: function traverseAncestors(t) {
      var e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
      var e = this.children;
      for (var _n25 = 0, _i17 = e.length; _n25 < _i17; _n25++) {
        var _i18 = e[_n25];
        !0 !== _i18.matrixWorldAutoUpdate && !0 !== t || _i18.updateMatrixWorld(t);
      }
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(t, e) {
      var n = this.parent;
      if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
        var _t28 = this.children;
        for (var _e14 = 0, _n26 = _t28.length; _e14 < _n26; _e14++) {
          var _n27 = _t28[_e14];
          !0 === _n27.matrixWorldAutoUpdate && _n27.updateWorldMatrix(!1, !0);
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t,
        n = {};
      e && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      }, n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      var i = {};
      function r(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
      }
      if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map(function (t) {
        return {
          boxInitialized: t.boxInitialized,
          boxMin: t.box.min.toArray(),
          boxMax: t.box.max.toArray(),
          sphereInitialized: t.sphereInitialized,
          sphereRadius: t.sphere.radius,
          sphereCenter: t.sphere.center.toArray()
        };
      }), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(t), null !== this.boundingSphere && (i.boundingSphere = {
        center: i.boundingSphere.center.toArray(),
        radius: i.boundingSphere.radius
      }), null !== this.boundingBox && (i.boundingBox = {
        min: i.boundingBox.min.toArray(),
        max: i.boundingBox.max.toArray()
      })), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid);else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = r(t.geometries, this.geometry);
        var _e15 = this.geometry.parameters;
        if (void 0 !== _e15 && void 0 !== _e15.shapes) {
          var _n28 = _e15.shapes;
          if (Array.isArray(_n28)) for (var _e16 = 0, _i19 = _n28.length; _e16 < _i19; _e16++) {
            var _i20 = _n28[_e16];
            r(t.shapes, _i20);
          } else r(t.shapes, _n28);
        }
      }
      if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
        var _e17 = [];
        for (var _n29 = 0, _i21 = this.material.length; _n29 < _i21; _n29++) _e17.push(r(t.materials, this.material[_n29]));
        i.material = _e17;
      } else i.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (var _e18 = 0; _e18 < this.children.length; _e18++) i.children.push(this.children[_e18].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (var _e19 = 0; _e19 < this.animations.length; _e19++) {
          var _n30 = this.animations[_e19];
          i.animations.push(r(t.animations, _n30));
        }
      }
      if (e) {
        var _e20 = s(t.geometries),
          _i22 = s(t.materials),
          _r14 = s(t.textures),
          _a4 = s(t.images),
          _o4 = s(t.shapes),
          _l3 = s(t.skeletons),
          _c3 = s(t.animations),
          _h2 = s(t.nodes);
        _e20.length > 0 && (n.geometries = _e20), _i22.length > 0 && (n.materials = _i22), _r14.length > 0 && (n.textures = _r14), _a4.length > 0 && (n.images = _a4), _o4.length > 0 && (n.shapes = _o4), _l3.length > 0 && (n.skeletons = _l3), _c3.length > 0 && (n.animations = _c3), _h2.length > 0 && (n.nodes = _h2);
      }
      return n.object = i, n;
      function s(t) {
        var e = [];
        for (var _n31 in t) {
          var _i23 = t[_n31];
          delete _i23.metadata, e.push(_i23);
        }
        return e;
      }
    }
  }, {
    key: "clone",
    value: function clone(t) {
      return new this.constructor().copy(this, t);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (var _e21 = 0; _e21 < t.children.length; _e21++) {
        var _n32 = t.children[_e21];
        this.add(_n32.clone());
      }
      return this;
    }
  }]);
}(zn);
Ur.DEFAULT_UP = new Ii(0, 1, 0), Ur.DEFAULT_MATRIX_AUTO_UPDATE = !0, Ur.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
var Nr = new Ii(),
  Dr = new Ii(),
  Or = new Ii(),
  Fr = new Ii(),
  Br = new Ii(),
  zr = new Ii(),
  Hr = new Ii(),
  Vr = new Ii(),
  kr = new Ii(),
  Gr = new Ii();
var Wr = exports.Triangle = /*#__PURE__*/function () {
  function Wr() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Ii();
    _classCallCheck(this, Wr);
    this.a = t, this.b = e, this.c = n;
  }
  return _createClass(Wr, [{
    key: "set",
    value: function set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }
  }, {
    key: "setFromPointsAndIndices",
    value: function setFromPointsAndIndices(t, e, n, i) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
    }
  }, {
    key: "setFromAttributeAndIndices",
    value: function setFromAttributeAndIndices(t, e, n, i) {
      return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      return Nr.subVectors(this.c, this.b), Dr.subVectors(this.a, this.b), .5 * Nr.cross(Dr).length();
    }
  }, {
    key: "getMidpoint",
    value: function getMidpoint(t) {
      return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
  }, {
    key: "getNormal",
    value: function getNormal(t) {
      return Wr.getNormal(this.a, this.b, this.c, t);
    }
  }, {
    key: "getPlane",
    value: function getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
  }, {
    key: "getBarycoord",
    value: function getBarycoord(t, e) {
      return Wr.getBarycoord(t, this.a, this.b, this.c, e);
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation(t, e, n, i, r) {
      return Wr.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      return Wr.containsPoint(t, this.a, this.b, this.c);
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(t) {
      return Wr.isFrontFacing(this.a, this.b, this.c, t);
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(t, e) {
      var n = this.a,
        i = this.b,
        r = this.c;
      var s, a;
      Br.subVectors(i, n), zr.subVectors(r, n), Vr.subVectors(t, n);
      var o = Br.dot(Vr),
        l = zr.dot(Vr);
      if (o <= 0 && l <= 0) return e.copy(n);
      kr.subVectors(t, i);
      var c = Br.dot(kr),
        h = zr.dot(kr);
      if (c >= 0 && h <= c) return e.copy(i);
      var u = o * h - c * l;
      if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector(Br, s);
      Gr.subVectors(t, r);
      var d = Br.dot(Gr),
        p = zr.dot(Gr);
      if (p >= 0 && d <= p) return e.copy(r);
      var m = d * l - o * p;
      if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(zr, a);
      var f = c * p - d * h;
      if (f <= 0 && h - c >= 0 && d - p >= 0) return Hr.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(Hr, a);
      var g = 1 / (f + m + u);
      return s = m * g, a = u * g, e.copy(n).addScaledVector(Br, s).addScaledVector(zr, a);
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }], [{
    key: "getNormal",
    value: function getNormal(t, e, n, i) {
      i.subVectors(n, e), Nr.subVectors(t, e), i.cross(Nr);
      var r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
  }, {
    key: "getBarycoord",
    value: function getBarycoord(t, e, n, i, r) {
      Nr.subVectors(i, e), Dr.subVectors(n, e), Or.subVectors(t, e);
      var s = Nr.dot(Nr),
        a = Nr.dot(Dr),
        o = Nr.dot(Or),
        l = Dr.dot(Dr),
        c = Dr.dot(Or),
        h = s * l - a * a;
      if (0 === h) return r.set(0, 0, 0), null;
      var u = 1 / h,
        d = (l * o - a * c) * u,
        p = (s * c - a * o) * u;
      return r.set(1 - d - p, p, d);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t, e, n, i) {
      return null !== this.getBarycoord(t, e, n, i, Fr) && Fr.x >= 0 && Fr.y >= 0 && Fr.x + Fr.y <= 1;
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation(t, e, n, i, r, s, a, o) {
      return null === this.getBarycoord(t, e, n, i, Fr) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(r, Fr.x), o.addScaledVector(s, Fr.y), o.addScaledVector(a, Fr.z), o);
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(t, e, n, i) {
      return Nr.subVectors(n, e), Dr.subVectors(t, e), Nr.cross(Dr).dot(i) < 0;
    }
  }]);
}();
var Xr = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  },
  jr = {
    h: 0,
    s: 0,
    l: 0
  },
  qr = {
    h: 0,
    s: 0,
    l: 0
  };
function Yr(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t;
}
var Zr = exports.Color = /*#__PURE__*/function () {
  function Zr(t, e, n) {
    _classCallCheck(this, Zr);
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n);
  }
  return _createClass(Zr, [{
    key: "set",
    value: function set(t, e, n) {
      if (void 0 === e && void 0 === n) {
        var _e22 = t;
        _e22 && _e22.isColor ? this.copy(_e22) : "number" == typeof _e22 ? this.setHex(_e22) : "string" == typeof _e22 && this.setStyle(_e22);
      } else this.setRGB(t, e, n);
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(t) {
      return this.r = t, this.g = t, this.b = t, this;
    }
  }, {
    key: "setHex",
    value: function setHex(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : je;
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, pi.toWorkingColorSpace(this, e), this;
    }
  }, {
    key: "setRGB",
    value: function setRGB(t, e, n) {
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : pi.workingColorSpace;
      return this.r = t, this.g = e, this.b = n, pi.toWorkingColorSpace(this, i), this;
    }
  }, {
    key: "setHSL",
    value: function setHSL(t, e, n) {
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : pi.workingColorSpace;
      if (t = jn(t, 1), e = Xn(e, 0, 1), n = Xn(n, 0, 1), 0 === e) this.r = this.g = this.b = n;else {
        var _i24 = n <= .5 ? n * (1 + e) : n + e - n * e,
          _r15 = 2 * n - _i24;
        this.r = Yr(_r15, _i24, t + 1 / 3), this.g = Yr(_r15, _i24, t), this.b = Yr(_r15, _i24, t - 1 / 3);
      }
      return pi.toWorkingColorSpace(this, i), this;
    }
  }, {
    key: "setStyle",
    value: function setStyle(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : je;
      function n(e) {
        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
      }
      var i;
      if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
        var _r16;
        var _s5 = i[1],
          _a5 = i[2];
        switch (_s5) {
          case "rgb":
          case "rgba":
            if (_r16 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_a5)) return n(_r16[4]), this.setRGB(Math.min(255, parseInt(_r16[1], 10)) / 255, Math.min(255, parseInt(_r16[2], 10)) / 255, Math.min(255, parseInt(_r16[3], 10)) / 255, e);
            if (_r16 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_a5)) return n(_r16[4]), this.setRGB(Math.min(100, parseInt(_r16[1], 10)) / 100, Math.min(100, parseInt(_r16[2], 10)) / 100, Math.min(100, parseInt(_r16[3], 10)) / 100, e);
            break;
          case "hsl":
          case "hsla":
            if (_r16 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_a5)) return n(_r16[4]), this.setHSL(parseFloat(_r16[1]) / 360, parseFloat(_r16[2]) / 100, parseFloat(_r16[3]) / 100, e);
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + t);
        }
      } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
        var _n33 = i[1],
          _r17 = _n33.length;
        if (3 === _r17) return this.setRGB(parseInt(_n33.charAt(0), 16) / 15, parseInt(_n33.charAt(1), 16) / 15, parseInt(_n33.charAt(2), 16) / 15, e);
        if (6 === _r17) return this.setHex(parseInt(_n33, 16), e);
        console.warn("THREE.Color: Invalid hex color " + t);
      } else if (t && t.length > 0) return this.setColorName(t, e);
      return this;
    }
  }, {
    key: "setColorName",
    value: function setColorName(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : je;
      var n = Xr[t.toLowerCase()];
      return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this;
    }
  }, {
    key: "copySRGBToLinear",
    value: function copySRGBToLinear(t) {
      return this.r = mi(t.r), this.g = mi(t.g), this.b = mi(t.b), this;
    }
  }, {
    key: "copyLinearToSRGB",
    value: function copyLinearToSRGB(t) {
      return this.r = fi(t.r), this.g = fi(t.g), this.b = fi(t.b), this;
    }
  }, {
    key: "convertSRGBToLinear",
    value: function convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
  }, {
    key: "convertLinearToSRGB",
    value: function convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
  }, {
    key: "getHex",
    value: function getHex() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : je;
      return pi.fromWorkingColorSpace(Jr.copy(this), t), 65536 * Math.round(Xn(255 * Jr.r, 0, 255)) + 256 * Math.round(Xn(255 * Jr.g, 0, 255)) + Math.round(Xn(255 * Jr.b, 0, 255));
    }
  }, {
    key: "getHexString",
    value: function getHexString() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : je;
      return ("000000" + this.getHex(t).toString(16)).slice(-6);
    }
  }, {
    key: "getHSL",
    value: function getHSL(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pi.workingColorSpace;
      pi.fromWorkingColorSpace(Jr.copy(this), e);
      var n = Jr.r,
        i = Jr.g,
        r = Jr.b,
        s = Math.max(n, i, r),
        a = Math.min(n, i, r);
      var o, l;
      var c = (a + s) / 2;
      if (a === s) o = 0, l = 0;else {
        var _t29 = s - a;
        switch (l = c <= .5 ? _t29 / (s + a) : _t29 / (2 - s - a), s) {
          case n:
            o = (i - r) / _t29 + (i < r ? 6 : 0);
            break;
          case i:
            o = (r - n) / _t29 + 2;
            break;
          case r:
            o = (n - i) / _t29 + 4;
        }
        o /= 6;
      }
      return t.h = o, t.s = l, t.l = c, t;
    }
  }, {
    key: "getRGB",
    value: function getRGB(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pi.workingColorSpace;
      return pi.fromWorkingColorSpace(Jr.copy(this), e), t.r = Jr.r, t.g = Jr.g, t.b = Jr.b, t;
    }
  }, {
    key: "getStyle",
    value: function getStyle() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : je;
      pi.fromWorkingColorSpace(Jr.copy(this), t);
      var e = Jr.r,
        n = Jr.g,
        i = Jr.b;
      return t !== je ? "color(".concat(t, " ").concat(e.toFixed(3), " ").concat(n.toFixed(3), " ").concat(i.toFixed(3), ")") : "rgb(".concat(Math.round(255 * e), ",").concat(Math.round(255 * n), ",").concat(Math.round(255 * i), ")");
    }
  }, {
    key: "offsetHSL",
    value: function offsetHSL(t, e, n) {
      return this.getHSL(jr), this.setHSL(jr.h + t, jr.s + e, jr.l + n);
    }
  }, {
    key: "add",
    value: function add(t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this;
    }
  }, {
    key: "addColors",
    value: function addColors(t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(t) {
      return this.r += t, this.g += t, this.b += t, this;
    }
  }, {
    key: "sub",
    value: function sub(t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    }
  }, {
    key: "multiply",
    value: function multiply(t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(t) {
      return this.r *= t, this.g *= t, this.b *= t, this;
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
    }
  }, {
    key: "lerpColors",
    value: function lerpColors(t, e, n) {
      return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this;
    }
  }, {
    key: "lerpHSL",
    value: function lerpHSL(t, e) {
      this.getHSL(jr), t.getHSL(qr);
      var n = qn(jr.h, qr.h, e),
        i = qn(jr.s, qr.s, e),
        r = qn(jr.l, qr.l, e);
      return this.setHSL(n, i, r), this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(t) {
      return this.r = t.x, this.g = t.y, this.b = t.z, this;
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(t) {
      var e = this.r,
        n = this.g,
        i = this.b,
        r = t.elements;
      return this.r = r[0] * e + r[3] * n + r[6] * i, this.g = r[1] * e + r[4] * n + r[7] * i, this.b = r[2] * e + r[5] * n + r[8] * i, this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(t, e) {
      return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.getHex();
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.r;
          case 2:
            _context6.next = 4;
            return this.g;
          case 4:
            _context6.next = 6;
            return this.b;
          case 6:
          case "end":
            return _context6.stop();
        }
      }, value, this);
    })
  }]);
}();
var Jr = new Zr();
Zr.NAMES = Xr;
var Kr = 0;
var $r = exports.Material = /*#__PURE__*/function (_zn4) {
  function $r() {
    var _this10;
    _classCallCheck(this, $r);
    _this10 = _callSuper(this, $r), _this10.isMaterial = !0, Object.defineProperty(_assertThisInitialized(_this10), "id", {
      value: Kr++
    }), _this10.uuid = Wn(), _this10.name = "", _this10.type = "Material", _this10.blending = 1, _this10.side = u, _this10.vertexColors = !1, _this10.opacity = 1, _this10.transparent = !1, _this10.alphaHash = !1, _this10.blendSrc = C, _this10.blendDst = P, _this10.blendEquation = y, _this10.blendSrcAlpha = null, _this10.blendDstAlpha = null, _this10.blendEquationAlpha = null, _this10.blendColor = new Zr(0, 0, 0), _this10.blendAlpha = 0, _this10.depthFunc = 3, _this10.depthTest = !0, _this10.depthWrite = !0, _this10.stencilWriteMask = 255, _this10.stencilFunc = 519, _this10.stencilRef = 0, _this10.stencilFuncMask = 255, _this10.stencilFail = en, _this10.stencilZFail = en, _this10.stencilZPass = en, _this10.stencilWrite = !1, _this10.clippingPlanes = null, _this10.clipIntersection = !1, _this10.clipShadows = !1, _this10.shadowSide = null, _this10.colorWrite = !0, _this10.precision = null, _this10.polygonOffset = !1, _this10.polygonOffsetFactor = 0, _this10.polygonOffsetUnits = 0, _this10.dithering = !1, _this10.alphaToCoverage = !1, _this10.premultipliedAlpha = !1, _this10.forceSinglePass = !1, _this10.visible = !0, _this10.toneMapped = !0, _this10.userData = {}, _this10.version = 0, _this10._alphaTest = 0;
    return _this10;
  }
  _inherits($r, _zn4);
  return _createClass($r, [{
    key: "alphaTest",
    get: function get() {
      return this._alphaTest;
    },
    set: function set(t) {
      this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
    }
  }, {
    key: "onBuild",
    value: function onBuild() {}
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender() {}
  }, {
    key: "onBeforeCompile",
    value: function onBeforeCompile() {}
  }, {
    key: "customProgramCacheKey",
    value: function customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
  }, {
    key: "setValues",
    value: function setValues(t) {
      if (void 0 !== t) for (var _e23 in t) {
        var _n34 = t[_e23];
        if (void 0 === _n34) {
          console.warn("THREE.Material: parameter '".concat(_e23, "' has value of undefined."));
          continue;
        }
        var _i25 = this[_e23];
        void 0 !== _i25 ? _i25 && _i25.isColor ? _i25.set(_n34) : _i25 && _i25.isVector3 && _n34 && _n34.isVector3 ? _i25.copy(_n34) : this[_e23] = _n34 : console.warn("THREE.Material: '".concat(_e23, "' is not a property of THREE.").concat(this.type, "."));
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t;
      e && (t = {
        textures: {},
        images: {}
      });
      var n = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      function i(t) {
        var e = [];
        for (var _n35 in t) {
          var _i26 = t[_n35];
          delete _i26.metadata, e.push(_i26);
        }
        return e;
      }
      if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), this.side !== u && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), this.blendSrc !== C && (n.blendSrc = this.blendSrc), this.blendDst !== P && (n.blendDst = this.blendDst), this.blendEquation !== y && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== en && (n.stencilFail = this.stencilFail), this.stencilZFail !== en && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== en && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) {
        var _e24 = i(t.textures),
          _r18 = i(t.images);
        _e24.length > 0 && (n.textures = _e24), _r18.length > 0 && (n.images = _r18);
      }
      return n;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
      var e = t.clippingPlanes;
      var n = null;
      if (null !== e) {
        var _t30 = e.length;
        n = new Array(_t30);
        for (var _i27 = 0; _i27 !== _t30; ++_i27) n[_i27] = e[_i27].clone();
      }
      return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }, {
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && this.version++;
    }
  }]);
}(zn);
var Qr = exports.MeshBasicMaterial = /*#__PURE__*/function (_$r) {
  function Qr(t) {
    var _this11;
    _classCallCheck(this, Qr);
    _this11 = _callSuper(this, Qr), _this11.isMeshBasicMaterial = !0, _this11.type = "MeshBasicMaterial", _this11.color = new Zr(16777215), _this11.map = null, _this11.lightMap = null, _this11.lightMapIntensity = 1, _this11.aoMap = null, _this11.aoMapIntensity = 1, _this11.specularMap = null, _this11.alphaMap = null, _this11.envMap = null, _this11.combine = Y, _this11.reflectivity = 1, _this11.refractionRatio = .98, _this11.wireframe = !1, _this11.wireframeLinewidth = 1, _this11.wireframeLinecap = "round", _this11.wireframeLinejoin = "round", _this11.fog = !0, _this11.setValues(t);
    return _this11;
  }
  _inherits(Qr, _$r);
  return _createClass(Qr, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Qr.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
    }
  }]);
}($r);
var ts = es();
function es() {
  var t = new ArrayBuffer(4),
    e = new Float32Array(t),
    n = new Uint32Array(t),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (var _t31 = 0; _t31 < 256; ++_t31) {
    var _e25 = _t31 - 127;
    _e25 < -27 ? (i[_t31] = 0, i[256 | _t31] = 32768, r[_t31] = 24, r[256 | _t31] = 24) : _e25 < -14 ? (i[_t31] = 1024 >> -_e25 - 14, i[256 | _t31] = 1024 >> -_e25 - 14 | 32768, r[_t31] = -_e25 - 1, r[256 | _t31] = -_e25 - 1) : _e25 <= 15 ? (i[_t31] = _e25 + 15 << 10, i[256 | _t31] = _e25 + 15 << 10 | 32768, r[_t31] = 13, r[256 | _t31] = 13) : _e25 < 128 ? (i[_t31] = 31744, i[256 | _t31] = 64512, r[_t31] = 24, r[256 | _t31] = 24) : (i[_t31] = 31744, i[256 | _t31] = 64512, r[_t31] = 13, r[256 | _t31] = 13);
  }
  var s = new Uint32Array(2048),
    a = new Uint32Array(64),
    o = new Uint32Array(64);
  for (var _t32 = 1; _t32 < 1024; ++_t32) {
    var _e26 = _t32 << 13,
      _n36 = 0;
    for (; 0 == (8388608 & _e26);) _e26 <<= 1, _n36 -= 8388608;
    _e26 &= -8388609, _n36 += 947912704, s[_t32] = _e26 | _n36;
  }
  for (var _t33 = 1024; _t33 < 2048; ++_t33) s[_t33] = 939524096 + (_t33 - 1024 << 13);
  for (var _t34 = 1; _t34 < 31; ++_t34) a[_t34] = _t34 << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (var _t35 = 33; _t35 < 63; ++_t35) a[_t35] = 2147483648 + (_t35 - 32 << 23);
  a[63] = 3347054592;
  for (var _t36 = 1; _t36 < 64; ++_t36) 32 !== _t36 && (o[_t36] = 1024);
  return {
    floatView: e,
    uint32View: n,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: a,
    offsetTable: o
  };
}
function ns(t) {
  Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t = Xn(t, -65504, 65504), ts.floatView[0] = t;
  var e = ts.uint32View[0],
    n = e >> 23 & 511;
  return ts.baseTable[n] + ((8388607 & e) >> ts.shiftTable[n]);
}
function is(t) {
  var e = t >> 10;
  return ts.uint32View[0] = ts.mantissaTable[ts.offsetTable[e] + (1023 & t)] + ts.exponentTable[e], ts.floatView[0];
}
var rs = exports.DataUtils = {
    toHalfFloat: ns,
    fromHalfFloat: is
  },
  ss = new Ii(),
  as = new Qn();
var os = exports.BufferAttribute = /*#__PURE__*/function () {
  function os(t, e) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    _classCallCheck(this, os);
    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n, this.usage = Tn, this._updateRange = {
      offset: 0,
      count: -1
    }, this.updateRanges = [], this.gpuType = Lt, this.version = 0;
  }
  return _createClass(os, [{
    key: "onUploadCallback",
    value: function onUploadCallback() {}
  }, {
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && this.version++;
    }
  }, {
    key: "updateRange",
    get: function get() {
      return li("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
    }
  }, {
    key: "setUsage",
    value: function setUsage(t) {
      return this.usage = t, this;
    }
  }, {
    key: "addUpdateRange",
    value: function addUpdateRange(t, e) {
      this.updateRanges.push({
        start: t,
        count: e
      });
    }
  }, {
    key: "clearUpdateRanges",
    value: function clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(t, e, n) {
      t *= this.itemSize, n *= e.itemSize;
      for (var _i28 = 0, _r19 = this.itemSize; _i28 < _r19; _i28++) this.array[t + _i28] = e.array[n + _i28];
      return this;
    }
  }, {
    key: "copyArray",
    value: function copyArray(t) {
      return this.array.set(t), this;
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(t) {
      if (2 === this.itemSize) for (var _e27 = 0, _n37 = this.count; _e27 < _n37; _e27++) as.fromBufferAttribute(this, _e27), as.applyMatrix3(t), this.setXY(_e27, as.x, as.y);else if (3 === this.itemSize) for (var _e28 = 0, _n38 = this.count; _e28 < _n38; _e28++) ss.fromBufferAttribute(this, _e28), ss.applyMatrix3(t), this.setXYZ(_e28, ss.x, ss.y, ss.z);
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      for (var _e29 = 0, _n39 = this.count; _e29 < _n39; _e29++) ss.fromBufferAttribute(this, _e29), ss.applyMatrix4(t), this.setXYZ(_e29, ss.x, ss.y, ss.z);
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(t) {
      for (var _e30 = 0, _n40 = this.count; _e30 < _n40; _e30++) ss.fromBufferAttribute(this, _e30), ss.applyNormalMatrix(t), this.setXYZ(_e30, ss.x, ss.y, ss.z);
      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(t) {
      for (var _e31 = 0, _n41 = this.count; _e31 < _n41; _e31++) ss.fromBufferAttribute(this, _e31), ss.transformDirection(t), this.setXYZ(_e31, ss.x, ss.y, ss.z);
      return this;
    }
  }, {
    key: "set",
    value: function set(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.array.set(t, e), this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(t, e) {
      var n = this.array[t * this.itemSize + e];
      return this.normalized && (n = Jn(n, this.array)), n;
    }
  }, {
    key: "setComponent",
    value: function setComponent(t, e, n) {
      return this.normalized && (n = Kn(n, this.array)), this.array[t * this.itemSize + e] = n, this;
    }
  }, {
    key: "getX",
    value: function getX(t) {
      var e = this.array[t * this.itemSize];
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setX",
    value: function setX(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.array[t * this.itemSize] = e, this;
    }
  }, {
    key: "getY",
    value: function getY(t) {
      var e = this.array[t * this.itemSize + 1];
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setY",
    value: function setY(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
    }
  }, {
    key: "getZ",
    value: function getZ(t) {
      var e = this.array[t * this.itemSize + 2];
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setZ",
    value: function setZ(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
    }
  }, {
    key: "getW",
    value: function getW(t) {
      var e = this.array[t * this.itemSize + 3];
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setW",
    value: function setW(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
    }
  }, {
    key: "setXY",
    value: function setXY(t, e, n) {
      return t *= this.itemSize, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(t, e, n, i) {
      return t *= this.itemSize, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array), i = Kn(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(t, e, n, i, r) {
      return t *= this.itemSize, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array), i = Kn(i, this.array), r = Kn(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this;
    }
  }, {
    key: "onUpload",
    value: function onUpload(t) {
      return this.onUploadCallback = t, this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      return "" !== this.name && (t.name = this.name), this.usage !== Tn && (t.usage = this.usage), t;
    }
  }]);
}();
var ls = exports.Int8BufferAttribute = /*#__PURE__*/function (_os) {
  function ls(t, e, n) {
    _classCallCheck(this, ls);
    return _callSuper(this, ls, [new Int8Array(t), e, n]);
  }
  _inherits(ls, _os);
  return _createClass(ls);
}(os);
var cs = exports.Uint8BufferAttribute = /*#__PURE__*/function (_os2) {
  function cs(t, e, n) {
    _classCallCheck(this, cs);
    return _callSuper(this, cs, [new Uint8Array(t), e, n]);
  }
  _inherits(cs, _os2);
  return _createClass(cs);
}(os);
var hs = exports.Uint8ClampedBufferAttribute = /*#__PURE__*/function (_os3) {
  function hs(t, e, n) {
    _classCallCheck(this, hs);
    return _callSuper(this, hs, [new Uint8ClampedArray(t), e, n]);
  }
  _inherits(hs, _os3);
  return _createClass(hs);
}(os);
var us = exports.Int16BufferAttribute = /*#__PURE__*/function (_os4) {
  function us(t, e, n) {
    _classCallCheck(this, us);
    return _callSuper(this, us, [new Int16Array(t), e, n]);
  }
  _inherits(us, _os4);
  return _createClass(us);
}(os);
var ds = exports.Uint16BufferAttribute = /*#__PURE__*/function (_os5) {
  function ds(t, e, n) {
    _classCallCheck(this, ds);
    return _callSuper(this, ds, [new Uint16Array(t), e, n]);
  }
  _inherits(ds, _os5);
  return _createClass(ds);
}(os);
var ps = exports.Int32BufferAttribute = /*#__PURE__*/function (_os6) {
  function ps(t, e, n) {
    _classCallCheck(this, ps);
    return _callSuper(this, ps, [new Int32Array(t), e, n]);
  }
  _inherits(ps, _os6);
  return _createClass(ps);
}(os);
var ms = exports.Uint32BufferAttribute = /*#__PURE__*/function (_os7) {
  function ms(t, e, n) {
    _classCallCheck(this, ms);
    return _callSuper(this, ms, [new Uint32Array(t), e, n]);
  }
  _inherits(ms, _os7);
  return _createClass(ms);
}(os);
var fs = exports.Float16BufferAttribute = /*#__PURE__*/function (_os8) {
  function fs(t, e, n) {
    var _this12;
    _classCallCheck(this, fs);
    _this12 = _callSuper(this, fs, [new Uint16Array(t), e, n]), _this12.isFloat16BufferAttribute = !0;
    return _this12;
  }
  _inherits(fs, _os8);
  return _createClass(fs, [{
    key: "getX",
    value: function getX(t) {
      var e = is(this.array[t * this.itemSize]);
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setX",
    value: function setX(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.array[t * this.itemSize] = ns(e), this;
    }
  }, {
    key: "getY",
    value: function getY(t) {
      var e = is(this.array[t * this.itemSize + 1]);
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setY",
    value: function setY(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.array[t * this.itemSize + 1] = ns(e), this;
    }
  }, {
    key: "getZ",
    value: function getZ(t) {
      var e = is(this.array[t * this.itemSize + 2]);
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setZ",
    value: function setZ(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.array[t * this.itemSize + 2] = ns(e), this;
    }
  }, {
    key: "getW",
    value: function getW(t) {
      var e = is(this.array[t * this.itemSize + 3]);
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setW",
    value: function setW(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.array[t * this.itemSize + 3] = ns(e), this;
    }
  }, {
    key: "setXY",
    value: function setXY(t, e, n) {
      return t *= this.itemSize, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array)), this.array[t + 0] = ns(e), this.array[t + 1] = ns(n), this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(t, e, n, i) {
      return t *= this.itemSize, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array), i = Kn(i, this.array)), this.array[t + 0] = ns(e), this.array[t + 1] = ns(n), this.array[t + 2] = ns(i), this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(t, e, n, i, r) {
      return t *= this.itemSize, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array), i = Kn(i, this.array), r = Kn(r, this.array)), this.array[t + 0] = ns(e), this.array[t + 1] = ns(n), this.array[t + 2] = ns(i), this.array[t + 3] = ns(r), this;
    }
  }]);
}(os);
var gs = exports.Float32BufferAttribute = /*#__PURE__*/function (_os9) {
  function gs(t, e, n) {
    _classCallCheck(this, gs);
    return _callSuper(this, gs, [new Float32Array(t), e, n]);
  }
  _inherits(gs, _os9);
  return _createClass(gs);
}(os);
var _s = exports.Float64BufferAttribute = /*#__PURE__*/function (_os10) {
  function _s(t, e, n) {
    _classCallCheck(this, _s);
    return _callSuper(this, _s, [new Float64Array(t), e, n]);
  }
  _inherits(_s, _os10);
  return _createClass(_s);
}(os);
var vs = 0;
var xs = new lr(),
  ys = new Ur(),
  Ms = new Ii(),
  Ss = new Di(),
  bs = new Di(),
  Es = new Ii();
var Ts = exports.BufferGeometry = /*#__PURE__*/function (_zn5) {
  function Ts() {
    var _this13;
    _classCallCheck(this, Ts);
    _this13 = _callSuper(this, Ts), _this13.isBufferGeometry = !0, Object.defineProperty(_assertThisInitialized(_this13), "id", {
      value: vs++
    }), _this13.uuid = Wn(), _this13.name = "", _this13.type = "BufferGeometry", _this13.index = null, _this13.attributes = {}, _this13.morphAttributes = {}, _this13.morphTargetsRelative = !1, _this13.groups = [], _this13.boundingBox = null, _this13.boundingSphere = null, _this13.drawRange = {
      start: 0,
      count: 1 / 0
    }, _this13.userData = {};
    return _this13;
  }
  _inherits(Ts, _zn5);
  return _createClass(Ts, [{
    key: "getIndex",
    value: function getIndex() {
      return this.index;
    }
  }, {
    key: "setIndex",
    value: function setIndex(t) {
      return Array.isArray(t) ? this.index = new (ni(t) ? ms : ds)(t, 1) : this.index = t, this;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(t) {
      return this.attributes[t];
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(t, e) {
      return this.attributes[t] = e, this;
    }
  }, {
    key: "deleteAttribute",
    value: function deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
  }, {
    key: "hasAttribute",
    value: function hasAttribute(t) {
      return void 0 !== this.attributes[t];
    }
  }, {
    key: "addGroup",
    value: function addGroup(t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.groups.push({
        start: t,
        count: e,
        materialIndex: n
      });
    }
  }, {
    key: "clearGroups",
    value: function clearGroups() {
      this.groups = [];
    }
  }, {
    key: "setDrawRange",
    value: function setDrawRange(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      var e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
      var n = this.attributes.normal;
      if (void 0 !== n) {
        var _e32 = new ti().getNormalMatrix(t);
        n.applyNormalMatrix(_e32), n.needsUpdate = !0;
      }
      var i = this.attributes.tangent;
      return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(t) {
      return xs.makeRotationFromQuaternion(t), this.applyMatrix4(xs), this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(t) {
      return xs.makeRotationX(t), this.applyMatrix4(xs), this;
    }
  }, {
    key: "rotateY",
    value: function rotateY(t) {
      return xs.makeRotationY(t), this.applyMatrix4(xs), this;
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(t) {
      return xs.makeRotationZ(t), this.applyMatrix4(xs), this;
    }
  }, {
    key: "translate",
    value: function translate(t, e, n) {
      return xs.makeTranslation(t, e, n), this.applyMatrix4(xs), this;
    }
  }, {
    key: "scale",
    value: function scale(t, e, n) {
      return xs.makeScale(t, e, n), this.applyMatrix4(xs), this;
    }
  }, {
    key: "lookAt",
    value: function lookAt(t) {
      return ys.lookAt(t), ys.updateMatrix(), this.applyMatrix4(ys.matrix), this;
    }
  }, {
    key: "center",
    value: function center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(Ms).negate(), this.translate(Ms.x, Ms.y, Ms.z), this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(t) {
      var e = [];
      for (var _n42 = 0, _i29 = t.length; _n42 < _i29; _n42++) {
        var _i30 = t[_n42];
        e.push(_i30.x, _i30.y, _i30.z || 0);
      }
      return this.setAttribute("position", new gs(e, 3)), this;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new Di());
      var t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Ii(-1 / 0, -1 / 0, -1 / 0), new Ii(1 / 0, 1 / 0, 1 / 0));
      if (void 0 !== t) {
        if (this.boundingBox.setFromBufferAttribute(t), e) for (var _t37 = 0, _n43 = e.length; _t37 < _n43; _t37++) {
          var _n44 = e[_t37];
          Ss.setFromBufferAttribute(_n44), this.morphTargetsRelative ? (Es.addVectors(this.boundingBox.min, Ss.min), this.boundingBox.expandByPoint(Es), Es.addVectors(this.boundingBox.max, Ss.max), this.boundingBox.expandByPoint(Es)) : (this.boundingBox.expandByPoint(Ss.min), this.boundingBox.expandByPoint(Ss.max));
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new Qi());
      var t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Ii(), 1 / 0);
      if (t) {
        var _n45 = this.boundingSphere.center;
        if (Ss.setFromBufferAttribute(t), e) for (var _t38 = 0, _n46 = e.length; _t38 < _n46; _t38++) {
          var _n47 = e[_t38];
          bs.setFromBufferAttribute(_n47), this.morphTargetsRelative ? (Es.addVectors(Ss.min, bs.min), Ss.expandByPoint(Es), Es.addVectors(Ss.max, bs.max), Ss.expandByPoint(Es)) : (Ss.expandByPoint(bs.min), Ss.expandByPoint(bs.max));
        }
        Ss.getCenter(_n45);
        var _i31 = 0;
        for (var _e33 = 0, _r20 = t.count; _e33 < _r20; _e33++) Es.fromBufferAttribute(t, _e33), _i31 = Math.max(_i31, _n45.distanceToSquared(Es));
        if (e) for (var _r21 = 0, _s6 = e.length; _r21 < _s6; _r21++) {
          var _s7 = e[_r21],
            _a6 = this.morphTargetsRelative;
          for (var _e34 = 0, _r22 = _s7.count; _e34 < _r22; _e34++) Es.fromBufferAttribute(_s7, _e34), _a6 && (Ms.fromBufferAttribute(t, _e34), Es.add(Ms)), _i31 = Math.max(_i31, _n45.distanceToSquared(Es));
        }
        this.boundingSphere.radius = Math.sqrt(_i31), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }, {
    key: "computeTangents",
    value: function computeTangents() {
      var t = this.index,
        e = this.attributes;
      if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      var n = t.array,
        i = e.position.array,
        r = e.normal.array,
        s = e.uv.array,
        a = i.length / 3;
      !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new os(new Float32Array(4 * a), 4));
      var o = this.getAttribute("tangent").array,
        l = [],
        c = [];
      for (var _t39 = 0; _t39 < a; _t39++) l[_t39] = new Ii(), c[_t39] = new Ii();
      var h = new Ii(),
        u = new Ii(),
        d = new Ii(),
        p = new Qn(),
        m = new Qn(),
        f = new Qn(),
        g = new Ii(),
        _ = new Ii();
      function v(t, e, n) {
        h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
        var r = 1 / (m.x * f.y - f.x * m.y);
        isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), _.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(_), c[e].add(_), c[n].add(_));
      }
      var x = this.groups;
      0 === x.length && (x = [{
        start: 0,
        count: n.length
      }]);
      for (var _t40 = 0, _e35 = x.length; _t40 < _e35; ++_t40) {
        var _e36 = x[_t40],
          _i32 = _e36.start;
        for (var _t41 = _i32, _r23 = _i32 + _e36.count; _t41 < _r23; _t41 += 3) v(n[_t41 + 0], n[_t41 + 1], n[_t41 + 2]);
      }
      var y = new Ii(),
        M = new Ii(),
        S = new Ii(),
        b = new Ii();
      function E(t) {
        S.fromArray(r, 3 * t), b.copy(S);
        var e = l[t];
        y.copy(e), y.sub(S.multiplyScalar(S.dot(e))).normalize(), M.crossVectors(b, e);
        var n = M.dot(c[t]) < 0 ? -1 : 1;
        o[4 * t] = y.x, o[4 * t + 1] = y.y, o[4 * t + 2] = y.z, o[4 * t + 3] = n;
      }
      for (var _t42 = 0, _e37 = x.length; _t42 < _e37; ++_t42) {
        var _e38 = x[_t42],
          _i33 = _e38.start;
        for (var _t43 = _i33, _r24 = _i33 + _e38.count; _t43 < _r24; _t43 += 3) E(n[_t43 + 0]), E(n[_t43 + 1]), E(n[_t43 + 2]);
      }
    }
  }, {
    key: "computeVertexNormals",
    value: function computeVertexNormals() {
      var t = this.index,
        e = this.getAttribute("position");
      if (void 0 !== e) {
        var _n48 = this.getAttribute("normal");
        if (void 0 === _n48) _n48 = new os(new Float32Array(3 * e.count), 3), this.setAttribute("normal", _n48);else for (var _t44 = 0, _e39 = _n48.count; _t44 < _e39; _t44++) _n48.setXYZ(_t44, 0, 0, 0);
        var _i34 = new Ii(),
          _r25 = new Ii(),
          _s8 = new Ii(),
          _a7 = new Ii(),
          _o5 = new Ii(),
          _l4 = new Ii(),
          _c4 = new Ii(),
          _h3 = new Ii();
        if (t) for (var _u2 = 0, _d2 = t.count; _u2 < _d2; _u2 += 3) {
          var _d3 = t.getX(_u2 + 0),
            _p2 = t.getX(_u2 + 1),
            _m2 = t.getX(_u2 + 2);
          _i34.fromBufferAttribute(e, _d3), _r25.fromBufferAttribute(e, _p2), _s8.fromBufferAttribute(e, _m2), _c4.subVectors(_s8, _r25), _h3.subVectors(_i34, _r25), _c4.cross(_h3), _a7.fromBufferAttribute(_n48, _d3), _o5.fromBufferAttribute(_n48, _p2), _l4.fromBufferAttribute(_n48, _m2), _a7.add(_c4), _o5.add(_c4), _l4.add(_c4), _n48.setXYZ(_d3, _a7.x, _a7.y, _a7.z), _n48.setXYZ(_p2, _o5.x, _o5.y, _o5.z), _n48.setXYZ(_m2, _l4.x, _l4.y, _l4.z);
        } else for (var _t45 = 0, _a8 = e.count; _t45 < _a8; _t45 += 3) _i34.fromBufferAttribute(e, _t45 + 0), _r25.fromBufferAttribute(e, _t45 + 1), _s8.fromBufferAttribute(e, _t45 + 2), _c4.subVectors(_s8, _r25), _h3.subVectors(_i34, _r25), _c4.cross(_h3), _n48.setXYZ(_t45 + 0, _c4.x, _c4.y, _c4.z), _n48.setXYZ(_t45 + 1, _c4.x, _c4.y, _c4.z), _n48.setXYZ(_t45 + 2, _c4.x, _c4.y, _c4.z);
        this.normalizeNormals(), _n48.needsUpdate = !0;
      }
    }
  }, {
    key: "normalizeNormals",
    value: function normalizeNormals() {
      var t = this.attributes.normal;
      for (var _e40 = 0, _n49 = t.count; _e40 < _n49; _e40++) Es.fromBufferAttribute(t, _e40), Es.normalize(), t.setXYZ(_e40, Es.x, Es.y, Es.z);
    }
  }, {
    key: "toNonIndexed",
    value: function toNonIndexed() {
      function t(t, e) {
        var n = t.array,
          i = t.itemSize,
          r = t.normalized,
          s = new n.constructor(e.length * i);
        var a = 0,
          o = 0;
        for (var _r26 = 0, _l5 = e.length; _r26 < _l5; _r26++) {
          a = t.isInterleavedBufferAttribute ? e[_r26] * t.data.stride + t.offset : e[_r26] * i;
          for (var _t46 = 0; _t46 < i; _t46++) s[o++] = n[a++];
        }
        return new os(s, i, r);
      }
      if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      var e = new Ts(),
        n = this.index.array,
        i = this.attributes;
      for (var _r27 in i) {
        var _s9 = t(i[_r27], n);
        e.setAttribute(_r27, _s9);
      }
      var r = this.morphAttributes;
      for (var _i35 in r) {
        var _s10 = [],
          _a9 = r[_i35];
        for (var _e41 = 0, _i36 = _a9.length; _e41 < _i36; _e41++) {
          var _i37 = t(_a9[_e41], n);
          _s10.push(_i37);
        }
        e.morphAttributes[_i35] = _s10;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      var s = this.groups;
      for (var _t47 = 0, _n50 = s.length; _t47 < _n50; _t47++) {
        var _n51 = s[_t47];
        e.addGroup(_n51.start, _n51.count, _n51.materialIndex);
      }
      return e;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
        var _e42 = this.parameters;
        for (var _n52 in _e42) void 0 !== _e42[_n52] && (t[_n52] = _e42[_n52]);
        return t;
      }
      t.data = {
        attributes: {}
      };
      var e = this.index;
      null !== e && (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array)
      });
      var n = this.attributes;
      for (var _e43 in n) {
        var _i38 = n[_e43];
        t.data.attributes[_e43] = _i38.toJSON(t.data);
      }
      var i = {};
      var r = !1;
      for (var _e44 in this.morphAttributes) {
        var _n53 = this.morphAttributes[_e44],
          _s11 = [];
        for (var _e45 = 0, _i39 = _n53.length; _e45 < _i39; _e45++) {
          var _i40 = _n53[_e45];
          _s11.push(_i40.toJSON(t.data));
        }
        _s11.length > 0 && (i[_e44] = _s11, r = !0);
      }
      r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
      var s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      var a = this.boundingSphere;
      return null !== a && (t.data.boundingSphere = {
        center: a.center.toArray(),
        radius: a.radius
      }), t;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      var e = {};
      this.name = t.name;
      var n = t.index;
      null !== n && this.setIndex(n.clone(e));
      var i = t.attributes;
      for (var _t48 in i) {
        var _n54 = i[_t48];
        this.setAttribute(_t48, _n54.clone(e));
      }
      var r = t.morphAttributes;
      for (var _t49 in r) {
        var _n55 = [],
          _i41 = r[_t49];
        for (var _t50 = 0, _r28 = _i41.length; _t50 < _r28; _t50++) _n55.push(_i41[_t50].clone(e));
        this.morphAttributes[_t49] = _n55;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      var s = t.groups;
      for (var _t51 = 0, _e46 = s.length; _t51 < _e46; _t51++) {
        var _e47 = s[_t51];
        this.addGroup(_e47.start, _e47.count, _e47.materialIndex);
      }
      var a = t.boundingBox;
      null !== a && (this.boundingBox = a.clone());
      var o = t.boundingSphere;
      return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }]);
}(zn);
var ws = new lr(),
  As = new or(),
  Rs = new Qi(),
  Cs = new Ii(),
  Ps = new Ii(),
  Ls = new Ii(),
  Is = new Ii(),
  Us = new Ii(),
  Ns = new Ii(),
  Ds = new Qn(),
  Os = new Qn(),
  Fs = new Qn(),
  Bs = new Ii(),
  zs = new Ii(),
  Hs = new Ii(),
  Vs = new Ii(),
  ks = new Ii();
var Gs = exports.Mesh = /*#__PURE__*/function (_Ur) {
  function Gs() {
    var _this14;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ts();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qr();
    _classCallCheck(this, Gs);
    _this14 = _callSuper(this, Gs), _this14.isMesh = !0, _this14.type = "Mesh", _this14.geometry = t, _this14.material = e, _this14.updateMorphTargets();
    return _this14;
  }
  _inherits(Gs, _Ur);
  return _createClass(Gs, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Gs.prototype), "copy", this).call(this, t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        var _n56 = t[e[0]];
        if (void 0 !== _n56) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (var _t52 = 0, _e48 = _n56.length; _t52 < _e48; _t52++) {
            var _e49 = _n56[_t52].name || String(_t52);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[_e49] = _t52;
          }
        }
      }
    }
  }, {
    key: "getVertexPosition",
    value: function getVertexPosition(t, e) {
      var n = this.geometry,
        i = n.attributes.position,
        r = n.morphAttributes.position,
        s = n.morphTargetsRelative;
      e.fromBufferAttribute(i, t);
      var a = this.morphTargetInfluences;
      if (r && a) {
        Ns.set(0, 0, 0);
        for (var _n57 = 0, _i42 = r.length; _n57 < _i42; _n57++) {
          var _i43 = a[_n57],
            _o6 = r[_n57];
          0 !== _i43 && (Us.fromBufferAttribute(_o6, t), s ? Ns.addScaledVector(Us, _i43) : Ns.addScaledVector(Us.sub(e), _i43));
        }
        e.add(Ns);
      }
      return e;
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this.geometry,
        i = this.material,
        r = this.matrixWorld;
      if (void 0 !== i) {
        if (null === n.boundingSphere && n.computeBoundingSphere(), Rs.copy(n.boundingSphere), Rs.applyMatrix4(r), As.copy(t.ray).recast(t.near), !1 === Rs.containsPoint(As.origin)) {
          if (null === As.intersectSphere(Rs, Cs)) return;
          if (As.origin.distanceToSquared(Cs) > Math.pow(t.far - t.near, 2)) return;
        }
        ws.copy(r).invert(), As.copy(t.ray).applyMatrix4(ws), null !== n.boundingBox && !1 === As.intersectsBox(n.boundingBox) || this._computeIntersections(t, e, As);
      }
    }
  }, {
    key: "_computeIntersections",
    value: function _computeIntersections(t, e, n) {
      var i;
      var r = this.geometry,
        s = this.material,
        a = r.index,
        o = r.attributes.position,
        l = r.attributes.uv,
        c = r.attributes.uv1,
        h = r.attributes.normal,
        u = r.groups,
        d = r.drawRange;
      if (null !== a) {
        if (Array.isArray(s)) for (var _r29 = 0, _o7 = u.length; _r29 < _o7; _r29++) {
          var _o8 = u[_r29],
            _p3 = s[_o8.materialIndex];
          for (var _r30 = Math.max(_o8.start, d.start), _s12 = Math.min(a.count, Math.min(_o8.start + _o8.count, d.start + d.count)); _r30 < _s12; _r30 += 3) {
            i = Ws(this, _p3, t, n, l, c, h, a.getX(_r30), a.getX(_r30 + 1), a.getX(_r30 + 2)), i && (i.faceIndex = Math.floor(_r30 / 3), i.face.materialIndex = _o8.materialIndex, e.push(i));
          }
        } else {
          for (var _r31 = Math.max(0, d.start), _o9 = Math.min(a.count, d.start + d.count); _r31 < _o9; _r31 += 3) {
            i = Ws(this, s, t, n, l, c, h, a.getX(_r31), a.getX(_r31 + 1), a.getX(_r31 + 2)), i && (i.faceIndex = Math.floor(_r31 / 3), e.push(i));
          }
        }
      } else if (void 0 !== o) if (Array.isArray(s)) for (var _r32 = 0, _a10 = u.length; _r32 < _a10; _r32++) {
        var _a11 = u[_r32],
          _p4 = s[_a11.materialIndex];
        for (var _r33 = Math.max(_a11.start, d.start), _s13 = Math.min(o.count, Math.min(_a11.start + _a11.count, d.start + d.count)); _r33 < _s13; _r33 += 3) {
          i = Ws(this, _p4, t, n, l, c, h, _r33, _r33 + 1, _r33 + 2), i && (i.faceIndex = Math.floor(_r33 / 3), i.face.materialIndex = _a11.materialIndex, e.push(i));
        }
      } else {
        for (var _r34 = Math.max(0, d.start), _a12 = Math.min(o.count, d.start + d.count); _r34 < _a12; _r34 += 3) {
          i = Ws(this, s, t, n, l, c, h, _r34, _r34 + 1, _r34 + 2), i && (i.faceIndex = Math.floor(_r34 / 3), e.push(i));
        }
      }
    }
  }]);
}(Ur);
function Ws(t, e, n, i, r, s, a, o, l, c) {
  t.getVertexPosition(o, Ps), t.getVertexPosition(l, Ls), t.getVertexPosition(c, Is);
  var h = function (t, e, n, i, r, s, a, o) {
    var l;
    if (l = e.side === d ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, e.side === u, o), null === l) return null;
    ks.copy(o), ks.applyMatrix4(t.matrixWorld);
    var c = n.ray.origin.distanceTo(ks);
    return c < n.near || c > n.far ? null : {
      distance: c,
      point: ks.clone(),
      object: t
    };
  }(t, e, n, i, Ps, Ls, Is, Vs);
  if (h) {
    r && (Ds.fromBufferAttribute(r, o), Os.fromBufferAttribute(r, l), Fs.fromBufferAttribute(r, c), h.uv = Wr.getInterpolation(Vs, Ps, Ls, Is, Ds, Os, Fs, new Qn())), s && (Ds.fromBufferAttribute(s, o), Os.fromBufferAttribute(s, l), Fs.fromBufferAttribute(s, c), h.uv1 = Wr.getInterpolation(Vs, Ps, Ls, Is, Ds, Os, Fs, new Qn()), h.uv2 = h.uv1), a && (Bs.fromBufferAttribute(a, o), zs.fromBufferAttribute(a, l), Hs.fromBufferAttribute(a, c), h.normal = Wr.getInterpolation(Vs, Ps, Ls, Is, Bs, zs, Hs, new Ii()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    var _t53 = {
      a: o,
      b: l,
      c: c,
      normal: new Ii(),
      materialIndex: 0
    };
    Wr.getNormal(Ps, Ls, Is, _t53.normal), h.face = _t53;
  }
  return h;
}
var Xs = exports.BoxGeometry = /*#__PURE__*/function (_Ts) {
  function Xs() {
    var _this15;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    _classCallCheck(this, Xs);
    _this15 = _callSuper(this, Xs), _this15.type = "BoxGeometry", _this15.parameters = {
      width: t,
      height: e,
      depth: n,
      widthSegments: i,
      heightSegments: r,
      depthSegments: s
    };
    var a = _this15;
    i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
    var o = [],
      l = [],
      c = [],
      h = [];
    var u = 0,
      d = 0;
    function p(t, e, n, i, r, s, p, m, f, g, _) {
      var v = s / f,
        x = p / g,
        y = s / 2,
        M = p / 2,
        S = m / 2,
        b = f + 1,
        E = g + 1;
      var T = 0,
        w = 0;
      var A = new Ii();
      for (var _s14 = 0; _s14 < E; _s14++) {
        var _a13 = _s14 * x - M;
        for (var _o10 = 0; _o10 < b; _o10++) {
          var _u3 = _o10 * v - y;
          A[t] = _u3 * i, A[e] = _a13 * r, A[n] = S, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(_o10 / f), h.push(1 - _s14 / g), T += 1;
        }
      }
      for (var _t54 = 0; _t54 < g; _t54++) for (var _e50 = 0; _e50 < f; _e50++) {
        var _n58 = u + _e50 + b * _t54,
          _i44 = u + _e50 + b * (_t54 + 1),
          _r35 = u + (_e50 + 1) + b * (_t54 + 1),
          _s15 = u + (_e50 + 1) + b * _t54;
        o.push(_n58, _i44, _s15), o.push(_i44, _r35, _s15), w += 6;
      }
      a.addGroup(d, w, _), d += w, u += T;
    }
    p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), _this15.setIndex(o), _this15.setAttribute("position", new gs(l, 3)), _this15.setAttribute("normal", new gs(c, 3)), _this15.setAttribute("uv", new gs(h, 2));
    return _this15;
  }
  _inherits(Xs, _Ts);
  return _createClass(Xs, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Xs.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new Xs(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
    }
  }]);
}(Ts);
function js(t) {
  var e = {};
  for (var _n59 in t) {
    e[_n59] = {};
    for (var _i45 in t[_n59]) {
      var _r36 = t[_n59][_i45];
      _r36 && (_r36.isColor || _r36.isMatrix3 || _r36.isMatrix4 || _r36.isVector2 || _r36.isVector3 || _r36.isVector4 || _r36.isTexture || _r36.isQuaternion) ? _r36.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[_n59][_i45] = null) : e[_n59][_i45] = _r36.clone() : Array.isArray(_r36) ? e[_n59][_i45] = _r36.slice() : e[_n59][_i45] = _r36;
    }
  }
  return e;
}
function qs(t) {
  var e = {};
  for (var _n60 = 0; _n60 < t.length; _n60++) {
    var _i46 = js(t[_n60]);
    for (var _t55 in _i46) e[_t55] = _i46[_t55];
  }
  return e;
}
function Ys(t) {
  return null === t.getRenderTarget() ? t.outputColorSpace : pi.workingColorSpace;
}
var Zs = exports.UniformsUtils = {
  clone: js,
  merge: qs
};
var Js = exports.ShaderMaterial = /*#__PURE__*/function (_$r2) {
  function Js(t) {
    var _this16;
    _classCallCheck(this, Js);
    _this16 = _callSuper(this, Js), _this16.isShaderMaterial = !0, _this16.type = "ShaderMaterial", _this16.defines = {}, _this16.uniforms = {}, _this16.uniformsGroups = [], _this16.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", _this16.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", _this16.linewidth = 1, _this16.wireframe = !1, _this16.wireframeLinewidth = 1, _this16.fog = !1, _this16.lights = !1, _this16.clipping = !1, _this16.forceSinglePass = !0, _this16.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1,
      clipCullDistance: !1,
      multiDraw: !1
    }, _this16.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, _this16.index0AttributeName = void 0, _this16.uniformsNeedUpdate = !1, _this16.glslVersion = null, void 0 !== t && _this16.setValues(t);
    return _this16;
  }
  _inherits(Js, _$r2);
  return _createClass(Js, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Js.prototype), "copy", this).call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = js(t.uniforms), this.uniformsGroups = function (t) {
        var e = [];
        for (var _n61 = 0; _n61 < t.length; _n61++) e.push(t[_n61].clone());
        return e;
      }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(Js.prototype), "toJSON", this).call(this, t);
      e.glslVersion = this.glslVersion, e.uniforms = {};
      for (var _n62 in this.uniforms) {
        var _i47 = this.uniforms[_n62].value;
        _i47 && _i47.isTexture ? e.uniforms[_n62] = {
          type: "t",
          value: _i47.toJSON(t).uuid
        } : _i47 && _i47.isColor ? e.uniforms[_n62] = {
          type: "c",
          value: _i47.getHex()
        } : _i47 && _i47.isVector2 ? e.uniforms[_n62] = {
          type: "v2",
          value: _i47.toArray()
        } : _i47 && _i47.isVector3 ? e.uniforms[_n62] = {
          type: "v3",
          value: _i47.toArray()
        } : _i47 && _i47.isVector4 ? e.uniforms[_n62] = {
          type: "v4",
          value: _i47.toArray()
        } : _i47 && _i47.isMatrix3 ? e.uniforms[_n62] = {
          type: "m3",
          value: _i47.toArray()
        } : _i47 && _i47.isMatrix4 ? e.uniforms[_n62] = {
          type: "m4",
          value: _i47.toArray()
        } : e.uniforms[_n62] = {
          value: _i47
        };
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
      var n = {};
      for (var _t56 in this.extensions) !0 === this.extensions[_t56] && (n[_t56] = !0);
      return Object.keys(n).length > 0 && (e.extensions = n), e;
    }
  }]);
}($r);
var Ks = exports.Camera = /*#__PURE__*/function (_Ur2) {
  function Ks() {
    var _this17;
    _classCallCheck(this, Ks);
    _this17 = _callSuper(this, Ks), _this17.isCamera = !0, _this17.type = "Camera", _this17.matrixWorldInverse = new lr(), _this17.projectionMatrix = new lr(), _this17.projectionMatrixInverse = new lr(), _this17.coordinateSystem = Fn;
    return _this17;
  }
  _inherits(Ks, _Ur2);
  return _createClass(Ks, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Ks.prototype), "copy", this).call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(t) {
      return _get(_getPrototypeOf(Ks.prototype), "getWorldDirection", this).call(this, t).negate();
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      _get(_getPrototypeOf(Ks.prototype), "updateMatrixWorld", this).call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(t, e) {
      _get(_getPrototypeOf(Ks.prototype), "updateWorldMatrix", this).call(this, t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}(Ur);
var $s = new Ii(),
  Qs = new Qn(),
  ta = new Qn();
var ea = exports.PerspectiveCamera = /*#__PURE__*/function (_Ks) {
  function ea() {
    var _this18;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2e3;
    _classCallCheck(this, ea);
    _this18 = _callSuper(this, ea), _this18.isPerspectiveCamera = !0, _this18.type = "PerspectiveCamera", _this18.fov = t, _this18.zoom = 1, _this18.near = n, _this18.far = i, _this18.focus = 10, _this18.aspect = e, _this18.view = null, _this18.filmGauge = 35, _this18.filmOffset = 0, _this18.updateProjectionMatrix();
    return _this18;
  }
  _inherits(ea, _Ks);
  return _createClass(ea, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(ea.prototype), "copy", this).call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    }
  }, {
    key: "setFocalLength",
    value: function setFocalLength(t) {
      var e = .5 * this.getFilmHeight() / t;
      this.fov = 2 * Gn * Math.atan(e), this.updateProjectionMatrix();
    }
  }, {
    key: "getFocalLength",
    value: function getFocalLength() {
      var t = Math.tan(.5 * kn * this.fov);
      return .5 * this.getFilmHeight() / t;
    }
  }, {
    key: "getEffectiveFOV",
    value: function getEffectiveFOV() {
      return 2 * Gn * Math.atan(Math.tan(.5 * kn * this.fov) / this.zoom);
    }
  }, {
    key: "getFilmWidth",
    value: function getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
  }, {
    key: "getFilmHeight",
    value: function getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
  }, {
    key: "getViewBounds",
    value: function getViewBounds(t, e, n) {
      $s.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), e.set($s.x, $s.y).multiplyScalar(-t / $s.z), $s.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set($s.x, $s.y).multiplyScalar(-t / $s.z);
    }
  }, {
    key: "getViewSize",
    value: function getViewSize(t, e) {
      return this.getViewBounds(t, Qs, ta), e.subVectors(ta, Qs);
    }
  }, {
    key: "setViewOffset",
    value: function setViewOffset(t, e, n, i, r, s) {
      this.aspect = t / e, null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var t = this.near;
      var e = t * Math.tan(.5 * kn * this.fov) / this.zoom,
        n = 2 * e,
        i = this.aspect * n,
        r = -.5 * i;
      var s = this.view;
      if (null !== this.view && this.view.enabled) {
        var _t57 = s.fullWidth,
          _a14 = s.fullHeight;
        r += s.offsetX * i / _t57, e -= s.offsetY * n / _a14, i *= s.width / _t57, n *= s.height / _a14;
      }
      var a = this.filmOffset;
      0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(ea.prototype), "toJSON", this).call(this, t);
      return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
    }
  }]);
}(Ks);
var na = -90;
var ia = exports.CubeCamera = /*#__PURE__*/function (_Ur3) {
  function ia(t, e, n) {
    var _this19;
    _classCallCheck(this, ia);
    _this19 = _callSuper(this, ia), _this19.type = "CubeCamera", _this19.renderTarget = n, _this19.coordinateSystem = null, _this19.activeMipmapLevel = 0;
    var i = new ea(na, 1, t, e);
    i.layers = _this19.layers, _this19.add(i);
    var r = new ea(na, 1, t, e);
    r.layers = _this19.layers, _this19.add(r);
    var s = new ea(na, 1, t, e);
    s.layers = _this19.layers, _this19.add(s);
    var a = new ea(na, 1, t, e);
    a.layers = _this19.layers, _this19.add(a);
    var o = new ea(na, 1, t, e);
    o.layers = _this19.layers, _this19.add(o);
    var l = new ea(na, 1, t, e);
    l.layers = _this19.layers, _this19.add(l);
    return _this19;
  }
  _inherits(ia, _Ur3);
  return _createClass(ia, [{
    key: "updateCoordinateSystem",
    value: function updateCoordinateSystem() {
      var t = this.coordinateSystem,
        e = this.children.concat(),
        _e51 = _slicedToArray(e, 6),
        n = _e51[0],
        i = _e51[1],
        r = _e51[2],
        s = _e51[3],
        a = _e51[4],
        o = _e51[5];
      var _iterator = _createForOfIteratorHelper(e),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _t58 = _step.value;
          this.remove(_t58);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (t === Fn) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1);else {
        if (t !== Bn) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
        n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1);
      }
      var _iterator2 = _createForOfIteratorHelper(e),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _t59 = _step2.value;
          this.add(_t59), _t59.updateMatrixWorld();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "update",
    value: function update(t, e) {
      null === this.parent && this.updateMatrixWorld();
      var n = this.renderTarget,
        i = this.activeMipmapLevel;
      this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
      var _this$children = _slicedToArray(this.children, 6),
        r = _this$children[0],
        s = _this$children[1],
        a = _this$children[2],
        o = _this$children[3],
        l = _this$children[4],
        c = _this$children[5],
        h = t.getRenderTarget(),
        u = t.getActiveCubeFace(),
        d = t.getActiveMipmapLevel(),
        p = t.xr.enabled;
      t.xr.enabled = !1;
      var m = n.texture.generateMipmaps;
      n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0, i), t.render(e, r), t.setRenderTarget(n, 1, i), t.render(e, s), t.setRenderTarget(n, 2, i), t.render(e, a), t.setRenderTarget(n, 3, i), t.render(e, o), t.setRenderTarget(n, 4, i), t.render(e, l), n.texture.generateMipmaps = m, t.setRenderTarget(n, 5, i), t.render(e, c), t.setRenderTarget(h, u, d), t.xr.enabled = p, n.texture.needsPMREMUpdate = !0;
    }
  }]);
}(Ur);
var ra = exports.CubeTexture = /*#__PURE__*/function (_Si3) {
  function ra(t, e, n, i, r, s, a, o, l, c) {
    var _this20;
    _classCallCheck(this, ra);
    _this20 = _callSuper(this, ra, [t = void 0 !== t ? t : [], e = void 0 !== e ? e : ot, n, i, r, s, a, o, l, c]), _this20.isCubeTexture = !0, _this20.flipY = !1;
    return _this20;
  }
  _inherits(ra, _Si3);
  return _createClass(ra, [{
    key: "images",
    get: function get() {
      return this.image;
    },
    set: function set(t) {
      this.image = t;
    }
  }]);
}(Si);
var sa = exports.WebGLCubeRenderTarget = /*#__PURE__*/function (_Ti4) {
  function sa() {
    var _this21;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, sa);
    _this21 = _callSuper(this, sa, [t, t, e]), _this21.isWebGLCubeRenderTarget = !0;
    var n = {
        width: t,
        height: t,
        depth: 1
      },
      i = [n, n, n, n, n, n];
    void 0 !== e.encoding && (li("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), e.colorSpace = e.encoding === He ? je : Xe), _this21.texture = new ra(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), _this21.texture.isRenderTargetTexture = !0, _this21.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, _this21.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : yt;
    return _this21;
  }
  _inherits(sa, _Ti4);
  return _createClass(sa, [{
    key: "fromEquirectangularTexture",
    value: function fromEquirectangularTexture(t, e) {
      this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
      var n = {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
          fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
        },
        i = new Xs(5, 5, 5),
        r = new Js({
          name: "CubemapFromEquirect",
          uniforms: js(n.uniforms),
          vertexShader: n.vertexShader,
          fragmentShader: n.fragmentShader,
          side: d,
          blending: 0
        });
      r.uniforms.tEquirect.value = e;
      var s = new Gs(i, r),
        a = e.minFilter;
      e.minFilter === bt && (e.minFilter = yt);
      return new ia(1, 10, this).update(t, s), e.minFilter = a, s.geometry.dispose(), s.material.dispose(), this;
    }
  }, {
    key: "clear",
    value: function clear(t, e, n, i) {
      var r = t.getRenderTarget();
      for (var _r37 = 0; _r37 < 6; _r37++) t.setRenderTarget(this, _r37), t.clear(e, n, i);
      t.setRenderTarget(r);
    }
  }]);
}(Ti);
var aa = new Ii(),
  oa = new Ii(),
  la = new ti();
var ca = exports.Plane = /*#__PURE__*/function () {
  function ca() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii(1, 0, 0);
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, ca);
    this.isPlane = !0, this.normal = t, this.constant = e;
  }
  return _createClass(ca, [{
    key: "set",
    value: function set(t, e) {
      return this.normal.copy(t), this.constant = e, this;
    }
  }, {
    key: "setComponents",
    value: function setComponents(t, e, n, i) {
      return this.normal.set(t, e, n), this.constant = i, this;
    }
  }, {
    key: "setFromNormalAndCoplanarPoint",
    value: function setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    }
  }, {
    key: "setFromCoplanarPoints",
    value: function setFromCoplanarPoints(t, e, n) {
      var i = aa.subVectors(n, e).cross(oa.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, t), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
  }, {
    key: "distanceToSphere",
    value: function distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
  }, {
    key: "projectPoint",
    value: function projectPoint(t, e) {
      return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
    }
  }, {
    key: "intersectLine",
    value: function intersectLine(t, e) {
      var n = t.delta(aa),
        i = this.normal.dot(n);
      if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      var r = -(t.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(t) {
      var e = this.distanceToPoint(t.start),
        n = this.distanceToPoint(t.end);
      return e < 0 && n > 0 || n < 0 && e > 0;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return t.intersectsPlane(this);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
  }, {
    key: "coplanarPoint",
    value: function coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t, e) {
      var n = e || la.getNormalMatrix(t),
        i = this.coplanarPoint(aa).applyMatrix4(t),
        r = this.normal.applyMatrix3(n).normalize();
      return this.constant = -i.dot(r), this;
    }
  }, {
    key: "translate",
    value: function translate(t) {
      return this.constant -= t.dot(this.normal), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var ha = new Qi(),
  ua = new Ii();
var da = exports.Frustum = /*#__PURE__*/function () {
  function da() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ca();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new ca();
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new ca();
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new ca();
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new ca();
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new ca();
    _classCallCheck(this, da);
    this.planes = [t, e, n, i, r, s];
  }
  return _createClass(da, [{
    key: "set",
    value: function set(t, e, n, i, r, s) {
      var a = this.planes;
      return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      var e = this.planes;
      for (var _n63 = 0; _n63 < 6; _n63++) e[_n63].copy(t.planes[_n63]);
      return this;
    }
  }, {
    key: "setFromProjectionMatrix",
    value: function setFromProjectionMatrix(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2e3;
      var n = this.planes,
        i = t.elements,
        r = i[0],
        s = i[1],
        a = i[2],
        o = i[3],
        l = i[4],
        c = i[5],
        h = i[6],
        u = i[7],
        d = i[8],
        p = i[9],
        m = i[10],
        f = i[11],
        g = i[12],
        _ = i[13],
        v = i[14],
        x = i[15];
      if (n[0].setComponents(o - r, u - l, f - d, x - g).normalize(), n[1].setComponents(o + r, u + l, f + d, x + g).normalize(), n[2].setComponents(o + s, u + c, f + p, x + _).normalize(), n[3].setComponents(o - s, u - c, f - p, x - _).normalize(), n[4].setComponents(o - a, u - h, f - m, x - v).normalize(), e === Fn) n[5].setComponents(o + a, u + h, f + m, x + v).normalize();else {
        if (e !== Bn) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
        n[5].setComponents(a, h, m, v).normalize();
      }
      return this;
    }
  }, {
    key: "intersectsObject",
    value: function intersectsObject(t) {
      if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), ha.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else {
        var _e52 = t.geometry;
        null === _e52.boundingSphere && _e52.computeBoundingSphere(), ha.copy(_e52.boundingSphere).applyMatrix4(t.matrixWorld);
      }
      return this.intersectsSphere(ha);
    }
  }, {
    key: "intersectsSprite",
    value: function intersectsSprite(t) {
      return ha.center.set(0, 0, 0), ha.radius = .7071067811865476, ha.applyMatrix4(t.matrixWorld), this.intersectsSphere(ha);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(t) {
      var e = this.planes,
        n = t.center,
        i = -t.radius;
      for (var _t60 = 0; _t60 < 6; _t60++) {
        if (e[_t60].distanceToPoint(n) < i) return !1;
      }
      return !0;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      var e = this.planes;
      for (var _n64 = 0; _n64 < 6; _n64++) {
        var _i48 = e[_n64];
        if (ua.x = _i48.normal.x > 0 ? t.max.x : t.min.x, ua.y = _i48.normal.y > 0 ? t.max.y : t.min.y, ua.z = _i48.normal.z > 0 ? t.max.z : t.min.z, _i48.distanceToPoint(ua) < 0) return !1;
      }
      return !0;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      var e = this.planes;
      for (var _n65 = 0; _n65 < 6; _n65++) if (e[_n65].distanceToPoint(t) < 0) return !1;
      return !0;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
function pa() {
  var t = null,
    e = !1,
    n = null,
    i = null;
  function r(e, s) {
    n(e, s), i = t.requestAnimationFrame(r);
  }
  return {
    start: function start() {
      !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0);
    },
    stop: function stop() {
      t.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function setAnimationLoop(t) {
      n = t;
    },
    setContext: function setContext(e) {
      t = e;
    }
  };
}
function ma(t, e) {
  var n = e.isWebGL2,
    i = new WeakMap();
  return {
    get: function get(t) {
      return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
    },
    remove: function remove(e) {
      e.isInterleavedBufferAttribute && (e = e.data);
      var n = i.get(e);
      n && (t.deleteBuffer(n.buffer), i.delete(e));
    },
    update: function update(e, r) {
      if (e.isGLBufferAttribute) {
        var _t61 = i.get(e);
        return void ((!_t61 || _t61.version < e.version) && i.set(e, {
          buffer: e.buffer,
          type: e.type,
          bytesPerElement: e.elementSize,
          version: e.version
        }));
      }
      e.isInterleavedBufferAttribute && (e = e.data);
      var s = i.get(e);
      if (void 0 === s) i.set(e, function (e, i) {
        var r = e.array,
          s = e.usage,
          a = r.byteLength,
          o = t.createBuffer();
        var l;
        if (t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback(), r instanceof Float32Array) l = t.FLOAT;else if (r instanceof Uint16Array) {
          if (e.isFloat16BufferAttribute) {
            if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            l = t.HALF_FLOAT;
          } else l = t.UNSIGNED_SHORT;
        } else if (r instanceof Int16Array) l = t.SHORT;else if (r instanceof Uint32Array) l = t.UNSIGNED_INT;else if (r instanceof Int32Array) l = t.INT;else if (r instanceof Int8Array) l = t.BYTE;else if (r instanceof Uint8Array) l = t.UNSIGNED_BYTE;else {
          if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
          l = t.UNSIGNED_BYTE;
        }
        return {
          buffer: o,
          type: l,
          bytesPerElement: r.BYTES_PER_ELEMENT,
          version: e.version,
          size: a
        };
      }(e, r));else if (s.version < e.version) {
        if (s.size !== e.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
        !function (e, i, r) {
          var s = i.array,
            a = i._updateRange,
            o = i.updateRanges;
          if (t.bindBuffer(r, e), -1 === a.count && 0 === o.length && t.bufferSubData(r, 0, s), 0 !== o.length) {
            for (var _e53 = 0, _i49 = o.length; _e53 < _i49; _e53++) {
              var _i50 = o[_e53];
              n ? t.bufferSubData(r, _i50.start * s.BYTES_PER_ELEMENT, s, _i50.start, _i50.count) : t.bufferSubData(r, _i50.start * s.BYTES_PER_ELEMENT, s.subarray(_i50.start, _i50.start + _i50.count));
            }
            i.clearUpdateRanges();
          }
          -1 !== a.count && (n ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1), i.onUploadCallback();
        }(s.buffer, e, r), s.version = e.version;
      }
    }
  };
}
var fa = exports.PlaneGeometry = /*#__PURE__*/function (_Ts2) {
  function fa() {
    var _this22;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, fa);
    _this22 = _callSuper(this, fa), _this22.type = "PlaneGeometry", _this22.parameters = {
      width: t,
      height: e,
      widthSegments: n,
      heightSegments: i
    };
    var r = t / 2,
      s = e / 2,
      a = Math.floor(n),
      o = Math.floor(i),
      l = a + 1,
      c = o + 1,
      h = t / a,
      u = e / o,
      d = [],
      p = [],
      m = [],
      f = [];
    for (var _t62 = 0; _t62 < c; _t62++) {
      var _e54 = _t62 * u - s;
      for (var _n66 = 0; _n66 < l; _n66++) {
        var _i51 = _n66 * h - r;
        p.push(_i51, -_e54, 0), m.push(0, 0, 1), f.push(_n66 / a), f.push(1 - _t62 / o);
      }
    }
    for (var _t63 = 0; _t63 < o; _t63++) for (var _e55 = 0; _e55 < a; _e55++) {
      var _n67 = _e55 + l * _t63,
        _i52 = _e55 + l * (_t63 + 1),
        _r38 = _e55 + 1 + l * (_t63 + 1),
        _s16 = _e55 + 1 + l * _t63;
      d.push(_n67, _i52, _s16), d.push(_i52, _r38, _s16);
    }
    _this22.setIndex(d), _this22.setAttribute("position", new gs(p, 3)), _this22.setAttribute("normal", new gs(m, 3)), _this22.setAttribute("uv", new gs(f, 2));
    return _this22;
  }
  _inherits(fa, _Ts2);
  return _createClass(fa, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(fa.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new fa(t.width, t.height, t.widthSegments, t.heightSegments);
    }
  }]);
}(Ts);
var ga = exports.ShaderChunk = {
    alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
    alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
    batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
    begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
    iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
    envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
    lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
    map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
    normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
    opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
    shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
    shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
    uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
    uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
    uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
  },
  _a = exports.UniformsLib = {
    common: {
      diffuse: {
        value: new Zr(16777215)
      },
      opacity: {
        value: 1
      },
      map: {
        value: null
      },
      mapTransform: {
        value: new ti()
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new ti()
      },
      alphaTest: {
        value: 0
      }
    },
    specularmap: {
      specularMap: {
        value: null
      },
      specularMapTransform: {
        value: new ti()
      }
    },
    envmap: {
      envMap: {
        value: null
      },
      flipEnvMap: {
        value: -1
      },
      reflectivity: {
        value: 1
      },
      ior: {
        value: 1.5
      },
      refractionRatio: {
        value: .98
      }
    },
    aomap: {
      aoMap: {
        value: null
      },
      aoMapIntensity: {
        value: 1
      },
      aoMapTransform: {
        value: new ti()
      }
    },
    lightmap: {
      lightMap: {
        value: null
      },
      lightMapIntensity: {
        value: 1
      },
      lightMapTransform: {
        value: new ti()
      }
    },
    bumpmap: {
      bumpMap: {
        value: null
      },
      bumpMapTransform: {
        value: new ti()
      },
      bumpScale: {
        value: 1
      }
    },
    normalmap: {
      normalMap: {
        value: null
      },
      normalMapTransform: {
        value: new ti()
      },
      normalScale: {
        value: new Qn(1, 1)
      }
    },
    displacementmap: {
      displacementMap: {
        value: null
      },
      displacementMapTransform: {
        value: new ti()
      },
      displacementScale: {
        value: 1
      },
      displacementBias: {
        value: 0
      }
    },
    emissivemap: {
      emissiveMap: {
        value: null
      },
      emissiveMapTransform: {
        value: new ti()
      }
    },
    metalnessmap: {
      metalnessMap: {
        value: null
      },
      metalnessMapTransform: {
        value: new ti()
      }
    },
    roughnessmap: {
      roughnessMap: {
        value: null
      },
      roughnessMapTransform: {
        value: new ti()
      }
    },
    gradientmap: {
      gradientMap: {
        value: null
      }
    },
    fog: {
      fogDensity: {
        value: 25e-5
      },
      fogNear: {
        value: 1
      },
      fogFar: {
        value: 2e3
      },
      fogColor: {
        value: new Zr(16777215)
      }
    },
    lights: {
      ambientLightColor: {
        value: []
      },
      lightProbe: {
        value: []
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {}
        }
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: {
        value: []
      },
      directionalShadowMatrix: {
        value: []
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        }
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotLightMap: {
        value: []
      },
      spotShadowMap: {
        value: []
      },
      spotLightMatrix: {
        value: []
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        }
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: {
        value: []
      },
      pointShadowMatrix: {
        value: []
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        }
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        }
      },
      ltc_1: {
        value: null
      },
      ltc_2: {
        value: null
      }
    },
    points: {
      diffuse: {
        value: new Zr(16777215)
      },
      opacity: {
        value: 1
      },
      size: {
        value: 1
      },
      scale: {
        value: 1
      },
      map: {
        value: null
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new ti()
      },
      alphaTest: {
        value: 0
      },
      uvTransform: {
        value: new ti()
      }
    },
    sprite: {
      diffuse: {
        value: new Zr(16777215)
      },
      opacity: {
        value: 1
      },
      center: {
        value: new Qn(.5, .5)
      },
      rotation: {
        value: 0
      },
      map: {
        value: null
      },
      mapTransform: {
        value: new ti()
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new ti()
      },
      alphaTest: {
        value: 0
      }
    }
  },
  va = exports.ShaderLib = {
    basic: {
      uniforms: qs([_a.common, _a.specularmap, _a.envmap, _a.aomap, _a.lightmap, _a.fog]),
      vertexShader: ga.meshbasic_vert,
      fragmentShader: ga.meshbasic_frag
    },
    lambert: {
      uniforms: qs([_a.common, _a.specularmap, _a.envmap, _a.aomap, _a.lightmap, _a.emissivemap, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.fog, _a.lights, {
        emissive: {
          value: new Zr(0)
        }
      }]),
      vertexShader: ga.meshlambert_vert,
      fragmentShader: ga.meshlambert_frag
    },
    phong: {
      uniforms: qs([_a.common, _a.specularmap, _a.envmap, _a.aomap, _a.lightmap, _a.emissivemap, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.fog, _a.lights, {
        emissive: {
          value: new Zr(0)
        },
        specular: {
          value: new Zr(1118481)
        },
        shininess: {
          value: 30
        }
      }]),
      vertexShader: ga.meshphong_vert,
      fragmentShader: ga.meshphong_frag
    },
    standard: {
      uniforms: qs([_a.common, _a.envmap, _a.aomap, _a.lightmap, _a.emissivemap, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.roughnessmap, _a.metalnessmap, _a.fog, _a.lights, {
        emissive: {
          value: new Zr(0)
        },
        roughness: {
          value: 1
        },
        metalness: {
          value: 0
        },
        envMapIntensity: {
          value: 1
        }
      }]),
      vertexShader: ga.meshphysical_vert,
      fragmentShader: ga.meshphysical_frag
    },
    toon: {
      uniforms: qs([_a.common, _a.aomap, _a.lightmap, _a.emissivemap, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.gradientmap, _a.fog, _a.lights, {
        emissive: {
          value: new Zr(0)
        }
      }]),
      vertexShader: ga.meshtoon_vert,
      fragmentShader: ga.meshtoon_frag
    },
    matcap: {
      uniforms: qs([_a.common, _a.bumpmap, _a.normalmap, _a.displacementmap, _a.fog, {
        matcap: {
          value: null
        }
      }]),
      vertexShader: ga.meshmatcap_vert,
      fragmentShader: ga.meshmatcap_frag
    },
    points: {
      uniforms: qs([_a.points, _a.fog]),
      vertexShader: ga.points_vert,
      fragmentShader: ga.points_frag
    },
    dashed: {
      uniforms: qs([_a.common, _a.fog, {
        scale: {
          value: 1
        },
        dashSize: {
          value: 1
        },
        totalSize: {
          value: 2
        }
      }]),
      vertexShader: ga.linedashed_vert,
      fragmentShader: ga.linedashed_frag
    },
    depth: {
      uniforms: qs([_a.common, _a.displacementmap]),
      vertexShader: ga.depth_vert,
      fragmentShader: ga.depth_frag
    },
    normal: {
      uniforms: qs([_a.common, _a.bumpmap, _a.normalmap, _a.displacementmap, {
        opacity: {
          value: 1
        }
      }]),
      vertexShader: ga.meshnormal_vert,
      fragmentShader: ga.meshnormal_frag
    },
    sprite: {
      uniforms: qs([_a.sprite, _a.fog]),
      vertexShader: ga.sprite_vert,
      fragmentShader: ga.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new ti()
        },
        t2D: {
          value: null
        },
        backgroundIntensity: {
          value: 1
        }
      },
      vertexShader: ga.background_vert,
      fragmentShader: ga.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        backgroundBlurriness: {
          value: 0
        },
        backgroundIntensity: {
          value: 1
        }
      },
      vertexShader: ga.backgroundCube_vert,
      fragmentShader: ga.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: {
          value: null
        },
        tFlip: {
          value: -1
        },
        opacity: {
          value: 1
        }
      },
      vertexShader: ga.cube_vert,
      fragmentShader: ga.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: ga.equirect_vert,
      fragmentShader: ga.equirect_frag
    },
    distanceRGBA: {
      uniforms: qs([_a.common, _a.displacementmap, {
        referencePosition: {
          value: new Ii()
        },
        nearDistance: {
          value: 1
        },
        farDistance: {
          value: 1e3
        }
      }]),
      vertexShader: ga.distanceRGBA_vert,
      fragmentShader: ga.distanceRGBA_frag
    },
    shadow: {
      uniforms: qs([_a.lights, _a.fog, {
        color: {
          value: new Zr(0)
        },
        opacity: {
          value: 1
        }
      }]),
      vertexShader: ga.shadow_vert,
      fragmentShader: ga.shadow_frag
    }
  };
va.physical = {
  uniforms: qs([va.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatMapTransform: {
      value: new ti()
    },
    clearcoatNormalMap: {
      value: null
    },
    clearcoatNormalMapTransform: {
      value: new ti()
    },
    clearcoatNormalScale: {
      value: new Qn(1, 1)
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatRoughnessMapTransform: {
      value: new ti()
    },
    iridescence: {
      value: 0
    },
    iridescenceMap: {
      value: null
    },
    iridescenceMapTransform: {
      value: new ti()
    },
    iridescenceIOR: {
      value: 1.3
    },
    iridescenceThicknessMinimum: {
      value: 100
    },
    iridescenceThicknessMaximum: {
      value: 400
    },
    iridescenceThicknessMap: {
      value: null
    },
    iridescenceThicknessMapTransform: {
      value: new ti()
    },
    sheen: {
      value: 0
    },
    sheenColor: {
      value: new Zr(0)
    },
    sheenColorMap: {
      value: null
    },
    sheenColorMapTransform: {
      value: new ti()
    },
    sheenRoughness: {
      value: 1
    },
    sheenRoughnessMap: {
      value: null
    },
    sheenRoughnessMapTransform: {
      value: new ti()
    },
    transmission: {
      value: 0
    },
    transmissionMap: {
      value: null
    },
    transmissionMapTransform: {
      value: new ti()
    },
    transmissionSamplerSize: {
      value: new Qn()
    },
    transmissionSamplerMap: {
      value: null
    },
    thickness: {
      value: 0
    },
    thicknessMap: {
      value: null
    },
    thicknessMapTransform: {
      value: new ti()
    },
    attenuationDistance: {
      value: 0
    },
    attenuationColor: {
      value: new Zr(0)
    },
    specularColor: {
      value: new Zr(1, 1, 1)
    },
    specularColorMap: {
      value: null
    },
    specularColorMapTransform: {
      value: new ti()
    },
    specularIntensity: {
      value: 1
    },
    specularIntensityMap: {
      value: null
    },
    specularIntensityMapTransform: {
      value: new ti()
    },
    anisotropyVector: {
      value: new Qn()
    },
    anisotropyMap: {
      value: null
    },
    anisotropyMapTransform: {
      value: new ti()
    }
  }]),
  vertexShader: ga.meshphysical_vert,
  fragmentShader: ga.meshphysical_frag
};
var xa = {
  r: 0,
  b: 0,
  g: 0
};
function ya(t, e, n, i, r, s, a) {
  var o = new Zr(0);
  var l,
    c,
    h = !0 === s ? 0 : 1,
    p = null,
    m = 0,
    f = null;
  function g(e, n) {
    e.getRGB(xa, Ys(t)), i.buffers.color.setClear(xa.r, xa.g, xa.b, n, a);
  }
  return {
    getClearColor: function getClearColor() {
      return o;
    },
    setClearColor: function setClearColor(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      o.set(t), h = e, g(o, h);
    },
    getClearAlpha: function getClearAlpha() {
      return h;
    },
    setClearAlpha: function setClearAlpha(t) {
      h = t, g(o, h);
    },
    render: function render(s, _) {
      var v = !1,
        x = !0 === _.isScene ? _.background : null;
      if (x && x.isTexture) {
        x = (_.backgroundBlurriness > 0 ? n : e).get(x);
      }
      null === x ? g(o, h) : x && x.isColor && (g(x, 1), v = !0);
      var y = t.xr.getEnvironmentBlendMode();
      "additive" === y ? i.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === y && i.buffers.color.setClear(0, 0, 0, 0, a), (t.autoClear || v) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), x && (x.isCubeTexture || x.mapping === ut) ? (void 0 === c && (c = new Gs(new Xs(1, 1, 1), new Js({
        name: "BackgroundCubeMaterial",
        uniforms: js(va.backgroundCube.uniforms),
        vertexShader: va.backgroundCube.vertexShader,
        fragmentShader: va.backgroundCube.fragmentShader,
        side: d,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (t, e, n) {
        this.matrixWorld.copyPosition(n.matrixWorld);
      }, Object.defineProperty(c.material, "envMap", {
        get: function get() {
          return this.uniforms.envMap.value;
        }
      }), r.update(c)), c.material.uniforms.envMap.value = x, c.material.uniforms.flipEnvMap.value = x.isCubeTexture && !1 === x.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity, c.material.toneMapped = pi.getTransfer(x.colorSpace) !== Ke, p === x && m === x.version && f === t.toneMapping || (c.material.needsUpdate = !0, p = x, m = x.version, f = t.toneMapping), c.layers.enableAll(), s.unshift(c, c.geometry, c.material, 0, 0, null)) : x && x.isTexture && (void 0 === l && (l = new Gs(new fa(2, 2), new Js({
        name: "BackgroundMaterial",
        uniforms: js(va.background.uniforms),
        vertexShader: va.background.vertexShader,
        fragmentShader: va.background.fragmentShader,
        side: u,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
        get: function get() {
          return this.uniforms.t2D.value;
        }
      }), r.update(l)), l.material.uniforms.t2D.value = x, l.material.uniforms.backgroundIntensity.value = _.backgroundIntensity, l.material.toneMapped = pi.getTransfer(x.colorSpace) !== Ke, !0 === x.matrixAutoUpdate && x.updateMatrix(), l.material.uniforms.uvTransform.value.copy(x.matrix), p === x && m === x.version && f === t.toneMapping || (l.material.needsUpdate = !0, p = x, m = x.version, f = t.toneMapping), l.layers.enableAll(), s.unshift(l, l.geometry, l.material, 0, 0, null));
    }
  };
}
function Ma(t, e, n, i) {
  var r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    a = i.isWebGL2 || null !== s,
    o = {},
    l = p(null);
  var c = l,
    h = !1;
  function u(e) {
    return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
  }
  function d(e) {
    return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
  }
  function p(t) {
    var e = [],
      n = [],
      i = [];
    for (var _t64 = 0; _t64 < r; _t64++) e[_t64] = 0, n[_t64] = 0, i[_t64] = 0;
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: e,
      enabledAttributes: n,
      attributeDivisors: i,
      object: t,
      attributes: {},
      index: null
    };
  }
  function m() {
    var t = c.newAttributes;
    for (var _e56 = 0, _n68 = t.length; _e56 < _n68; _e56++) t[_e56] = 0;
  }
  function f(t) {
    g(t, 0);
  }
  function g(n, r) {
    var s = c.newAttributes,
      a = c.enabledAttributes,
      o = c.attributeDivisors;
    if (s[n] = 1, 0 === a[n] && (t.enableVertexAttribArray(n), a[n] = 1), o[n] !== r) {
      (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r;
    }
  }
  function _() {
    var e = c.newAttributes,
      n = c.enabledAttributes;
    for (var _i53 = 0, _r39 = n.length; _i53 < _r39; _i53++) n[_i53] !== e[_i53] && (t.disableVertexAttribArray(_i53), n[_i53] = 0);
  }
  function v(e, n, i, r, s, a, o) {
    !0 === o ? t.vertexAttribIPointer(e, n, i, s, a) : t.vertexAttribPointer(e, n, i, r, s, a);
  }
  function x() {
    y(), h = !0, c !== l && (c = l, u(c.object));
  }
  function y() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return {
    setup: function setup(r, l, d, x, y) {
      var M = !1;
      if (a) {
        var _e57 = function (e, n, r) {
          var a = !0 === r.wireframe;
          var l = o[e.id];
          void 0 === l && (l = {}, o[e.id] = l);
          var c = l[n.id];
          void 0 === c && (c = {}, l[n.id] = c);
          var h = c[a];
          void 0 === h && (h = p(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[a] = h);
          return h;
        }(x, d, l);
        c !== _e57 && (c = _e57, u(c.object)), M = function (t, e, n, i) {
          var r = c.attributes,
            s = e.attributes;
          var a = 0;
          var o = n.getAttributes();
          for (var _e58 in o) {
            if (o[_e58].location >= 0) {
              var _n69 = r[_e58];
              var _i54 = s[_e58];
              if (void 0 === _i54 && ("instanceMatrix" === _e58 && t.instanceMatrix && (_i54 = t.instanceMatrix), "instanceColor" === _e58 && t.instanceColor && (_i54 = t.instanceColor)), void 0 === _n69) return !0;
              if (_n69.attribute !== _i54) return !0;
              if (_i54 && _n69.data !== _i54.data) return !0;
              a++;
            }
          }
          return c.attributesNum !== a || c.index !== i;
        }(r, x, d, y), M && function (t, e, n, i) {
          var r = {},
            s = e.attributes;
          var a = 0;
          var o = n.getAttributes();
          for (var _e59 in o) {
            if (o[_e59].location >= 0) {
              var _n70 = s[_e59];
              void 0 === _n70 && ("instanceMatrix" === _e59 && t.instanceMatrix && (_n70 = t.instanceMatrix), "instanceColor" === _e59 && t.instanceColor && (_n70 = t.instanceColor));
              var _i55 = {};
              _i55.attribute = _n70, _n70 && _n70.data && (_i55.data = _n70.data), r[_e59] = _i55, a++;
            }
          }
          c.attributes = r, c.attributesNum = a, c.index = i;
        }(r, x, d, y);
      } else {
        var _t65 = !0 === l.wireframe;
        c.geometry === x.id && c.program === d.id && c.wireframe === _t65 || (c.geometry = x.id, c.program = d.id, c.wireframe = _t65, M = !0);
      }
      null !== y && n.update(y, t.ELEMENT_ARRAY_BUFFER), (M || h) && (h = !1, function (r, s, a, o) {
        if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
        m();
        var l = o.attributes,
          c = a.getAttributes(),
          h = s.defaultAttributeValues;
        for (var _e60 in c) {
          var _s17 = c[_e60];
          if (_s17.location >= 0) {
            var _a15 = l[_e60];
            if (void 0 === _a15 && ("instanceMatrix" === _e60 && r.instanceMatrix && (_a15 = r.instanceMatrix), "instanceColor" === _e60 && r.instanceColor && (_a15 = r.instanceColor)), void 0 !== _a15) {
              var _e61 = _a15.normalized,
                _l6 = _a15.itemSize,
                _c5 = n.get(_a15);
              if (void 0 === _c5) continue;
              var _h4 = _c5.buffer,
                _u4 = _c5.type,
                _d4 = _c5.bytesPerElement,
                _p5 = !0 === i.isWebGL2 && (_u4 === t.INT || _u4 === t.UNSIGNED_INT || _a15.gpuType === Ct);
              if (_a15.isInterleavedBufferAttribute) {
                var _n71 = _a15.data,
                  _i56 = _n71.stride,
                  _c6 = _a15.offset;
                if (_n71.isInstancedInterleavedBuffer) {
                  for (var _t66 = 0; _t66 < _s17.locationSize; _t66++) g(_s17.location + _t66, _n71.meshPerAttribute);
                  !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = _n71.meshPerAttribute * _n71.count);
                } else for (var _t67 = 0; _t67 < _s17.locationSize; _t67++) f(_s17.location + _t67);
                t.bindBuffer(t.ARRAY_BUFFER, _h4);
                for (var _t68 = 0; _t68 < _s17.locationSize; _t68++) v(_s17.location + _t68, _l6 / _s17.locationSize, _u4, _e61, _i56 * _d4, (_c6 + _l6 / _s17.locationSize * _t68) * _d4, _p5);
              } else {
                if (_a15.isInstancedBufferAttribute) {
                  for (var _t69 = 0; _t69 < _s17.locationSize; _t69++) g(_s17.location + _t69, _a15.meshPerAttribute);
                  !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = _a15.meshPerAttribute * _a15.count);
                } else for (var _t70 = 0; _t70 < _s17.locationSize; _t70++) f(_s17.location + _t70);
                t.bindBuffer(t.ARRAY_BUFFER, _h4);
                for (var _t71 = 0; _t71 < _s17.locationSize; _t71++) v(_s17.location + _t71, _l6 / _s17.locationSize, _u4, _e61, _l6 * _d4, _l6 / _s17.locationSize * _t71 * _d4, _p5);
              }
            } else if (void 0 !== h) {
              var _n72 = h[_e60];
              if (void 0 !== _n72) switch (_n72.length) {
                case 2:
                  t.vertexAttrib2fv(_s17.location, _n72);
                  break;
                case 3:
                  t.vertexAttrib3fv(_s17.location, _n72);
                  break;
                case 4:
                  t.vertexAttrib4fv(_s17.location, _n72);
                  break;
                default:
                  t.vertexAttrib1fv(_s17.location, _n72);
              }
            }
          }
        }
        _();
      }(r, l, d, x), null !== y && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(y).buffer));
    },
    reset: x,
    resetDefaultState: y,
    dispose: function dispose() {
      x();
      for (var _t72 in o) {
        var _e62 = o[_t72];
        for (var _t73 in _e62) {
          var _n73 = _e62[_t73];
          for (var _t74 in _n73) d(_n73[_t74].object), delete _n73[_t74];
          delete _e62[_t73];
        }
        delete o[_t72];
      }
    },
    releaseStatesOfGeometry: function releaseStatesOfGeometry(t) {
      if (void 0 === o[t.id]) return;
      var e = o[t.id];
      for (var _t75 in e) {
        var _n74 = e[_t75];
        for (var _t76 in _n74) d(_n74[_t76].object), delete _n74[_t76];
        delete e[_t75];
      }
      delete o[t.id];
    },
    releaseStatesOfProgram: function releaseStatesOfProgram(t) {
      for (var _e63 in o) {
        var _n75 = o[_e63];
        if (void 0 === _n75[t.id]) continue;
        var _i57 = _n75[t.id];
        for (var _t77 in _i57) d(_i57[_t77].object), delete _i57[_t77];
        delete _n75[t.id];
      }
    },
    initAttributes: m,
    enableAttribute: f,
    disableUnusedAttributes: _
  };
}
function Sa(t, e, n, i) {
  var r = i.isWebGL2;
  var s;
  this.setMode = function (t) {
    s = t;
  }, this.render = function (e, i) {
    t.drawArrays(s, e, i), n.update(i, s, 1);
  }, this.renderInstances = function (i, a, o) {
    if (0 === o) return;
    var l, c;
    if (r) l = t, c = "drawArraysInstanced";else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    l[c](s, i, a, o), n.update(a, s, o);
  }, this.renderMultiDraw = function (t, i, r) {
    if (0 === r) return;
    var a = e.get("WEBGL_multi_draw");
    if (null === a) for (var _e64 = 0; _e64 < r; _e64++) this.render(t[_e64], i[_e64]);else {
      a.multiDrawArraysWEBGL(s, t, 0, i, 0, r);
      var _e65 = 0;
      for (var _t78 = 0; _t78 < r; _t78++) _e65 += i[_t78];
      n.update(_e65, s, 1);
    }
  };
}
function ba(t, e, n) {
  var i;
  function r(e) {
    if ("highp" === e) {
      if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
      e = "mediump";
    }
    return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  var s = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === t.constructor.name;
  var a = void 0 !== n.precision ? n.precision : "highp";
  var o = r(a);
  o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
  var l = s || e.has("WEBGL_draw_buffers"),
    c = !0 === n.logarithmicDepthBuffer,
    h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
    u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    d = t.getParameter(t.MAX_TEXTURE_SIZE),
    p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
    m = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
    g = t.getParameter(t.MAX_VARYING_VECTORS),
    _ = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
    v = u > 0,
    x = s || e.has("OES_texture_float");
  return {
    isWebGL2: s,
    drawBuffers: l,
    getMaxAnisotropy: function getMaxAnisotropy() {
      if (void 0 !== i) return i;
      if (!0 === e.has("EXT_texture_filter_anisotropic")) {
        var _n76 = e.get("EXT_texture_filter_anisotropic");
        i = t.getParameter(_n76.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else i = 0;
      return i;
    },
    getMaxPrecision: r,
    precision: a,
    logarithmicDepthBuffer: c,
    maxTextures: h,
    maxVertexTextures: u,
    maxTextureSize: d,
    maxCubemapSize: p,
    maxAttributes: m,
    maxVertexUniforms: f,
    maxVaryings: g,
    maxFragmentUniforms: _,
    vertexTextures: v,
    floatFragmentTextures: x,
    floatVertexTextures: v && x,
    maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0
  };
}
function Ea(t) {
  var e = this;
  var n = null,
    i = 0,
    r = !1,
    s = !1;
  var a = new ca(),
    o = new ti(),
    l = {
      value: null,
      needsUpdate: !1
    };
  function c(t, n, i, r) {
    var s = null !== t ? t.length : 0;
    var c = null;
    if (0 !== s) {
      if (c = l.value, !0 !== r || null === c) {
        var _e66 = i + 4 * s,
          _r40 = n.matrixWorldInverse;
        o.getNormalMatrix(_r40), (null === c || c.length < _e66) && (c = new Float32Array(_e66));
        for (var _e67 = 0, _n77 = i; _e67 !== s; ++_e67, _n77 += 4) a.copy(t[_e67]).applyMatrix4(_r40, o), a.normal.toArray(c, _n77), c[_n77 + 3] = a.constant;
      }
      l.value = c, l.needsUpdate = !0;
    }
    return e.numPlanes = s, e.numIntersection = 0, c;
  }
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e) {
    var n = 0 !== t.length || e || 0 !== i || r;
    return r = e, i = t.length, n;
  }, this.beginShadows = function () {
    s = !0, c(null);
  }, this.endShadows = function () {
    s = !1;
  }, this.setGlobalState = function (t, e) {
    n = c(t, e, 0);
  }, this.setState = function (a, o, h) {
    var u = a.clippingPlanes,
      d = a.clipIntersection,
      p = a.clipShadows,
      m = t.get(a);
    if (!r || null === u || 0 === u.length || s && !p) s ? c(null) : function () {
      l.value !== n && (l.value = n, l.needsUpdate = i > 0);
      e.numPlanes = i, e.numIntersection = 0;
    }();else {
      var _t79 = s ? 0 : i,
        _e68 = 4 * _t79;
      var _r41 = m.clippingState || null;
      l.value = _r41, _r41 = c(u, o, _e68, h);
      for (var _t80 = 0; _t80 !== _e68; ++_t80) _r41[_t80] = n[_t80];
      m.clippingState = _r41, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += _t79;
    }
  };
}
function Ta(t) {
  var e = new WeakMap();
  function n(t, e) {
    return e === ct ? t.mapping = ot : e === ht && (t.mapping = lt), t;
  }
  function i(t) {
    var n = t.target;
    n.removeEventListener("dispose", i);
    var r = e.get(n);
    void 0 !== r && (e.delete(n), r.dispose());
  }
  return {
    get: function get(r) {
      if (r && r.isTexture) {
        var _s18 = r.mapping;
        if (_s18 === ct || _s18 === ht) {
          if (e.has(r)) {
            return n(e.get(r).texture, r.mapping);
          }
          {
            var _s19 = r.image;
            if (_s19 && _s19.height > 0) {
              var _a16 = new sa(_s19.height);
              return _a16.fromEquirectangularTexture(t, r), e.set(r, _a16), r.addEventListener("dispose", i), n(_a16.texture, r.mapping);
            }
            return null;
          }
        }
      }
      return r;
    },
    dispose: function dispose() {
      e = new WeakMap();
    }
  };
}
var wa = exports.OrthographicCamera = /*#__PURE__*/function (_Ks2) {
  function wa() {
    var _this23;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .1;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2e3;
    _classCallCheck(this, wa);
    _this23 = _callSuper(this, wa), _this23.isOrthographicCamera = !0, _this23.type = "OrthographicCamera", _this23.zoom = 1, _this23.view = null, _this23.left = t, _this23.right = e, _this23.top = n, _this23.bottom = i, _this23.near = r, _this23.far = s, _this23.updateProjectionMatrix();
    return _this23;
  }
  _inherits(wa, _Ks2);
  return _createClass(wa, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(wa.prototype), "copy", this).call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this;
    }
  }, {
    key: "setViewOffset",
    value: function setViewOffset(t, e, n, i, r, s) {
      null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var t = (this.right - this.left) / (2 * this.zoom),
        e = (this.top - this.bottom) / (2 * this.zoom),
        n = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2;
      var r = n - t,
        s = n + t,
        a = i + e,
        o = i - e;
      if (null !== this.view && this.view.enabled) {
        var _t81 = (this.right - this.left) / this.view.fullWidth / this.zoom,
          _e69 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        r += _t81 * this.view.offsetX, s = r + _t81 * this.view.width, a -= _e69 * this.view.offsetY, o = a - _e69 * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(wa.prototype), "toJSON", this).call(this, t);
      return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e;
    }
  }]);
}(Ks);
var Aa = [.125, .215, .35, .446, .526, .582],
  Ra = 20,
  Ca = new wa(),
  Pa = new Zr();
var La = null,
  Ia = 0,
  Ua = 0;
var Na = (1 + Math.sqrt(5)) / 2,
  Da = 1 / Na,
  Oa = [new Ii(1, 1, 1), new Ii(-1, 1, 1), new Ii(1, 1, -1), new Ii(-1, 1, -1), new Ii(0, Na, Da), new Ii(0, Na, -Da), new Ii(Da, 0, Na), new Ii(-Da, 0, Na), new Ii(Na, Da, 0), new Ii(-Na, Da, 0)];
var Fa = exports.PMREMGenerator = /*#__PURE__*/function () {
  function Fa(t) {
    _classCallCheck(this, Fa);
    this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  return _createClass(Fa, [{
    key: "fromScene",
    value: function fromScene(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .1;
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
      La = this._renderer.getRenderTarget(), Ia = this._renderer.getActiveCubeFace(), Ua = this._renderer.getActiveMipmapLevel(), this._setSize(256);
      var r = this._allocateTargets();
      return r.depthBuffer = !0, this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r;
    }
  }, {
    key: "fromEquirectangular",
    value: function fromEquirectangular(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this._fromTexture(t, e);
    }
  }, {
    key: "fromCubemap",
    value: function fromCubemap(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this._fromTexture(t, e);
    }
  }, {
    key: "compileCubemapShader",
    value: function compileCubemapShader() {
      null === this._cubemapMaterial && (this._cubemapMaterial = Va(), this._compileMaterial(this._cubemapMaterial));
    }
  }, {
    key: "compileEquirectangularShader",
    value: function compileEquirectangularShader() {
      null === this._equirectMaterial && (this._equirectMaterial = Ha(), this._compileMaterial(this._equirectMaterial));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
  }, {
    key: "_setSize",
    value: function _setSize(t) {
      this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
    }
  }, {
    key: "_dispose",
    value: function _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
      for (var _t82 = 0; _t82 < this._lodPlanes.length; _t82++) this._lodPlanes[_t82].dispose();
    }
  }, {
    key: "_cleanup",
    value: function _cleanup(t) {
      this._renderer.setRenderTarget(La, Ia, Ua), t.scissorTest = !1, za(t, 0, 0, t.width, t.height);
    }
  }, {
    key: "_fromTexture",
    value: function _fromTexture(t, e) {
      t.mapping === ot || t.mapping === lt ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), La = this._renderer.getRenderTarget(), Ia = this._renderer.getActiveCubeFace(), Ua = this._renderer.getActiveMipmapLevel();
      var n = e || this._allocateTargets();
      return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n;
    }
  }, {
    key: "_allocateTargets",
    value: function _allocateTargets() {
      var t = 3 * Math.max(this._cubeSize, 112),
        e = 4 * this._cubeSize,
        n = {
          magFilter: yt,
          minFilter: yt,
          generateMipmaps: !1,
          type: It,
          format: Ft,
          colorSpace: qe,
          depthBuffer: !1
        },
        i = Ba(t, e, n);
      if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
        var _ref;
        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Ba(t, e, n);
        var _i58 = this._lodMax;
        (_ref = function (t) {
          var e = [],
            n = [],
            i = [];
          var r = t;
          var s = t - 4 + 1 + Aa.length;
          for (var _a17 = 0; _a17 < s; _a17++) {
            var _s20 = Math.pow(2, r);
            n.push(_s20);
            var _o11 = 1 / _s20;
            _a17 > t - 4 ? _o11 = Aa[_a17 - t + 4 - 1] : 0 === _a17 && (_o11 = 0), i.push(_o11);
            var _l7 = 1 / (_s20 - 2),
              _c7 = -_l7,
              _h5 = 1 + _l7,
              _u5 = [_c7, _c7, _h5, _c7, _h5, _h5, _c7, _c7, _h5, _h5, _c7, _h5],
              _d5 = 6,
              _p6 = 6,
              _m3 = 3,
              _f = 2,
              _g = 1,
              _3 = new Float32Array(_m3 * _p6 * _d5),
              _v2 = new Float32Array(_f * _p6 * _d5),
              _x2 = new Float32Array(_g * _p6 * _d5);
            for (var _t83 = 0; _t83 < _d5; _t83++) {
              var _e70 = _t83 % 3 * 2 / 3 - 1,
                _n78 = _t83 > 2 ? 0 : -1,
                _i59 = [_e70, _n78, 0, _e70 + 2 / 3, _n78, 0, _e70 + 2 / 3, _n78 + 1, 0, _e70, _n78, 0, _e70 + 2 / 3, _n78 + 1, 0, _e70, _n78 + 1, 0];
              _3.set(_i59, _m3 * _p6 * _t83), _v2.set(_u5, _f * _p6 * _t83);
              var _r42 = [_t83, _t83, _t83, _t83, _t83, _t83];
              _x2.set(_r42, _g * _p6 * _t83);
            }
            var _y2 = new Ts();
            _y2.setAttribute("position", new os(_3, _m3)), _y2.setAttribute("uv", new os(_v2, _f)), _y2.setAttribute("faceIndex", new os(_x2, _g)), e.push(_y2), r > 4 && r--;
          }
          return {
            lodPlanes: e,
            sizeLods: n,
            sigmas: i
          };
        }(_i58), this._sizeLods = _ref.sizeLods, this._lodPlanes = _ref.lodPlanes, this._sigmas = _ref.sigmas), this._blurMaterial = function (t, e, n) {
          var i = new Float32Array(Ra),
            r = new Ii(0, 1, 0),
            s = new Js({
              name: "SphericalGaussianBlur",
              defines: {
                n: Ra,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / n,
                CUBEUV_MAX_MIP: "".concat(t, ".0")
              },
              uniforms: {
                envMap: {
                  value: null
                },
                samples: {
                  value: 1
                },
                weights: {
                  value: i
                },
                latitudinal: {
                  value: !1
                },
                dTheta: {
                  value: 0
                },
                mipInt: {
                  value: 0
                },
                poleAxis: {
                  value: r
                }
              },
              vertexShader: ka(),
              fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
              blending: 0,
              depthTest: !1,
              depthWrite: !1
            });
          return s;
        }(_i58, t, e);
      }
      return i;
    }
  }, {
    key: "_compileMaterial",
    value: function _compileMaterial(t) {
      var e = new Gs(this._lodPlanes[0], t);
      this._renderer.compile(e, Ca);
    }
  }, {
    key: "_sceneToCubeUV",
    value: function _sceneToCubeUV(t, e, n, i) {
      var r = new ea(90, 1, e, n),
        s = [1, -1, 1, 1, 1, 1],
        a = [1, 1, 1, -1, -1, -1],
        o = this._renderer,
        l = o.autoClear,
        c = o.toneMapping;
      o.getClearColor(Pa), o.toneMapping = K, o.autoClear = !1;
      var h = new Qr({
          name: "PMREM.Background",
          side: d,
          depthWrite: !1,
          depthTest: !1
        }),
        u = new Gs(new Xs(), h);
      var p = !1;
      var m = t.background;
      m ? m.isColor && (h.color.copy(m), t.background = null, p = !0) : (h.color.copy(Pa), p = !0);
      for (var _e71 = 0; _e71 < 6; _e71++) {
        var _n79 = _e71 % 3;
        0 === _n79 ? (r.up.set(0, s[_e71], 0), r.lookAt(a[_e71], 0, 0)) : 1 === _n79 ? (r.up.set(0, 0, s[_e71]), r.lookAt(0, a[_e71], 0)) : (r.up.set(0, s[_e71], 0), r.lookAt(0, 0, a[_e71]));
        var _l8 = this._cubeSize;
        za(i, _n79 * _l8, _e71 > 2 ? _l8 : 0, _l8, _l8), o.setRenderTarget(i), p && o.render(u, r), o.render(t, r);
      }
      u.geometry.dispose(), u.material.dispose(), o.toneMapping = c, o.autoClear = l, t.background = m;
    }
  }, {
    key: "_textureToCubeUV",
    value: function _textureToCubeUV(t, e) {
      var n = this._renderer,
        i = t.mapping === ot || t.mapping === lt;
      i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Va()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Ha());
      var r = i ? this._cubemapMaterial : this._equirectMaterial,
        s = new Gs(this._lodPlanes[0], r);
      r.uniforms.envMap.value = t;
      var a = this._cubeSize;
      za(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(s, Ca);
    }
  }, {
    key: "_applyPMREM",
    value: function _applyPMREM(t) {
      var e = this._renderer,
        n = e.autoClear;
      e.autoClear = !1;
      for (var _e72 = 1; _e72 < this._lodPlanes.length; _e72++) {
        var _n80 = Math.sqrt(this._sigmas[_e72] * this._sigmas[_e72] - this._sigmas[_e72 - 1] * this._sigmas[_e72 - 1]),
          _i60 = Oa[(_e72 - 1) % Oa.length];
        this._blur(t, _e72 - 1, _e72, _n80, _i60);
      }
      e.autoClear = n;
    }
  }, {
    key: "_blur",
    value: function _blur(t, e, n, i, r) {
      var s = this._pingPongRenderTarget;
      this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r);
    }
  }, {
    key: "_halfBlur",
    value: function _halfBlur(t, e, n, i, r, s, a) {
      var o = this._renderer,
        l = this._blurMaterial;
      "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
      var c = new Gs(this._lodPlanes[i], l),
        h = l.uniforms,
        u = this._sizeLods[n] - 1,
        d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
        p = r / d,
        m = isFinite(r) ? 1 + Math.floor(3 * p) : Ra;
      m > Ra && console.warn("sigmaRadians, ".concat(r, ", is too large and will clip, as it requested ").concat(m, " samples when the maximum is set to 20"));
      var f = [];
      var g = 0;
      for (var _t84 = 0; _t84 < Ra; ++_t84) {
        var _e73 = _t84 / p,
          _n81 = Math.exp(-_e73 * _e73 / 2);
        f.push(_n81), 0 === _t84 ? g += _n81 : _t84 < m && (g += 2 * _n81);
      }
      for (var _t85 = 0; _t85 < f.length; _t85++) f[_t85] = f[_t85] / g;
      h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a);
      var _ = this._lodMax;
      h.dTheta.value = d, h.mipInt.value = _ - n;
      var v = this._sizeLods[i];
      za(e, 3 * v * (i > _ - 4 ? i - _ + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), o.setRenderTarget(e), o.render(c, Ca);
    }
  }]);
}();
function Ba(t, e, n) {
  var i = new Ti(t, e, n);
  return i.texture.mapping = ut, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function za(t, e, n, i, r) {
  t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
}
function Ha() {
  return new Js({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: {
        value: null
      }
    },
    vertexShader: ka(),
    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}
function Va() {
  return new Js({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: {
        value: null
      },
      flipEnvMap: {
        value: -1
      }
    },
    vertexShader: ka(),
    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}
function ka() {
  return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
}
function Ga(t) {
  var e = new WeakMap(),
    n = null;
  function i(t) {
    var n = t.target;
    n.removeEventListener("dispose", i);
    var r = e.get(n);
    void 0 !== r && (e.delete(n), r.dispose());
  }
  return {
    get: function get(r) {
      if (r && r.isTexture) {
        var _s21 = r.mapping,
          _a18 = _s21 === ct || _s21 === ht,
          _o12 = _s21 === ot || _s21 === lt;
        if (_a18 || _o12) {
          if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
            r.needsPMREMUpdate = !1;
            var _i61 = e.get(r);
            return null === n && (n = new Fa(t)), _i61 = _a18 ? n.fromEquirectangular(r, _i61) : n.fromCubemap(r, _i61), e.set(r, _i61), _i61.texture;
          }
          if (e.has(r)) return e.get(r).texture;
          {
            var _s22 = r.image;
            if (_a18 && _s22 && _s22.height > 0 || _o12 && _s22 && function (t) {
              var e = 0;
              var n = 6;
              for (var _i62 = 0; _i62 < n; _i62++) void 0 !== t[_i62] && e++;
              return e === n;
            }(_s22)) {
              null === n && (n = new Fa(t));
              var _s23 = _a18 ? n.fromEquirectangular(r) : n.fromCubemap(r);
              return e.set(r, _s23), r.addEventListener("dispose", i), _s23.texture;
            }
            return null;
          }
        }
      }
      return r;
    },
    dispose: function dispose() {
      e = new WeakMap(), null !== n && (n.dispose(), n = null);
    }
  };
}
function Wa(t) {
  var e = {};
  function n(n) {
    if (void 0 !== e[n]) return e[n];
    var i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = t.getExtension(n);
    }
    return e[n] = i, i;
  }
  return {
    has: function has(t) {
      return null !== n(t);
    },
    init: function init(t) {
      t.isWebGL2 ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture");
    },
    get: function get(t) {
      var e = n(t);
      return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e;
    }
  };
}
function Xa(t, e, n, i) {
  var r = {},
    s = new WeakMap();
  function a(t) {
    var o = t.target;
    null !== o.index && e.remove(o.index);
    for (var _t86 in o.attributes) e.remove(o.attributes[_t86]);
    for (var _t87 in o.morphAttributes) {
      var _n82 = o.morphAttributes[_t87];
      for (var _t88 = 0, _i63 = _n82.length; _t88 < _i63; _t88++) e.remove(_n82[_t88]);
    }
    o.removeEventListener("dispose", a), delete r[o.id];
    var l = s.get(o);
    l && (e.remove(l), s.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--;
  }
  function o(t) {
    var n = [],
      i = t.index,
      r = t.attributes.position;
    var a = 0;
    if (null !== i) {
      var _t89 = i.array;
      a = i.version;
      for (var _e74 = 0, _i64 = _t89.length; _e74 < _i64; _e74 += 3) {
        var _i65 = _t89[_e74 + 0],
          _r43 = _t89[_e74 + 1],
          _s24 = _t89[_e74 + 2];
        n.push(_i65, _r43, _r43, _s24, _s24, _i65);
      }
    } else {
      if (void 0 === r) return;
      {
        var _t90 = r.array;
        a = r.version;
        for (var _e75 = 0, _i66 = _t90.length / 3 - 1; _e75 < _i66; _e75 += 3) {
          var _t91 = _e75 + 0,
            _i67 = _e75 + 1,
            _r44 = _e75 + 2;
          n.push(_t91, _i67, _i67, _r44, _r44, _t91);
        }
      }
    }
    var o = new (ni(n) ? ms : ds)(n, 1);
    o.version = a;
    var l = s.get(t);
    l && e.remove(l), s.set(t, o);
  }
  return {
    get: function get(t, e) {
      return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, n.memory.geometries++), e;
    },
    update: function update(n) {
      var i = n.attributes;
      for (var _n83 in i) e.update(i[_n83], t.ARRAY_BUFFER);
      var r = n.morphAttributes;
      for (var _n84 in r) {
        var _i68 = r[_n84];
        for (var _n85 = 0, _r45 = _i68.length; _n85 < _r45; _n85++) e.update(_i68[_n85], t.ARRAY_BUFFER);
      }
    },
    getWireframeAttribute: function getWireframeAttribute(t) {
      var e = s.get(t);
      if (e) {
        var _n86 = t.index;
        null !== _n86 && e.version < _n86.version && o(t);
      } else o(t);
      return s.get(t);
    }
  };
}
function ja(t, e, n, i) {
  var r = i.isWebGL2;
  var s, a, o;
  this.setMode = function (t) {
    s = t;
  }, this.setIndex = function (t) {
    a = t.type, o = t.bytesPerElement;
  }, this.render = function (e, i) {
    t.drawElements(s, i, a, e * o), n.update(i, s, 1);
  }, this.renderInstances = function (i, l, c) {
    if (0 === c) return;
    var h, u;
    if (r) h = t, u = "drawElementsInstanced";else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    h[u](s, l, a, i * o, c), n.update(l, s, c);
  }, this.renderMultiDraw = function (t, i, r) {
    if (0 === r) return;
    var l = e.get("WEBGL_multi_draw");
    if (null === l) for (var _e76 = 0; _e76 < r; _e76++) this.render(t[_e76] / o, i[_e76]);else {
      l.multiDrawElementsWEBGL(s, i, 0, a, t, 0, r);
      var _e77 = 0;
      for (var _t92 = 0; _t92 < r; _t92++) _e77 += i[_t92];
      n.update(_e77, s, 1);
    }
  };
}
function qa(t) {
  var e = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  return {
    memory: {
      geometries: 0,
      textures: 0
    },
    render: e,
    programs: null,
    autoReset: !0,
    reset: function reset() {
      e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
    },
    update: function update(n, i, r) {
      switch (e.calls++, i) {
        case t.TRIANGLES:
          e.triangles += r * (n / 3);
          break;
        case t.LINES:
          e.lines += r * (n / 2);
          break;
        case t.LINE_STRIP:
          e.lines += r * (n - 1);
          break;
        case t.LINE_LOOP:
          e.lines += r * n;
          break;
        case t.POINTS:
          e.points += r * n;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", i);
      }
    }
  };
}
function Ya(t, e) {
  return t[0] - e[0];
}
function Za(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function Ja(t, e, n) {
  var i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    a = new bi(),
    o = [];
  for (var _t93 = 0; _t93 < 8; _t93++) o[_t93] = [_t93, 0];
  return {
    update: function update(l, c, h) {
      var u = l.morphTargetInfluences;
      if (!0 === e.isWebGL2) {
        var _d6 = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
          _p7 = void 0 !== _d6 ? _d6.length : 0;
        var _m4 = s.get(c);
        if (void 0 === _m4 || _m4.count !== _p7) {
          void 0 !== _m4 && _m4.texture.dispose();
          var _4 = void 0 !== c.morphAttributes.position,
            _v3 = void 0 !== c.morphAttributes.normal,
            _x3 = void 0 !== c.morphAttributes.color,
            _y3 = c.morphAttributes.position || [],
            _M = c.morphAttributes.normal || [],
            _S = c.morphAttributes.color || [];
          var _b = 0;
          !0 === _4 && (_b = 1), !0 === _v3 && (_b = 2), !0 === _x3 && (_b = 3);
          var _E = c.attributes.position.count * _b,
            _T = 1;
          _E > e.maxTextureSize && (_T = Math.ceil(_E / e.maxTextureSize), _E = e.maxTextureSize);
          var _w = new Float32Array(_E * _T * 4 * _p7),
            _A = new wi(_w, _E, _T, _p7);
          _A.type = Lt, _A.needsUpdate = !0;
          var _R = 4 * _b;
          for (var _P = 0; _P < _p7; _P++) {
            var _L = _y3[_P],
              _I = _M[_P],
              _U = _S[_P],
              _N = _E * _T * 4 * _P;
            for (var _D = 0; _D < _L.count; _D++) {
              var _O = _D * _R;
              !0 === _4 && (a.fromBufferAttribute(_L, _D), _w[_N + _O + 0] = a.x, _w[_N + _O + 1] = a.y, _w[_N + _O + 2] = a.z, _w[_N + _O + 3] = 0), !0 === _v3 && (a.fromBufferAttribute(_I, _D), _w[_N + _O + 4] = a.x, _w[_N + _O + 5] = a.y, _w[_N + _O + 6] = a.z, _w[_N + _O + 7] = 0), !0 === _x3 && (a.fromBufferAttribute(_U, _D), _w[_N + _O + 8] = a.x, _w[_N + _O + 9] = a.y, _w[_N + _O + 10] = a.z, _w[_N + _O + 11] = 4 === _U.itemSize ? a.w : 1);
            }
          }
          function C() {
            _A.dispose(), s.delete(c), c.removeEventListener("dispose", C);
          }
          _m4 = {
            count: _p7,
            texture: _A,
            size: new Qn(_E, _T)
          }, s.set(c, _m4), c.addEventListener("dispose", C);
        }
        var _f2 = 0;
        for (var _F = 0; _F < u.length; _F++) _f2 += u[_F];
        var _g2 = c.morphTargetsRelative ? 1 : 1 - _f2;
        h.getUniforms().setValue(t, "morphTargetBaseInfluence", _g2), h.getUniforms().setValue(t, "morphTargetInfluences", u), h.getUniforms().setValue(t, "morphTargetsTexture", _m4.texture, n), h.getUniforms().setValue(t, "morphTargetsTextureSize", _m4.size);
      } else {
        var _B = void 0 === u ? 0 : u.length;
        var _z = i[c.id];
        if (void 0 === _z || _z.length !== _B) {
          _z = [];
          for (var _W = 0; _W < _B; _W++) _z[_W] = [_W, 0];
          i[c.id] = _z;
        }
        for (var _X = 0; _X < _B; _X++) {
          var _j = _z[_X];
          _j[0] = _X, _j[1] = u[_X];
        }
        _z.sort(Za);
        for (var _q = 0; _q < 8; _q++) _q < _B && _z[_q][1] ? (o[_q][0] = _z[_q][0], o[_q][1] = _z[_q][1]) : (o[_q][0] = Number.MAX_SAFE_INTEGER, o[_q][1] = 0);
        o.sort(Ya);
        var _H = c.morphAttributes.position,
          _V = c.morphAttributes.normal;
        var _k = 0;
        for (var _Y = 0; _Y < 8; _Y++) {
          var _Z = o[_Y],
            _J = _Z[0],
            _K = _Z[1];
          _J !== Number.MAX_SAFE_INTEGER && _K ? (_H && c.getAttribute("morphTarget" + _Y) !== _H[_J] && c.setAttribute("morphTarget" + _Y, _H[_J]), _V && c.getAttribute("morphNormal" + _Y) !== _V[_J] && c.setAttribute("morphNormal" + _Y, _V[_J]), r[_Y] = _K, _k += _K) : (_H && !0 === c.hasAttribute("morphTarget" + _Y) && c.deleteAttribute("morphTarget" + _Y), _V && !0 === c.hasAttribute("morphNormal" + _Y) && c.deleteAttribute("morphNormal" + _Y), r[_Y] = 0);
        }
        var _G = c.morphTargetsRelative ? 1 : 1 - _k;
        h.getUniforms().setValue(t, "morphTargetBaseInfluence", _G), h.getUniforms().setValue(t, "morphTargetInfluences", r);
      }
    }
  };
}
function Ka(t, e, n, i) {
  var r = new WeakMap();
  function s(t) {
    var e = t.target;
    e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor);
  }
  return {
    update: function update(a) {
      var o = i.render.frame,
        l = a.geometry,
        c = e.get(a, l);
      if (r.get(c) !== o && (e.update(c), r.set(c, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), r.get(a) !== o && (n.update(a.instanceMatrix, t.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER), r.set(a, o))), a.isSkinnedMesh) {
        var _t94 = a.skeleton;
        r.get(_t94) !== o && (_t94.update(), r.set(_t94, o));
      }
      return c;
    },
    dispose: function dispose() {
      r = new WeakMap();
    }
  };
}
var $a = exports.DepthTexture = /*#__PURE__*/function (_Si4) {
  function $a(t, e, n, i, r, s, a, o, l, c) {
    var _this24;
    _classCallCheck(this, $a);
    if ((c = void 0 !== c ? c : Ht) !== Ht && c !== Vt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    void 0 === n && c === Ht && (n = Pt), void 0 === n && c === Vt && (n = Dt), _this24 = _callSuper(this, $a, [null, i, r, s, a, o, c, n, l]), _this24.isDepthTexture = !0, _this24.image = {
      width: t,
      height: e
    }, _this24.magFilter = void 0 !== a ? a : ft, _this24.minFilter = void 0 !== o ? o : ft, _this24.flipY = !1, _this24.generateMipmaps = !1, _this24.compareFunction = null;
    return _this24;
  }
  _inherits($a, _Si4);
  return _createClass($a, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf($a.prototype), "copy", this).call(this, t), this.compareFunction = t.compareFunction, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf($a.prototype), "toJSON", this).call(this, t);
      return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e;
    }
  }]);
}(Si);
var Qa = new Si(),
  to = new $a(1, 1);
to.compareFunction = 515;
var eo = new wi(),
  no = new Ri(),
  io = new ra(),
  ro = [],
  so = [],
  ao = new Float32Array(16),
  oo = new Float32Array(9),
  lo = new Float32Array(4);
function co(t, e, n) {
  var i = t[0];
  if (i <= 0 || i > 0) return t;
  var r = e * n;
  var s = ro[r];
  if (void 0 === s && (s = new Float32Array(r), ro[r] = s), 0 !== e) {
    i.toArray(s, 0);
    for (var _i69 = 1, _r46 = 0; _i69 !== e; ++_i69) _r46 += n, t[_i69].toArray(s, _r46);
  }
  return s;
}
function ho(t, e) {
  if (t.length !== e.length) return !1;
  for (var _n87 = 0, _i70 = t.length; _n87 < _i70; _n87++) if (t[_n87] !== e[_n87]) return !1;
  return !0;
}
function uo(t, e) {
  for (var _n88 = 0, _i71 = e.length; _n88 < _i71; _n88++) t[_n88] = e[_n88];
}
function po(t, e) {
  var n = so[e];
  void 0 === n && (n = new Int32Array(e), so[e] = n);
  for (var _i72 = 0; _i72 !== e; ++_i72) n[_i72] = t.allocateTextureUnit();
  return n;
}
function mo(t, e) {
  var n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e);
}
function fo(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);else {
    if (ho(n, e)) return;
    t.uniform2fv(this.addr, e), uo(n, e);
  }
}
function go(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);else {
    if (ho(n, e)) return;
    t.uniform3fv(this.addr, e), uo(n, e);
  }
}
function _o(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);else {
    if (ho(n, e)) return;
    t.uniform4fv(this.addr, e), uo(n, e);
  }
}
function vo(t, e) {
  var n = this.cache,
    i = e.elements;
  if (void 0 === i) {
    if (ho(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), uo(n, e);
  } else {
    if (ho(n, i)) return;
    lo.set(i), t.uniformMatrix2fv(this.addr, !1, lo), uo(n, i);
  }
}
function xo(t, e) {
  var n = this.cache,
    i = e.elements;
  if (void 0 === i) {
    if (ho(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), uo(n, e);
  } else {
    if (ho(n, i)) return;
    oo.set(i), t.uniformMatrix3fv(this.addr, !1, oo), uo(n, i);
  }
}
function yo(t, e) {
  var n = this.cache,
    i = e.elements;
  if (void 0 === i) {
    if (ho(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), uo(n, e);
  } else {
    if (ho(n, i)) return;
    ao.set(i), t.uniformMatrix4fv(this.addr, !1, ao), uo(n, i);
  }
}
function Mo(t, e) {
  var n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e);
}
function So(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);else {
    if (ho(n, e)) return;
    t.uniform2iv(this.addr, e), uo(n, e);
  }
}
function bo(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);else {
    if (ho(n, e)) return;
    t.uniform3iv(this.addr, e), uo(n, e);
  }
}
function Eo(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);else {
    if (ho(n, e)) return;
    t.uniform4iv(this.addr, e), uo(n, e);
  }
}
function To(t, e) {
  var n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e);
}
function wo(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);else {
    if (ho(n, e)) return;
    t.uniform2uiv(this.addr, e), uo(n, e);
  }
}
function Ao(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);else {
    if (ho(n, e)) return;
    t.uniform3uiv(this.addr, e), uo(n, e);
  }
}
function Ro(t, e) {
  var n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);else {
    if (ho(n, e)) return;
    t.uniform4uiv(this.addr, e), uo(n, e);
  }
}
function Co(t, e, n) {
  var i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r);
  var s = this.type === t.SAMPLER_2D_SHADOW ? to : Qa;
  n.setTexture2D(e || s, r);
}
function Po(t, e, n) {
  var i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || no, r);
}
function Lo(t, e, n) {
  var i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || io, r);
}
function Io(t, e, n) {
  var i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || eo, r);
}
function Uo(t, e) {
  t.uniform1fv(this.addr, e);
}
function No(t, e) {
  var n = co(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function Do(t, e) {
  var n = co(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function Oo(t, e) {
  var n = co(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function Fo(t, e) {
  var n = co(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function Bo(t, e) {
  var n = co(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function zo(t, e) {
  var n = co(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function Ho(t, e) {
  t.uniform1iv(this.addr, e);
}
function Vo(t, e) {
  t.uniform2iv(this.addr, e);
}
function ko(t, e) {
  t.uniform3iv(this.addr, e);
}
function Go(t, e) {
  t.uniform4iv(this.addr, e);
}
function Wo(t, e) {
  t.uniform1uiv(this.addr, e);
}
function Xo(t, e) {
  t.uniform2uiv(this.addr, e);
}
function jo(t, e) {
  t.uniform3uiv(this.addr, e);
}
function qo(t, e) {
  t.uniform4uiv(this.addr, e);
}
function Yo(t, e, n) {
  var i = this.cache,
    r = e.length,
    s = po(n, r);
  ho(i, s) || (t.uniform1iv(this.addr, s), uo(i, s));
  for (var _t95 = 0; _t95 !== r; ++_t95) n.setTexture2D(e[_t95] || Qa, s[_t95]);
}
function Zo(t, e, n) {
  var i = this.cache,
    r = e.length,
    s = po(n, r);
  ho(i, s) || (t.uniform1iv(this.addr, s), uo(i, s));
  for (var _t96 = 0; _t96 !== r; ++_t96) n.setTexture3D(e[_t96] || no, s[_t96]);
}
function Jo(t, e, n) {
  var i = this.cache,
    r = e.length,
    s = po(n, r);
  ho(i, s) || (t.uniform1iv(this.addr, s), uo(i, s));
  for (var _t97 = 0; _t97 !== r; ++_t97) n.setTextureCube(e[_t97] || io, s[_t97]);
}
function Ko(t, e, n) {
  var i = this.cache,
    r = e.length,
    s = po(n, r);
  ho(i, s) || (t.uniform1iv(this.addr, s), uo(i, s));
  for (var _t98 = 0; _t98 !== r; ++_t98) n.setTexture2DArray(e[_t98] || eo, s[_t98]);
}
var $o = /*#__PURE__*/_createClass(function $o(t, e, n) {
  _classCallCheck(this, $o);
  this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = function (t) {
    switch (t) {
      case 5126:
        return mo;
      case 35664:
        return fo;
      case 35665:
        return go;
      case 35666:
        return _o;
      case 35674:
        return vo;
      case 35675:
        return xo;
      case 35676:
        return yo;
      case 5124:
      case 35670:
        return Mo;
      case 35667:
      case 35671:
        return So;
      case 35668:
      case 35672:
        return bo;
      case 35669:
      case 35673:
        return Eo;
      case 5125:
        return To;
      case 36294:
        return wo;
      case 36295:
        return Ao;
      case 36296:
        return Ro;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Co;
      case 35679:
      case 36299:
      case 36307:
        return Po;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Lo;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Io;
    }
  }(e.type);
});
var Qo = /*#__PURE__*/_createClass(function Qo(t, e, n) {
  _classCallCheck(this, Qo);
  this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = function (t) {
    switch (t) {
      case 5126:
        return Uo;
      case 35664:
        return No;
      case 35665:
        return Do;
      case 35666:
        return Oo;
      case 35674:
        return Fo;
      case 35675:
        return Bo;
      case 35676:
        return zo;
      case 5124:
      case 35670:
        return Ho;
      case 35667:
      case 35671:
        return Vo;
      case 35668:
      case 35672:
        return ko;
      case 35669:
      case 35673:
        return Go;
      case 5125:
        return Wo;
      case 36294:
        return Xo;
      case 36295:
        return jo;
      case 36296:
        return qo;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Yo;
      case 35679:
      case 36299:
      case 36307:
        return Zo;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Jo;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Ko;
    }
  }(e.type);
});
var tl = /*#__PURE__*/function () {
  function tl(t) {
    _classCallCheck(this, tl);
    this.id = t, this.seq = [], this.map = {};
  }
  return _createClass(tl, [{
    key: "setValue",
    value: function setValue(t, e, n) {
      var i = this.seq;
      for (var _r47 = 0, _s25 = i.length; _r47 !== _s25; ++_r47) {
        var _s26 = i[_r47];
        _s26.setValue(t, e[_s26.id], n);
      }
    }
  }]);
}();
var el = /(\w+)(\])?(\[|\.)?/g;
function nl(t, e) {
  t.seq.push(e), t.map[e.id] = e;
}
function il(t, e, n) {
  var i = t.name,
    r = i.length;
  for (el.lastIndex = 0;;) {
    var _s27 = el.exec(i),
      _a19 = el.lastIndex;
    var _o13 = _s27[1];
    var _l9 = "]" === _s27[2],
      _c8 = _s27[3];
    if (_l9 && (_o13 |= 0), void 0 === _c8 || "[" === _c8 && _a19 + 2 === r) {
      nl(n, void 0 === _c8 ? new $o(_o13, t, e) : new Qo(_o13, t, e));
      break;
    }
    {
      var _t99 = n.map[_o13];
      void 0 === _t99 && (_t99 = new tl(_o13), nl(n, _t99)), n = _t99;
    }
  }
}
var rl = /*#__PURE__*/function () {
  function rl(t, e) {
    _classCallCheck(this, rl);
    this.seq = [], this.map = {};
    var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (var _i73 = 0; _i73 < n; ++_i73) {
      var _n89 = t.getActiveUniform(e, _i73);
      il(_n89, t.getUniformLocation(e, _n89.name), this);
    }
  }
  return _createClass(rl, [{
    key: "setValue",
    value: function setValue(t, e, n, i) {
      var r = this.map[e];
      void 0 !== r && r.setValue(t, n, i);
    }
  }, {
    key: "setOptional",
    value: function setOptional(t, e, n) {
      var i = e[n];
      void 0 !== i && this.setValue(t, n, i);
    }
  }], [{
    key: "upload",
    value: function upload(t, e, n, i) {
      for (var _r48 = 0, _s28 = e.length; _r48 !== _s28; ++_r48) {
        var _s29 = e[_r48],
          _a20 = n[_s29.id];
        !1 !== _a20.needsUpdate && _s29.setValue(t, _a20.value, i);
      }
    }
  }, {
    key: "seqWithValue",
    value: function seqWithValue(t, e) {
      var n = [];
      for (var _i74 = 0, _r49 = t.length; _i74 !== _r49; ++_i74) {
        var _r50 = t[_i74];
        _r50.id in e && n.push(_r50);
      }
      return n;
    }
  }]);
}();
function sl(t, e, n) {
  var i = t.createShader(e);
  return t.shaderSource(i, n), t.compileShader(i), i;
}
var al = 37297;
var ol = 0;
function ll(t, e, n) {
  var i = t.getShaderParameter(e, t.COMPILE_STATUS),
    r = t.getShaderInfoLog(e).trim();
  if (i && "" === r) return "";
  var s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    var _i75 = parseInt(s[1]);
    return n.toUpperCase() + "\n\n" + r + "\n\n" + function (t, e) {
      var n = t.split("\n"),
        i = [],
        r = Math.max(e - 6, 0),
        s = Math.min(e + 6, n.length);
      for (var _t100 = r; _t100 < s; _t100++) {
        var _r51 = _t100 + 1;
        i.push("".concat(_r51 === e ? ">" : " ", " ").concat(_r51, ": ").concat(n[_t100]));
      }
      return i.join("\n");
    }(t.getShaderSource(e), _i75);
  }
  return r;
}
function cl(t, e) {
  var n = function (t) {
    var e = pi.getPrimaries(pi.workingColorSpace),
      n = pi.getPrimaries(t);
    var i;
    switch (e === n ? i = "" : e === Qe && n === $e ? i = "LinearDisplayP3ToLinearSRGB" : e === $e && n === Qe && (i = "LinearSRGBToLinearDisplayP3"), t) {
      case qe:
      case Ze:
        return [i, "LinearTransferOETF"];
      case je:
      case Ye:
        return [i, "sRGBTransferOETF"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", t), [i, "LinearTransferOETF"];
    }
  }(e);
  return "vec4 ".concat(t, "( vec4 value ) { return ").concat(n[0], "( ").concat(n[1], "( value ) ); }");
}
function hl(t, e) {
  var n;
  switch (e) {
    case $:
      n = "Linear";
      break;
    case Q:
      n = "Reinhard";
      break;
    case tt:
      n = "OptimizedCineon";
      break;
    case et:
      n = "ACESFilmic";
      break;
    case it:
      n = "AgX";
      break;
    case nt:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
function ul(t) {
  return "" !== t;
}
function dl(t, e) {
  var n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function pl(t, e) {
  return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
var ml = /^[ \t]*#include +<([\w\d./]+)>/gm;
function fl(t) {
  return t.replace(ml, _l);
}
var gl = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
function _l(t, e) {
  var n = ga[e];
  if (void 0 === n) {
    var _t101 = gl.get(e);
    if (void 0 === _t101) throw new Error("Can not resolve #include <" + e + ">");
    n = ga[_t101], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, _t101);
  }
  return fl(n);
}
var vl = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function xl(t) {
  return t.replace(vl, yl);
}
function yl(t, e, n, i) {
  var r = "";
  for (var _t102 = parseInt(e); _t102 < parseInt(n); _t102++) r += i.replace(/\[\s*i\s*\]/g, "[ " + _t102 + " ]").replace(/UNROLLED_LOOP_INDEX/g, _t102);
  return r;
}
function Ml(t) {
  var e = "precision ".concat(t.precision, " float;\n\tprecision ").concat(t.precision, " int;\n\tprecision ").concat(t.precision, " sampler2D;\n\tprecision ").concat(t.precision, " samplerCube;\n\t");
  return t.isWebGL2 && (e += "precision ".concat(t.precision, " sampler3D;\n\t\tprecision ").concat(t.precision, " sampler2DArray;\n\t\tprecision ").concat(t.precision, " sampler2DShadow;\n\t\tprecision ").concat(t.precision, " samplerCubeShadow;\n\t\tprecision ").concat(t.precision, " sampler2DArrayShadow;\n\t\tprecision ").concat(t.precision, " isampler2D;\n\t\tprecision ").concat(t.precision, " isampler3D;\n\t\tprecision ").concat(t.precision, " isamplerCube;\n\t\tprecision ").concat(t.precision, " isampler2DArray;\n\t\tprecision ").concat(t.precision, " usampler2D;\n\t\tprecision ").concat(t.precision, " usampler3D;\n\t\tprecision ").concat(t.precision, " usamplerCube;\n\t\tprecision ").concat(t.precision, " usampler2DArray;\n\t\t")), "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e;
}
function Sl(t, e, n, i) {
  var r = t.getContext(),
    s = n.defines;
  var a = n.vertexShader,
    o = n.fragmentShader;
  var u = function (t) {
      var e = "SHADOWMAP_TYPE_BASIC";
      return t.shadowMapType === l ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === c ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === h && (e = "SHADOWMAP_TYPE_VSM"), e;
    }(n),
    d = function (t) {
      var e = "ENVMAP_TYPE_CUBE";
      if (t.envMap) switch (t.envMapMode) {
        case ot:
        case lt:
          e = "ENVMAP_TYPE_CUBE";
          break;
        case ut:
          e = "ENVMAP_TYPE_CUBE_UV";
      }
      return e;
    }(n),
    p = function (t) {
      var e = "ENVMAP_MODE_REFLECTION";
      t.envMap && t.envMapMode === lt && (e = "ENVMAP_MODE_REFRACTION");
      return e;
    }(n),
    m = function (t) {
      var e = "ENVMAP_BLENDING_NONE";
      if (t.envMap) switch (t.combine) {
        case Y:
          e = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case Z:
          e = "ENVMAP_BLENDING_MIX";
          break;
        case J:
          e = "ENVMAP_BLENDING_ADD";
      }
      return e;
    }(n),
    f = function (t) {
      var e = t.envMapCubeUVHeight;
      if (null === e) return null;
      var n = Math.log2(e) - 2,
        i = 1 / e;
      return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
        texelHeight: i,
        maxMip: n
      };
    }(n),
    g = n.isWebGL2 ? "" : function (t) {
      return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || t.alphaToCoverage || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ul).join("\n");
    }(n),
    _ = function (t) {
      return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(ul).join("\n");
    }(n),
    v = function (t) {
      var e = [];
      for (var _n90 in t) {
        var _i76 = t[_n90];
        !1 !== _i76 && e.push("#define " + _n90 + " " + _i76);
      }
      return e.join("\n");
    }(s),
    x = r.createProgram();
  var y,
    M,
    S = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
  n.isRawShaderMaterial ? (y = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter(ul).join("\n"), y.length > 0 && (y += "\n"), M = [g, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter(ul).join("\n"), M.length > 0 && (M += "\n")) : (y = [Ml(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ul).join("\n"), M = [g, Ml(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== K ? "#define TONE_MAPPING" : "", n.toneMapping !== K ? ga.tonemapping_pars_fragment : "", n.toneMapping !== K ? hl("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", ga.colorspace_pars_fragment, cl("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ul).join("\n")), a = fl(a), a = dl(a, n), a = pl(a, n), o = fl(o), o = dl(o, n), o = pl(o, n), a = xl(a), o = xl(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (S = "#version 300 es\n", y = [_, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, M = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === Dn ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Dn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + M);
  var b = S + y + a,
    E = S + M + o,
    T = sl(r, r.VERTEX_SHADER, b),
    w = sl(r, r.FRAGMENT_SHADER, E);
  function A(e) {
    if (t.debug.checkShaderErrors) {
      var _n91 = r.getProgramInfoLog(x).trim(),
        _i77 = r.getShaderInfoLog(T).trim(),
        _s30 = r.getShaderInfoLog(w).trim();
      var _a21 = !0,
        _o14 = !0;
      if (!1 === r.getProgramParameter(x, r.LINK_STATUS)) {
        if (_a21 = !1, "function" == typeof t.debug.onShaderError) t.debug.onShaderError(r, x, T, w);else {
          var _t103 = ll(r, T, "vertex"),
            _i78 = ll(r, w, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + e.name + "\nMaterial Type: " + e.type + "\n\nProgram Info Log: " + _n91 + "\n" + _t103 + "\n" + _i78);
        }
      } else "" !== _n91 ? console.warn("THREE.WebGLProgram: Program Info Log:", _n91) : "" !== _i77 && "" !== _s30 || (_o14 = !1);
      _o14 && (e.diagnostics = {
        runnable: _a21,
        programLog: _n91,
        vertexShader: {
          log: _i77,
          prefix: y
        },
        fragmentShader: {
          log: _s30,
          prefix: M
        }
      });
    }
    r.deleteShader(T), r.deleteShader(w), R = new rl(r, x), C = function (t, e) {
      var n = {},
        i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
      for (var _r52 = 0; _r52 < i; _r52++) {
        var _i79 = t.getActiveAttrib(e, _r52),
          _s31 = _i79.name;
        var _a22 = 1;
        _i79.type === t.FLOAT_MAT2 && (_a22 = 2), _i79.type === t.FLOAT_MAT3 && (_a22 = 3), _i79.type === t.FLOAT_MAT4 && (_a22 = 4), n[_s31] = {
          type: _i79.type,
          location: t.getAttribLocation(e, _s31),
          locationSize: _a22
        };
      }
      return n;
    }(r, x);
  }
  var R, C;
  r.attachShader(x, T), r.attachShader(x, w), void 0 !== n.index0AttributeName ? r.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(x, 0, "position"), r.linkProgram(x), this.getUniforms = function () {
    return void 0 === R && A(this), R;
  }, this.getAttributes = function () {
    return void 0 === C && A(this), C;
  };
  var P = !1 === n.rendererExtensionParallelShaderCompile;
  return this.isReady = function () {
    return !1 === P && (P = r.getProgramParameter(x, al)), P;
  }, this.destroy = function () {
    i.releaseStatesOfProgram(this), r.deleteProgram(x), this.program = void 0;
  }, this.type = n.shaderType, this.name = n.shaderName, this.id = ol++, this.cacheKey = e, this.usedTimes = 1, this.program = x, this.vertexShader = T, this.fragmentShader = w, this;
}
var bl = 0;
var El = /*#__PURE__*/function () {
  function El() {
    _classCallCheck(this, El);
    this.shaderCache = new Map(), this.materialCache = new Map();
  }
  return _createClass(El, [{
    key: "update",
    value: function update(t) {
      var e = t.vertexShader,
        n = t.fragmentShader,
        i = this._getShaderStage(e),
        r = this._getShaderStage(n),
        s = this._getShaderCacheForMaterial(t);
      return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this;
    }
  }, {
    key: "remove",
    value: function remove(t) {
      var e = this.materialCache.get(t);
      var _iterator3 = _createForOfIteratorHelper(e),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _t104 = _step3.value;
          _t104.usedTimes--, 0 === _t104.usedTimes && this.shaderCache.delete(_t104.code);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return this.materialCache.delete(t), this;
    }
  }, {
    key: "getVertexShaderID",
    value: function getVertexShaderID(t) {
      return this._getShaderStage(t.vertexShader).id;
    }
  }, {
    key: "getFragmentShaderID",
    value: function getFragmentShaderID(t) {
      return this._getShaderStage(t.fragmentShader).id;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
  }, {
    key: "_getShaderCacheForMaterial",
    value: function _getShaderCacheForMaterial(t) {
      var e = this.materialCache;
      var n = e.get(t);
      return void 0 === n && (n = new Set(), e.set(t, n)), n;
    }
  }, {
    key: "_getShaderStage",
    value: function _getShaderStage(t) {
      var e = this.shaderCache;
      var n = e.get(t);
      return void 0 === n && (n = new Tl(t), e.set(t, n)), n;
    }
  }]);
}();
var Tl = /*#__PURE__*/_createClass(function Tl(t) {
  _classCallCheck(this, Tl);
  this.id = bl++, this.code = t, this.usedTimes = 0;
});
function wl(t, e, n, i, r, s, a) {
  var o = new xr(),
    l = new El(),
    c = new Set(),
    h = [],
    u = r.isWebGL2,
    p = r.logarithmicDepthBuffer,
    m = r.vertexTextures;
  var f = r.precision;
  var g = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function _(t) {
    return c.add(t), 0 === t ? "uv" : "uv".concat(t);
  }
  return {
    getParameters: function getParameters(s, o, h, v, x) {
      var y = v.fog,
        M = x.geometry,
        S = s.isMeshStandardMaterial ? v.environment : null,
        b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || S),
        E = b && b.mapping === ut ? b.image.height : null,
        T = g[s.type];
      null !== s.precision && (f = r.getMaxPrecision(s.precision), f !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", f, "instead."));
      var w = M.morphAttributes.position || M.morphAttributes.normal || M.morphAttributes.color,
        A = void 0 !== w ? w.length : 0;
      var R,
        C,
        P,
        L,
        I = 0;
      if (void 0 !== M.morphAttributes.position && (I = 1), void 0 !== M.morphAttributes.normal && (I = 2), void 0 !== M.morphAttributes.color && (I = 3), T) {
        var _t105 = va[T];
        R = _t105.vertexShader, C = _t105.fragmentShader;
      } else R = s.vertexShader, C = s.fragmentShader, l.update(s), P = l.getVertexShaderID(s), L = l.getFragmentShaderID(s);
      var U = t.getRenderTarget(),
        N = !0 === x.isInstancedMesh,
        D = !0 === x.isBatchedMesh,
        O = !!s.map,
        F = !!s.matcap,
        B = !!b,
        z = !!s.aoMap,
        H = !!s.lightMap,
        V = !!s.bumpMap,
        k = !!s.normalMap,
        G = !!s.displacementMap,
        W = !!s.emissiveMap,
        X = !!s.metalnessMap,
        j = !!s.roughnessMap,
        q = s.anisotropy > 0,
        Y = s.clearcoat > 0,
        Z = s.iridescence > 0,
        J = s.sheen > 0,
        $ = s.transmission > 0,
        Q = q && !!s.anisotropyMap,
        tt = Y && !!s.clearcoatMap,
        et = Y && !!s.clearcoatNormalMap,
        nt = Y && !!s.clearcoatRoughnessMap,
        it = Z && !!s.iridescenceMap,
        rt = Z && !!s.iridescenceThicknessMap,
        st = J && !!s.sheenColorMap,
        at = J && !!s.sheenRoughnessMap,
        ot = !!s.specularMap,
        lt = !!s.specularColorMap,
        ct = !!s.specularIntensityMap,
        ht = $ && !!s.transmissionMap,
        dt = $ && !!s.thicknessMap,
        pt = !!s.gradientMap,
        mt = !!s.alphaMap,
        ft = s.alphaTest > 0,
        gt = !!s.alphaHash,
        _t = !!s.extensions;
      var vt = K;
      s.toneMapped && (null !== U && !0 !== U.isXRRenderTarget || (vt = t.toneMapping));
      var xt = {
        isWebGL2: u,
        shaderID: T,
        shaderType: s.type,
        shaderName: s.name,
        vertexShader: R,
        fragmentShader: C,
        defines: s.defines,
        customVertexShaderID: P,
        customFragmentShaderID: L,
        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
        glslVersion: s.glslVersion,
        precision: f,
        batching: D,
        instancing: N,
        instancingColor: N && null !== x.instanceColor,
        supportsVertexTextures: m,
        outputColorSpace: null === U ? t.outputColorSpace : !0 === U.isXRRenderTarget ? U.texture.colorSpace : qe,
        alphaToCoverage: !!s.alphaToCoverage,
        map: O,
        matcap: F,
        envMap: B,
        envMapMode: B && b.mapping,
        envMapCubeUVHeight: E,
        aoMap: z,
        lightMap: H,
        bumpMap: V,
        normalMap: k,
        displacementMap: m && G,
        emissiveMap: W,
        normalMapObjectSpace: k && 1 === s.normalMapType,
        normalMapTangentSpace: k && 0 === s.normalMapType,
        metalnessMap: X,
        roughnessMap: j,
        anisotropy: q,
        anisotropyMap: Q,
        clearcoat: Y,
        clearcoatMap: tt,
        clearcoatNormalMap: et,
        clearcoatRoughnessMap: nt,
        iridescence: Z,
        iridescenceMap: it,
        iridescenceThicknessMap: rt,
        sheen: J,
        sheenColorMap: st,
        sheenRoughnessMap: at,
        specularMap: ot,
        specularColorMap: lt,
        specularIntensityMap: ct,
        transmission: $,
        transmissionMap: ht,
        thicknessMap: dt,
        gradientMap: pt,
        opaque: !1 === s.transparent && 1 === s.blending && !1 === s.alphaToCoverage,
        alphaMap: mt,
        alphaTest: ft,
        alphaHash: gt,
        combine: s.combine,
        mapUv: O && _(s.map.channel),
        aoMapUv: z && _(s.aoMap.channel),
        lightMapUv: H && _(s.lightMap.channel),
        bumpMapUv: V && _(s.bumpMap.channel),
        normalMapUv: k && _(s.normalMap.channel),
        displacementMapUv: G && _(s.displacementMap.channel),
        emissiveMapUv: W && _(s.emissiveMap.channel),
        metalnessMapUv: X && _(s.metalnessMap.channel),
        roughnessMapUv: j && _(s.roughnessMap.channel),
        anisotropyMapUv: Q && _(s.anisotropyMap.channel),
        clearcoatMapUv: tt && _(s.clearcoatMap.channel),
        clearcoatNormalMapUv: et && _(s.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: nt && _(s.clearcoatRoughnessMap.channel),
        iridescenceMapUv: it && _(s.iridescenceMap.channel),
        iridescenceThicknessMapUv: rt && _(s.iridescenceThicknessMap.channel),
        sheenColorMapUv: st && _(s.sheenColorMap.channel),
        sheenRoughnessMapUv: at && _(s.sheenRoughnessMap.channel),
        specularMapUv: ot && _(s.specularMap.channel),
        specularColorMapUv: lt && _(s.specularColorMap.channel),
        specularIntensityMapUv: ct && _(s.specularIntensityMap.channel),
        transmissionMapUv: ht && _(s.transmissionMap.channel),
        thicknessMapUv: dt && _(s.thicknessMap.channel),
        alphaMapUv: mt && _(s.alphaMap.channel),
        vertexTangents: !!M.attributes.tangent && (k || q),
        vertexColors: s.vertexColors,
        vertexAlphas: !0 === s.vertexColors && !!M.attributes.color && 4 === M.attributes.color.itemSize,
        pointsUvs: !0 === x.isPoints && !!M.attributes.uv && (O || mt),
        fog: !!y,
        useFog: !0 === s.fog,
        fogExp2: !!y && y.isFogExp2,
        flatShading: !0 === s.flatShading,
        sizeAttenuation: !0 === s.sizeAttenuation,
        logarithmicDepthBuffer: p,
        skinning: !0 === x.isSkinnedMesh,
        morphTargets: void 0 !== M.morphAttributes.position,
        morphNormals: void 0 !== M.morphAttributes.normal,
        morphColors: void 0 !== M.morphAttributes.color,
        morphTargetsCount: A,
        morphTextureStride: I,
        numDirLights: o.directional.length,
        numPointLights: o.point.length,
        numSpotLights: o.spot.length,
        numSpotLightMaps: o.spotLightMap.length,
        numRectAreaLights: o.rectArea.length,
        numHemiLights: o.hemi.length,
        numDirLightShadows: o.directionalShadowMap.length,
        numPointLightShadows: o.pointShadowMap.length,
        numSpotLightShadows: o.spotShadowMap.length,
        numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
        numLightProbes: o.numLightProbes,
        numClippingPlanes: a.numPlanes,
        numClipIntersection: a.numIntersection,
        dithering: s.dithering,
        shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
        shadowMapType: t.shadowMap.type,
        toneMapping: vt,
        useLegacyLights: t._useLegacyLights,
        decodeVideoTexture: O && !0 === s.map.isVideoTexture && pi.getTransfer(s.map.colorSpace) === Ke,
        premultipliedAlpha: s.premultipliedAlpha,
        doubleSided: 2 === s.side,
        flipSided: s.side === d,
        useDepthPacking: s.depthPacking >= 0,
        depthPacking: s.depthPacking || 0,
        index0AttributeName: s.index0AttributeName,
        extensionDerivatives: _t && !0 === s.extensions.derivatives,
        extensionFragDepth: _t && !0 === s.extensions.fragDepth,
        extensionDrawBuffers: _t && !0 === s.extensions.drawBuffers,
        extensionShaderTextureLOD: _t && !0 === s.extensions.shaderTextureLOD,
        extensionClipCullDistance: _t && !0 === s.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
        extensionMultiDraw: _t && !0 === s.extensions.multiDraw && i.has("WEBGL_multi_draw"),
        rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
        rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
        customProgramCacheKey: s.customProgramCacheKey()
      };
      return xt.vertexUv1s = c.has(1), xt.vertexUv2s = c.has(2), xt.vertexUv3s = c.has(3), c.clear(), xt;
    },
    getProgramCacheKey: function getProgramCacheKey(e) {
      var n = [];
      if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines) for (var _t106 in e.defines) n.push(_t106), n.push(e.defines[_t106]);
      return !1 === e.isRawShaderMaterial && (!function (t, e) {
        t.push(e.precision), t.push(e.outputColorSpace), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.mapUv), t.push(e.alphaMapUv), t.push(e.lightMapUv), t.push(e.aoMapUv), t.push(e.bumpMapUv), t.push(e.normalMapUv), t.push(e.displacementMapUv), t.push(e.emissiveMapUv), t.push(e.metalnessMapUv), t.push(e.roughnessMapUv), t.push(e.anisotropyMapUv), t.push(e.clearcoatMapUv), t.push(e.clearcoatNormalMapUv), t.push(e.clearcoatRoughnessMapUv), t.push(e.iridescenceMapUv), t.push(e.iridescenceThicknessMapUv), t.push(e.sheenColorMapUv), t.push(e.sheenRoughnessMapUv), t.push(e.specularMapUv), t.push(e.specularColorMapUv), t.push(e.specularIntensityMapUv), t.push(e.transmissionMapUv), t.push(e.thicknessMapUv), t.push(e.combine), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.numLightProbes), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking);
      }(n, e), function (t, e) {
        o.disableAll(), e.isWebGL2 && o.enable(0);
        e.supportsVertexTextures && o.enable(1);
        e.instancing && o.enable(2);
        e.instancingColor && o.enable(3);
        e.matcap && o.enable(4);
        e.envMap && o.enable(5);
        e.normalMapObjectSpace && o.enable(6);
        e.normalMapTangentSpace && o.enable(7);
        e.clearcoat && o.enable(8);
        e.iridescence && o.enable(9);
        e.alphaTest && o.enable(10);
        e.vertexColors && o.enable(11);
        e.vertexAlphas && o.enable(12);
        e.vertexUv1s && o.enable(13);
        e.vertexUv2s && o.enable(14);
        e.vertexUv3s && o.enable(15);
        e.vertexTangents && o.enable(16);
        e.anisotropy && o.enable(17);
        e.alphaHash && o.enable(18);
        e.batching && o.enable(19);
        t.push(o.mask), o.disableAll(), e.fog && o.enable(0);
        e.useFog && o.enable(1);
        e.flatShading && o.enable(2);
        e.logarithmicDepthBuffer && o.enable(3);
        e.skinning && o.enable(4);
        e.morphTargets && o.enable(5);
        e.morphNormals && o.enable(6);
        e.morphColors && o.enable(7);
        e.premultipliedAlpha && o.enable(8);
        e.shadowMapEnabled && o.enable(9);
        e.useLegacyLights && o.enable(10);
        e.doubleSided && o.enable(11);
        e.flipSided && o.enable(12);
        e.useDepthPacking && o.enable(13);
        e.dithering && o.enable(14);
        e.transmission && o.enable(15);
        e.sheen && o.enable(16);
        e.opaque && o.enable(17);
        e.pointsUvs && o.enable(18);
        e.decodeVideoTexture && o.enable(19);
        e.alphaToCoverage && o.enable(20);
        t.push(o.mask);
      }(n, e), n.push(t.outputColorSpace)), n.push(e.customProgramCacheKey), n.join();
    },
    getUniforms: function getUniforms(t) {
      var e = g[t.type];
      var n;
      if (e) {
        var _t107 = va[e];
        n = Zs.clone(_t107.uniforms);
      } else n = t.uniforms;
      return n;
    },
    acquireProgram: function acquireProgram(e, n) {
      var i;
      for (var _t108 = 0, _e78 = h.length; _t108 < _e78; _t108++) {
        var _e79 = h[_t108];
        if (_e79.cacheKey === n) {
          i = _e79, ++i.usedTimes;
          break;
        }
      }
      return void 0 === i && (i = new Sl(t, n, e, s), h.push(i)), i;
    },
    releaseProgram: function releaseProgram(t) {
      if (0 == --t.usedTimes) {
        var _e80 = h.indexOf(t);
        h[_e80] = h[h.length - 1], h.pop(), t.destroy();
      }
    },
    releaseShaderCache: function releaseShaderCache(t) {
      l.remove(t);
    },
    programs: h,
    dispose: function dispose() {
      l.dispose();
    }
  };
}
function Al() {
  var t = new WeakMap();
  return {
    get: function get(e) {
      var n = t.get(e);
      return void 0 === n && (n = {}, t.set(e, n)), n;
    },
    remove: function remove(e) {
      t.delete(e);
    },
    update: function update(e, n, i) {
      t.get(e)[n] = i;
    },
    dispose: function dispose() {
      t = new WeakMap();
    }
  };
}
function Rl(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
}
function Cl(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
}
function Pl() {
  var t = [];
  var e = 0;
  var n = [],
    i = [],
    r = [];
  function s(n, i, r, s, a, o) {
    var l = t[e];
    return void 0 === l ? (l = {
      id: n.id,
      object: n,
      geometry: i,
      material: r,
      groupOrder: s,
      renderOrder: n.renderOrder,
      z: a,
      group: o
    }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = o), e++, l;
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: r,
    init: function init() {
      e = 0, n.length = 0, i.length = 0, r.length = 0;
    },
    push: function push(t, e, a, o, l, c) {
      var h = s(t, e, a, o, l, c);
      a.transmission > 0 ? i.push(h) : !0 === a.transparent ? r.push(h) : n.push(h);
    },
    unshift: function unshift(t, e, a, o, l, c) {
      var h = s(t, e, a, o, l, c);
      a.transmission > 0 ? i.unshift(h) : !0 === a.transparent ? r.unshift(h) : n.unshift(h);
    },
    finish: function finish() {
      for (var _n92 = e, _i80 = t.length; _n92 < _i80; _n92++) {
        var _e81 = t[_n92];
        if (null === _e81.id) break;
        _e81.id = null, _e81.object = null, _e81.geometry = null, _e81.material = null, _e81.group = null;
      }
    },
    sort: function sort(t, e) {
      n.length > 1 && n.sort(t || Rl), i.length > 1 && i.sort(e || Cl), r.length > 1 && r.sort(e || Cl);
    }
  };
}
function Ll() {
  var t = new WeakMap();
  return {
    get: function get(e, n) {
      var i = t.get(e);
      var r;
      return void 0 === i ? (r = new Pl(), t.set(e, [r])) : n >= i.length ? (r = new Pl(), i.push(r)) : r = i[n], r;
    },
    dispose: function dispose() {
      t = new WeakMap();
    }
  };
}
function Il() {
  var t = {};
  return {
    get: function get(e) {
      if (void 0 !== t[e.id]) return t[e.id];
      var n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new Ii(),
            color: new Zr()
          };
          break;
        case "SpotLight":
          n = {
            position: new Ii(),
            direction: new Ii(),
            color: new Zr(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new Ii(),
            color: new Zr(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new Ii(),
            skyColor: new Zr(),
            groundColor: new Zr()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new Zr(),
            position: new Ii(),
            halfWidth: new Ii(),
            halfHeight: new Ii()
          };
      }
      return t[e.id] = n, n;
    }
  };
}
var Ul = 0;
function Nl(t, e) {
  return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0);
}
function Dl(t, e) {
  var n = new Il(),
    i = function () {
      var t = {};
      return {
        get: function get(e) {
          if (void 0 !== t[e.id]) return t[e.id];
          var n;
          switch (e.type) {
            case "DirectionalLight":
            case "SpotLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Qn()
              };
              break;
            case "PointLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Qn(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3
              };
          }
          return t[e.id] = n, n;
        }
      };
    }(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0
    };
  for (var _t109 = 0; _t109 < 9; _t109++) r.probe.push(new Ii());
  var s = new Ii(),
    a = new lr(),
    o = new lr();
  return {
    setup: function setup(s, a) {
      var o = 0,
        l = 0,
        c = 0;
      for (var _t110 = 0; _t110 < 9; _t110++) r.probe[_t110].set(0, 0, 0);
      var h = 0,
        u = 0,
        d = 0,
        p = 0,
        m = 0,
        f = 0,
        g = 0,
        _ = 0,
        v = 0,
        x = 0,
        y = 0;
      s.sort(Nl);
      var M = !0 === a ? Math.PI : 1;
      for (var _t111 = 0, _e82 = s.length; _t111 < _e82; _t111++) {
        var _e83 = s[_t111],
          _a23 = _e83.color,
          _S2 = _e83.intensity,
          _b2 = _e83.distance,
          _E2 = _e83.shadow && _e83.shadow.map ? _e83.shadow.map.texture : null;
        if (_e83.isAmbientLight) o += _a23.r * _S2 * M, l += _a23.g * _S2 * M, c += _a23.b * _S2 * M;else if (_e83.isLightProbe) {
          for (var _t112 = 0; _t112 < 9; _t112++) r.probe[_t112].addScaledVector(_e83.sh.coefficients[_t112], _S2);
          y++;
        } else if (_e83.isDirectionalLight) {
          var _t113 = n.get(_e83);
          if (_t113.color.copy(_e83.color).multiplyScalar(_e83.intensity * M), _e83.castShadow) {
            var _t114 = _e83.shadow,
              _n93 = i.get(_e83);
            _n93.shadowBias = _t114.bias, _n93.shadowNormalBias = _t114.normalBias, _n93.shadowRadius = _t114.radius, _n93.shadowMapSize = _t114.mapSize, r.directionalShadow[h] = _n93, r.directionalShadowMap[h] = _E2, r.directionalShadowMatrix[h] = _e83.shadow.matrix, f++;
          }
          r.directional[h] = _t113, h++;
        } else if (_e83.isSpotLight) {
          var _t115 = n.get(_e83);
          _t115.position.setFromMatrixPosition(_e83.matrixWorld), _t115.color.copy(_a23).multiplyScalar(_S2 * M), _t115.distance = _b2, _t115.coneCos = Math.cos(_e83.angle), _t115.penumbraCos = Math.cos(_e83.angle * (1 - _e83.penumbra)), _t115.decay = _e83.decay, r.spot[d] = _t115;
          var _s32 = _e83.shadow;
          if (_e83.map && (r.spotLightMap[v] = _e83.map, v++, _s32.updateMatrices(_e83), _e83.castShadow && x++), r.spotLightMatrix[d] = _s32.matrix, _e83.castShadow) {
            var _t116 = i.get(_e83);
            _t116.shadowBias = _s32.bias, _t116.shadowNormalBias = _s32.normalBias, _t116.shadowRadius = _s32.radius, _t116.shadowMapSize = _s32.mapSize, r.spotShadow[d] = _t116, r.spotShadowMap[d] = _E2, _++;
          }
          d++;
        } else if (_e83.isRectAreaLight) {
          var _t117 = n.get(_e83);
          _t117.color.copy(_a23).multiplyScalar(_S2), _t117.halfWidth.set(.5 * _e83.width, 0, 0), _t117.halfHeight.set(0, .5 * _e83.height, 0), r.rectArea[p] = _t117, p++;
        } else if (_e83.isPointLight) {
          var _t118 = n.get(_e83);
          if (_t118.color.copy(_e83.color).multiplyScalar(_e83.intensity * M), _t118.distance = _e83.distance, _t118.decay = _e83.decay, _e83.castShadow) {
            var _t119 = _e83.shadow,
              _n94 = i.get(_e83);
            _n94.shadowBias = _t119.bias, _n94.shadowNormalBias = _t119.normalBias, _n94.shadowRadius = _t119.radius, _n94.shadowMapSize = _t119.mapSize, _n94.shadowCameraNear = _t119.camera.near, _n94.shadowCameraFar = _t119.camera.far, r.pointShadow[u] = _n94, r.pointShadowMap[u] = _E2, r.pointShadowMatrix[u] = _e83.shadow.matrix, g++;
          }
          r.point[u] = _t118, u++;
        } else if (_e83.isHemisphereLight) {
          var _t120 = n.get(_e83);
          _t120.skyColor.copy(_e83.color).multiplyScalar(_S2 * M), _t120.groundColor.copy(_e83.groundColor).multiplyScalar(_S2 * M), r.hemi[m] = _t120, m++;
        }
      }
      p > 0 && (e.isWebGL2 ? !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = _a.LTC_FLOAT_1, r.rectAreaLTC2 = _a.LTC_FLOAT_2) : (r.rectAreaLTC1 = _a.LTC_HALF_1, r.rectAreaLTC2 = _a.LTC_HALF_2) : !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = _a.LTC_FLOAT_1, r.rectAreaLTC2 = _a.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = _a.LTC_HALF_1, r.rectAreaLTC2 = _a.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
      var S = r.hash;
      S.directionalLength === h && S.pointLength === u && S.spotLength === d && S.rectAreaLength === p && S.hemiLength === m && S.numDirectionalShadows === f && S.numPointShadows === g && S.numSpotShadows === _ && S.numSpotMaps === v && S.numLightProbes === y || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = _, r.spotShadowMap.length = _, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotLightMatrix.length = _ + v - x, r.spotLightMap.length = v, r.numSpotLightShadowsWithMaps = x, r.numLightProbes = y, S.directionalLength = h, S.pointLength = u, S.spotLength = d, S.rectAreaLength = p, S.hemiLength = m, S.numDirectionalShadows = f, S.numPointShadows = g, S.numSpotShadows = _, S.numSpotMaps = v, S.numLightProbes = y, r.version = Ul++);
    },
    setupView: function setupView(t, e) {
      var n = 0,
        i = 0,
        l = 0,
        c = 0,
        h = 0;
      var u = e.matrixWorldInverse;
      for (var _e84 = 0, _d7 = t.length; _e84 < _d7; _e84++) {
        var _d8 = t[_e84];
        if (_d8.isDirectionalLight) {
          var _t121 = r.directional[n];
          _t121.direction.setFromMatrixPosition(_d8.matrixWorld), s.setFromMatrixPosition(_d8.target.matrixWorld), _t121.direction.sub(s), _t121.direction.transformDirection(u), n++;
        } else if (_d8.isSpotLight) {
          var _t122 = r.spot[l];
          _t122.position.setFromMatrixPosition(_d8.matrixWorld), _t122.position.applyMatrix4(u), _t122.direction.setFromMatrixPosition(_d8.matrixWorld), s.setFromMatrixPosition(_d8.target.matrixWorld), _t122.direction.sub(s), _t122.direction.transformDirection(u), l++;
        } else if (_d8.isRectAreaLight) {
          var _t123 = r.rectArea[c];
          _t123.position.setFromMatrixPosition(_d8.matrixWorld), _t123.position.applyMatrix4(u), o.identity(), a.copy(_d8.matrixWorld), a.premultiply(u), o.extractRotation(a), _t123.halfWidth.set(.5 * _d8.width, 0, 0), _t123.halfHeight.set(0, .5 * _d8.height, 0), _t123.halfWidth.applyMatrix4(o), _t123.halfHeight.applyMatrix4(o), c++;
        } else if (_d8.isPointLight) {
          var _t124 = r.point[i];
          _t124.position.setFromMatrixPosition(_d8.matrixWorld), _t124.position.applyMatrix4(u), i++;
        } else if (_d8.isHemisphereLight) {
          var _t125 = r.hemi[h];
          _t125.direction.setFromMatrixPosition(_d8.matrixWorld), _t125.direction.transformDirection(u), h++;
        }
      }
    },
    state: r
  };
}
function Ol(t, e) {
  var n = new Dl(t, e),
    i = [],
    r = [];
  return {
    init: function init() {
      i.length = 0, r.length = 0;
    },
    state: {
      lightsArray: i,
      shadowsArray: r,
      lights: n
    },
    setupLights: function setupLights(t) {
      n.setup(i, t);
    },
    setupLightsView: function setupLightsView(t) {
      n.setupView(i, t);
    },
    pushLight: function pushLight(t) {
      i.push(t);
    },
    pushShadow: function pushShadow(t) {
      r.push(t);
    }
  };
}
function Fl(t, e) {
  var n = new WeakMap();
  return {
    get: function get(i) {
      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s = n.get(i);
      var a;
      return void 0 === s ? (a = new Ol(t, e), n.set(i, [a])) : r >= s.length ? (a = new Ol(t, e), s.push(a)) : a = s[r], a;
    },
    dispose: function dispose() {
      n = new WeakMap();
    }
  };
}
var Bl = exports.MeshDepthMaterial = /*#__PURE__*/function (_$r3) {
  function Bl(t) {
    var _this25;
    _classCallCheck(this, Bl);
    _this25 = _callSuper(this, Bl), _this25.isMeshDepthMaterial = !0, _this25.type = "MeshDepthMaterial", _this25.depthPacking = 3200, _this25.map = null, _this25.alphaMap = null, _this25.displacementMap = null, _this25.displacementScale = 1, _this25.displacementBias = 0, _this25.wireframe = !1, _this25.wireframeLinewidth = 1, _this25.setValues(t);
    return _this25;
  }
  _inherits(Bl, _$r3);
  return _createClass(Bl, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Bl.prototype), "copy", this).call(this, t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
    }
  }]);
}($r);
var zl = exports.MeshDistanceMaterial = /*#__PURE__*/function (_$r4) {
  function zl(t) {
    var _this26;
    _classCallCheck(this, zl);
    _this26 = _callSuper(this, zl), _this26.isMeshDistanceMaterial = !0, _this26.type = "MeshDistanceMaterial", _this26.map = null, _this26.alphaMap = null, _this26.displacementMap = null, _this26.displacementScale = 1, _this26.displacementBias = 0, _this26.setValues(t);
    return _this26;
  }
  _inherits(zl, _$r4);
  return _createClass(zl, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(zl.prototype), "copy", this).call(this, t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
    }
  }]);
}($r);
function Hl(t, e, n) {
  var i = new da();
  var r = new Qn(),
    s = new Qn(),
    a = new bi(),
    o = new Bl({
      depthPacking: 3201
    }),
    c = new zl(),
    p = {},
    m = n.maxTextureSize,
    f = _defineProperty(_defineProperty(_defineProperty({}, u, d), d, u), 2, 2),
    g = new Js({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: {
          value: null
        },
        resolution: {
          value: new Qn()
        },
        radius: {
          value: 4
        }
      },
      vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
      fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
    }),
    _ = g.clone();
  _.defines.HORIZONTAL_PASS = 1;
  var v = new Ts();
  v.setAttribute("position", new os(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
  var x = new Gs(v, g),
    y = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = l;
  var M = this.type;
  function S(n, i) {
    var s = e.update(x);
    g.defines.VSM_SAMPLES !== n.blurSamples && (g.defines.VSM_SAMPLES = n.blurSamples, _.defines.VSM_SAMPLES = n.blurSamples, g.needsUpdate = !0, _.needsUpdate = !0), null === n.mapPass && (n.mapPass = new Ti(r.x, r.y)), g.uniforms.shadow_pass.value = n.map.texture, g.uniforms.resolution.value = n.mapSize, g.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, s, g, x, null), _.uniforms.shadow_pass.value = n.mapPass.texture, _.uniforms.resolution.value = n.mapSize, _.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, s, _, x, null);
  }
  function b(e, n, i, r) {
    var s = null;
    var a = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
    if (void 0 !== a) s = a;else if (s = !0 === i.isPointLight ? c : o, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
      var _t126 = s.uuid,
        _e85 = n.uuid;
      var _i81 = p[_t126];
      void 0 === _i81 && (_i81 = {}, p[_t126] = _i81);
      var _r53 = _i81[_e85];
      void 0 === _r53 && (_r53 = s.clone(), _i81[_e85] = _r53, n.addEventListener("dispose", T)), s = _r53;
    }
    if (s.visible = n.visible, s.wireframe = n.wireframe, s.side = r === h ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : f[n.side], s.alphaMap = n.alphaMap, s.alphaTest = n.alphaTest, s.map = n.map, s.clipShadows = n.clipShadows, s.clippingPlanes = n.clippingPlanes, s.clipIntersection = n.clipIntersection, s.displacementMap = n.displacementMap, s.displacementScale = n.displacementScale, s.displacementBias = n.displacementBias, s.wireframeLinewidth = n.wireframeLinewidth, s.linewidth = n.linewidth, !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial) {
      t.properties.get(s).light = i;
    }
    return s;
  }
  function E(n, r, s, a, o) {
    if (!1 === n.visible) return;
    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === h) && (!n.frustumCulled || i.intersectsObject(n))) {
      n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
      var _i82 = e.update(n),
        _l10 = n.material;
      if (Array.isArray(_l10)) {
        var _e86 = _i82.groups;
        for (var _c9 = 0, _h6 = _e86.length; _c9 < _h6; _c9++) {
          var _h7 = _e86[_c9],
            _u6 = _l10[_h7.materialIndex];
          if (_u6 && _u6.visible) {
            var _e87 = b(n, _u6, a, o);
            n.onBeforeShadow(t, n, r, s, _i82, _e87, _h7), t.renderBufferDirect(s, null, _i82, _e87, n, _h7), n.onAfterShadow(t, n, r, s, _i82, _e87, _h7);
          }
        }
      } else if (_l10.visible) {
        var _e88 = b(n, _l10, a, o);
        n.onBeforeShadow(t, n, r, s, _i82, _e88, null), t.renderBufferDirect(s, null, _i82, _e88, n, null), n.onAfterShadow(t, n, r, s, _i82, _e88, null);
      }
    }
    var l = n.children;
    for (var _t127 = 0, _e89 = l.length; _t127 < _e89; _t127++) E(l[_t127], r, s, a, o);
  }
  function T(t) {
    t.target.removeEventListener("dispose", T);
    for (var _e90 in p) {
      var _n95 = p[_e90],
        _i83 = t.target.uuid;
      if (_i83 in _n95) {
        _n95[_i83].dispose(), delete _n95[_i83];
      }
    }
  }
  this.render = function (e, n, o) {
    if (!1 === y.enabled) return;
    if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
    if (0 === e.length) return;
    var l = t.getRenderTarget(),
      c = t.getActiveCubeFace(),
      u = t.getActiveMipmapLevel(),
      d = t.state;
    d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
    var p = M !== h && this.type === h,
      f = M === h && this.type !== h;
    for (var _l11 = 0, _c10 = e.length; _l11 < _c10; _l11++) {
      var _c11 = e[_l11],
        _u7 = _c11.shadow;
      if (void 0 === _u7) {
        console.warn("THREE.WebGLShadowMap:", _c11, "has no shadow.");
        continue;
      }
      if (!1 === _u7.autoUpdate && !1 === _u7.needsUpdate) continue;
      r.copy(_u7.mapSize);
      var _g3 = _u7.getFrameExtents();
      if (r.multiply(_g3), s.copy(_u7.mapSize), (r.x > m || r.y > m) && (r.x > m && (s.x = Math.floor(m / _g3.x), r.x = s.x * _g3.x, _u7.mapSize.x = s.x), r.y > m && (s.y = Math.floor(m / _g3.y), r.y = s.y * _g3.y, _u7.mapSize.y = s.y)), null === _u7.map || !0 === p || !0 === f) {
        var _t128 = this.type !== h ? {
          minFilter: ft,
          magFilter: ft
        } : {};
        null !== _u7.map && _u7.map.dispose(), _u7.map = new Ti(r.x, r.y, _t128), _u7.map.texture.name = _c11.name + ".shadowMap", _u7.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(_u7.map), t.clear();
      var _5 = _u7.getViewportCount();
      for (var _t129 = 0; _t129 < _5; _t129++) {
        var _e91 = _u7.getViewport(_t129);
        a.set(s.x * _e91.x, s.y * _e91.y, s.x * _e91.z, s.y * _e91.w), d.viewport(a), _u7.updateMatrices(_c11, _t129), i = _u7.getFrustum(), E(n, o, _u7.camera, _c11, this.type);
      }
      !0 !== _u7.isPointLightShadow && this.type === h && S(_u7, o), _u7.needsUpdate = !1;
    }
    M = this.type, y.needsUpdate = !1, t.setRenderTarget(l, c, u);
  };
}
function Vl(t, e, n) {
  var _Z2;
  var i = n.isWebGL2;
  var r = new function () {
      var e = !1;
      var n = new bi();
      var i = null;
      var r = new bi(0, 0, 0, 0);
      return {
        setMask: function setMask(n) {
          i === n || e || (t.colorMask(n, n, n, n), i = n);
        },
        setLocked: function setLocked(t) {
          e = t;
        },
        setClear: function setClear(e, i, s, a, o) {
          !0 === o && (e *= a, i *= a, s *= a), n.set(e, i, s, a), !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
        },
        reset: function reset() {
          e = !1, i = null, r.set(-1, 0, 0, 0);
        }
      };
    }(),
    s = new function () {
      var e = !1,
        n = null,
        i = null,
        r = null;
      return {
        setTest: function setTest(e) {
          e ? j(t.DEPTH_TEST) : q(t.DEPTH_TEST);
        },
        setMask: function setMask(i) {
          n === i || e || (t.depthMask(i), n = i);
        },
        setFunc: function setFunc(e) {
          if (i !== e) {
            switch (e) {
              case 0:
                t.depthFunc(t.NEVER);
                break;
              case 1:
                t.depthFunc(t.ALWAYS);
                break;
              case 2:
                t.depthFunc(t.LESS);
                break;
              case 3:
              default:
                t.depthFunc(t.LEQUAL);
                break;
              case 4:
                t.depthFunc(t.EQUAL);
                break;
              case 5:
                t.depthFunc(t.GEQUAL);
                break;
              case 6:
                t.depthFunc(t.GREATER);
                break;
              case 7:
                t.depthFunc(t.NOTEQUAL);
            }
            i = e;
          }
        },
        setLocked: function setLocked(t) {
          e = t;
        },
        setClear: function setClear(e) {
          r !== e && (t.clearDepth(e), r = e);
        },
        reset: function reset() {
          e = !1, n = null, i = null, r = null;
        }
      };
    }(),
    a = new function () {
      var e = !1,
        n = null,
        i = null,
        r = null,
        s = null,
        a = null,
        o = null,
        l = null,
        c = null;
      return {
        setTest: function setTest(n) {
          e || (n ? j(t.STENCIL_TEST) : q(t.STENCIL_TEST));
        },
        setMask: function setMask(i) {
          n === i || e || (t.stencilMask(i), n = i);
        },
        setFunc: function setFunc(e, n, a) {
          i === e && r === n && s === a || (t.stencilFunc(e, n, a), i = e, r = n, s = a);
        },
        setOp: function setOp(e, n, i) {
          a === e && o === n && l === i || (t.stencilOp(e, n, i), a = e, o = n, l = i);
        },
        setLocked: function setLocked(t) {
          e = t;
        },
        setClear: function setClear(e) {
          c !== e && (t.clearStencil(e), c = e);
        },
        reset: function reset() {
          e = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null;
        }
      };
    }(),
    o = new WeakMap(),
    l = new WeakMap();
  var c = {},
    h = {},
    u = new WeakMap(),
    p = [],
    m = null,
    f = !1,
    g = null,
    _ = null,
    v = null,
    x = null,
    M = null,
    S = null,
    b = null,
    E = new Zr(0, 0, 0),
    T = 0,
    w = !1,
    A = null,
    R = null,
    L = null,
    I = null,
    U = null;
  var N = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  var D = !1,
    O = 0;
  var F = t.getParameter(t.VERSION);
  -1 !== F.indexOf("WebGL") ? (O = parseFloat(/^WebGL (\d)/.exec(F)[1]), D = O >= 1) : -1 !== F.indexOf("OpenGL ES") && (O = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]), D = O >= 2);
  var B = null,
    z = {};
  var H = t.getParameter(t.SCISSOR_BOX),
    V = t.getParameter(t.VIEWPORT),
    k = new bi().fromArray(H),
    G = new bi().fromArray(V);
  function W(e, n, r, s) {
    var a = new Uint8Array(4),
      o = t.createTexture();
    t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
    for (var _o15 = 0; _o15 < r; _o15++) !i || e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY ? t.texImage2D(n + _o15, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, a) : t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, a);
    return o;
  }
  var X = {};
  function j(e) {
    !0 !== c[e] && (t.enable(e), c[e] = !0);
  }
  function q(e) {
    !1 !== c[e] && (t.disable(e), c[e] = !1);
  }
  X[t.TEXTURE_2D] = W(t.TEXTURE_2D, t.TEXTURE_2D, 1), X[t.TEXTURE_CUBE_MAP] = W(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (X[t.TEXTURE_2D_ARRAY] = W(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), X[t.TEXTURE_3D] = W(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), j(t.DEPTH_TEST), s.setFunc(3), K(!1), $(1), j(t.CULL_FACE), J(0);
  var Y = _defineProperty(_defineProperty(_defineProperty({}, y, t.FUNC_ADD), 101, t.FUNC_SUBTRACT), 102, t.FUNC_REVERSE_SUBTRACT);
  if (i) Y[103] = t.MIN, Y[104] = t.MAX;else {
    var _t130 = e.get("EXT_blend_minmax");
    null !== _t130 && (Y[103] = _t130.MIN_EXT, Y[104] = _t130.MAX_EXT);
  }
  var Z = (_Z2 = {
    200: t.ZERO,
    201: t.ONE,
    202: t.SRC_COLOR
  }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_Z2, C, t.SRC_ALPHA), 210, t.SRC_ALPHA_SATURATE), 208, t.DST_COLOR), 206, t.DST_ALPHA), 203, t.ONE_MINUS_SRC_COLOR), P, t.ONE_MINUS_SRC_ALPHA), 209, t.ONE_MINUS_DST_COLOR), 207, t.ONE_MINUS_DST_ALPHA), 211, t.CONSTANT_COLOR), 212, t.ONE_MINUS_CONSTANT_COLOR), _defineProperty(_defineProperty(_Z2, 213, t.CONSTANT_ALPHA), 214, t.ONE_MINUS_CONSTANT_ALPHA));
  function J(e, n, i, r, s, a, o, l, c, h) {
    if (0 !== e) {
      if (!1 === f && (j(t.BLEND), f = !0), 5 === e) s = s || n, a = a || i, o = o || r, n === _ && s === M || (t.blendEquationSeparate(Y[n], Y[s]), _ = n, M = s), i === v && r === x && a === S && o === b || (t.blendFuncSeparate(Z[i], Z[r], Z[a], Z[o]), v = i, x = r, S = a, b = o), !1 !== l.equals(E) && c === T || (t.blendColor(l.r, l.g, l.b, c), E.copy(l), T = c), g = e, w = !1;else if (e !== g || h !== w) {
        if (_ === y && M === y || (t.blendEquation(t.FUNC_ADD), _ = y, M = y), h) switch (e) {
          case 1:
            t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
            break;
          case 2:
            t.blendFunc(t.ONE, t.ONE);
            break;
          case 3:
            t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
            break;
          case 4:
            t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", e);
        } else switch (e) {
          case 1:
            t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
            break;
          case 2:
            t.blendFunc(t.SRC_ALPHA, t.ONE);
            break;
          case 3:
            t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
            break;
          case 4:
            t.blendFunc(t.ZERO, t.SRC_COLOR);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", e);
        }
        v = null, x = null, S = null, b = null, E.set(0, 0, 0), T = 0, g = e, w = h;
      }
    } else !0 === f && (q(t.BLEND), f = !1);
  }
  function K(e) {
    A !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), A = e);
  }
  function $(e) {
    0 !== e ? (j(t.CULL_FACE), e !== R && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : q(t.CULL_FACE), R = e;
  }
  function Q(e, n, i) {
    e ? (j(t.POLYGON_OFFSET_FILL), I === n && U === i || (t.polygonOffset(n, i), I = n, U = i)) : q(t.POLYGON_OFFSET_FILL);
  }
  return {
    buffers: {
      color: r,
      depth: s,
      stencil: a
    },
    enable: j,
    disable: q,
    bindFramebuffer: function bindFramebuffer(e, n) {
      return h[e] !== n && (t.bindFramebuffer(e, n), h[e] = n, i && (e === t.DRAW_FRAMEBUFFER && (h[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (h[t.DRAW_FRAMEBUFFER] = n)), !0);
    },
    drawBuffers: function drawBuffers(i, r) {
      var s = p,
        a = !1;
      if (i) {
        if (s = u.get(r), void 0 === s && (s = [], u.set(r, s)), i.isWebGLMultipleRenderTargets) {
          var _e92 = i.texture;
          if (s.length !== _e92.length || s[0] !== t.COLOR_ATTACHMENT0) {
            for (var _n96 = 0, _i84 = _e92.length; _n96 < _i84; _n96++) s[_n96] = t.COLOR_ATTACHMENT0 + _n96;
            s.length = _e92.length, a = !0;
          }
        } else s[0] !== t.COLOR_ATTACHMENT0 && (s[0] = t.COLOR_ATTACHMENT0, a = !0);
      } else s[0] !== t.BACK && (s[0] = t.BACK, a = !0);
      a && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
    },
    useProgram: function useProgram(e) {
      return m !== e && (t.useProgram(e), m = e, !0);
    },
    setBlending: J,
    setMaterial: function setMaterial(e, n) {
      2 === e.side ? q(t.CULL_FACE) : j(t.CULL_FACE);
      var i = e.side === d;
      n && (i = !i), K(i), 1 === e.blending && !1 === e.transparent ? J(0) : J(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.blendColor, e.blendAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), r.setMask(e.colorWrite);
      var o = e.stencilWrite;
      a.setTest(o), o && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? j(t.SAMPLE_ALPHA_TO_COVERAGE) : q(t.SAMPLE_ALPHA_TO_COVERAGE);
    },
    setFlipSided: K,
    setCullFace: $,
    setLineWidth: function setLineWidth(e) {
      e !== L && (D && t.lineWidth(e), L = e);
    },
    setPolygonOffset: Q,
    setScissorTest: function setScissorTest(e) {
      e ? j(t.SCISSOR_TEST) : q(t.SCISSOR_TEST);
    },
    activeTexture: function activeTexture(e) {
      void 0 === e && (e = t.TEXTURE0 + N - 1), B !== e && (t.activeTexture(e), B = e);
    },
    bindTexture: function bindTexture(e, n, i) {
      void 0 === i && (i = null === B ? t.TEXTURE0 + N - 1 : B);
      var r = z[i];
      void 0 === r && (r = {
        type: void 0,
        texture: void 0
      }, z[i] = r), r.type === e && r.texture === n || (B !== i && (t.activeTexture(i), B = i), t.bindTexture(e, n || X[e]), r.type = e, r.texture = n);
    },
    unbindTexture: function unbindTexture() {
      var e = z[B];
      void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0);
    },
    compressedTexImage2D: function compressedTexImage2D() {
      try {
        t.compressedTexImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    compressedTexImage3D: function compressedTexImage3D() {
      try {
        t.compressedTexImage3D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage2D: function texImage2D() {
      try {
        t.texImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage3D: function texImage3D() {
      try {
        t.texImage3D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    updateUBOMapping: function updateUBOMapping(e, n) {
      var i = l.get(n);
      void 0 === i && (i = new WeakMap(), l.set(n, i));
      var r = i.get(e);
      void 0 === r && (r = t.getUniformBlockIndex(n, e.name), i.set(e, r));
    },
    uniformBlockBinding: function uniformBlockBinding(e, n) {
      var i = l.get(n).get(e);
      o.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), o.set(n, i));
    },
    texStorage2D: function texStorage2D() {
      try {
        t.texStorage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texStorage3D: function texStorage3D() {
      try {
        t.texStorage3D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texSubImage2D: function texSubImage2D() {
      try {
        t.texSubImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texSubImage3D: function texSubImage3D() {
      try {
        t.texSubImage3D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    compressedTexSubImage2D: function compressedTexSubImage2D() {
      try {
        t.compressedTexSubImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    compressedTexSubImage3D: function compressedTexSubImage3D() {
      try {
        t.compressedTexSubImage3D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    scissor: function scissor(e) {
      !1 === k.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), k.copy(e));
    },
    viewport: function viewport(e) {
      !1 === G.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), G.copy(e));
    },
    reset: function reset() {
      t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.blendColor(0, 0, 0, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === i && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), c = {}, B = null, z = {}, h = {}, u = new WeakMap(), p = [], m = null, f = !1, g = null, _ = null, v = null, x = null, M = null, S = null, b = null, E = new Zr(0, 0, 0), T = 0, w = !1, A = null, R = null, L = null, I = null, U = null, k.set(0, 0, t.canvas.width, t.canvas.height), G.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), a.reset();
    }
  };
}
function kl(t, e, n, i, r, s, a) {
  var o = r.isWebGL2,
    l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
    c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
    h = new WeakMap();
  var u;
  var d = new WeakMap();
  var p = !1;
  try {
    p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (t) {}
  function m(t, e) {
    return p ? new OffscreenCanvas(t, e) : si("canvas");
  }
  function f(t, e, n, i) {
    var r = 1;
    if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
      if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
        var _i85 = e ? Zn : Math.floor,
          _s33 = _i85(r * t.width),
          _a24 = _i85(r * t.height);
        void 0 === u && (u = m(_s33, _a24));
        var _o16 = n ? m(_s33, _a24) : u;
        _o16.width = _s33, _o16.height = _a24;
        return _o16.getContext("2d").drawImage(t, 0, 0, _s33, _a24), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + _s33 + "x" + _a24 + ")."), _o16;
      }
      return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t;
    }
    return t;
  }
  function g(t) {
    return Yn(t.width) && Yn(t.height);
  }
  function _(t, e) {
    return t.generateMipmaps && e && t.minFilter !== ft && t.minFilter !== yt;
  }
  function v(e) {
    t.generateMipmap(e);
  }
  function x(n, i, r, s) {
    var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    if (!1 === o) return i;
    if (null !== n) {
      if (void 0 !== t[n]) return t[n];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'");
    }
    var l = i;
    if (i === t.RED && (r === t.FLOAT && (l = t.R32F), r === t.HALF_FLOAT && (l = t.R16F), r === t.UNSIGNED_BYTE && (l = t.R8)), i === t.RED_INTEGER && (r === t.UNSIGNED_BYTE && (l = t.R8UI), r === t.UNSIGNED_SHORT && (l = t.R16UI), r === t.UNSIGNED_INT && (l = t.R32UI), r === t.BYTE && (l = t.R8I), r === t.SHORT && (l = t.R16I), r === t.INT && (l = t.R32I)), i === t.RG && (r === t.FLOAT && (l = t.RG32F), r === t.HALF_FLOAT && (l = t.RG16F), r === t.UNSIGNED_BYTE && (l = t.RG8)), i === t.RGBA) {
      var _e93 = a ? Je : pi.getTransfer(s);
      r === t.FLOAT && (l = t.RGBA32F), r === t.HALF_FLOAT && (l = t.RGBA16F), r === t.UNSIGNED_BYTE && (l = _e93 === Ke ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1);
    }
    return l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l;
  }
  function y(t, e, n) {
    return !0 === _(t, n) || t.isFramebufferTexture && t.minFilter !== ft && t.minFilter !== yt ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1;
  }
  function M(e) {
    return e === ft || e === gt || e === vt ? t.NEAREST : t.LINEAR;
  }
  function S(t) {
    var e = t.target;
    e.removeEventListener("dispose", S), function (t) {
      var e = i.get(t);
      if (void 0 === e.__webglInit) return;
      var n = t.source,
        r = d.get(n);
      if (r) {
        var _i86 = r[e.__cacheKey];
        _i86.usedTimes--, 0 === _i86.usedTimes && E(t), 0 === Object.keys(r).length && d.delete(n);
      }
      i.remove(t);
    }(e), e.isVideoTexture && h.delete(e);
  }
  function b(e) {
    var n = e.target;
    n.removeEventListener("dispose", b), function (e) {
      var n = e.texture,
        r = i.get(e),
        s = i.get(n);
      void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--);
      e.depthTexture && e.depthTexture.dispose();
      if (e.isWebGLCubeRenderTarget) for (var _e94 = 0; _e94 < 6; _e94++) {
        if (Array.isArray(r.__webglFramebuffer[_e94])) for (var _n97 = 0; _n97 < r.__webglFramebuffer[_e94].length; _n97++) t.deleteFramebuffer(r.__webglFramebuffer[_e94][_n97]);else t.deleteFramebuffer(r.__webglFramebuffer[_e94]);
        r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[_e94]);
      } else {
        if (Array.isArray(r.__webglFramebuffer)) for (var _e95 = 0; _e95 < r.__webglFramebuffer.length; _e95++) t.deleteFramebuffer(r.__webglFramebuffer[_e95]);else t.deleteFramebuffer(r.__webglFramebuffer);
        if (r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer) for (var _e96 = 0; _e96 < r.__webglColorRenderbuffer.length; _e96++) r.__webglColorRenderbuffer[_e96] && t.deleteRenderbuffer(r.__webglColorRenderbuffer[_e96]);
        r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
      }
      if (e.isWebGLMultipleRenderTargets) for (var _e97 = 0, _r54 = n.length; _e97 < _r54; _e97++) {
        var _r55 = i.get(n[_e97]);
        _r55.__webglTexture && (t.deleteTexture(_r55.__webglTexture), a.memory.textures--), i.remove(n[_e97]);
      }
      i.remove(n), i.remove(e);
    }(n);
  }
  function E(e) {
    var n = i.get(e);
    t.deleteTexture(n.__webglTexture);
    var r = e.source;
    delete d.get(r)[n.__cacheKey], a.memory.textures--;
  }
  var T = 0;
  function w(e, r) {
    var s = i.get(e);
    if (e.isVideoTexture && function (t) {
      var e = a.render.frame;
      h.get(t) !== e && (h.set(t, e), t.update());
    }(e), !1 === e.isRenderTargetTexture && e.version > 0 && s.__version !== e.version) {
      var _t131 = e.image;
      if (null === _t131) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else {
        if (!1 !== _t131.complete) return void I(s, e, r);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }
    n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
  }
  var A = _defineProperty(_defineProperty(_defineProperty({}, dt, t.REPEAT), pt, t.CLAMP_TO_EDGE), mt, t.MIRRORED_REPEAT),
    R = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, ft, t.NEAREST), gt, t.NEAREST_MIPMAP_NEAREST), vt, t.NEAREST_MIPMAP_LINEAR), yt, t.LINEAR), Mt, t.LINEAR_MIPMAP_NEAREST), bt, t.LINEAR_MIPMAP_LINEAR),
    C = {
      512: t.NEVER,
      519: t.ALWAYS,
      513: t.LESS,
      515: t.LEQUAL,
      514: t.EQUAL,
      518: t.GEQUAL,
      516: t.GREATER,
      517: t.NOTEQUAL
    };
  function P(n, s, a) {
    if (s.type !== Lt || !1 !== e.has("OES_texture_float_linear") || s.magFilter !== yt && s.magFilter !== Mt && s.magFilter !== vt && s.magFilter !== bt && s.minFilter !== yt && s.minFilter !== Mt && s.minFilter !== vt && s.minFilter !== bt || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), a ? (t.texParameteri(n, t.TEXTURE_WRAP_S, A[s.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, A[s.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, A[s.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, R[s.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, R[s.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), s.wrapS === pt && s.wrapT === pt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, M(s.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, M(s.minFilter)), s.minFilter !== ft && s.minFilter !== yt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), s.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, C[s.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
      var _a25 = e.get("EXT_texture_filter_anisotropic");
      if (s.magFilter === ft) return;
      if (s.minFilter !== vt && s.minFilter !== bt) return;
      if (s.type === Lt && !1 === e.has("OES_texture_float_linear")) return;
      if (!1 === o && s.type === It && !1 === e.has("OES_texture_half_float_linear")) return;
      (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, _a25.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy);
    }
  }
  function L(e, n) {
    var i = !1;
    void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S));
    var r = n.source;
    var s = d.get(r);
    void 0 === s && (s = {}, d.set(r, s));
    var o = function (t) {
      var e = [];
      return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.colorSpace), e.join();
    }(n);
    if (o !== e.__cacheKey) {
      void 0 === s[o] && (s[o] = {
        texture: t.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, i = !0), s[o].usedTimes++;
      var _r56 = s[e.__cacheKey];
      void 0 !== _r56 && (s[e.__cacheKey].usedTimes--, 0 === _r56.usedTimes && E(n)), e.__cacheKey = o, e.__webglTexture = s[o].texture;
    }
    return i;
  }
  function I(e, a, l) {
    var c = t.TEXTURE_2D;
    (a.isDataArrayTexture || a.isCompressedArrayTexture) && (c = t.TEXTURE_2D_ARRAY), a.isData3DTexture && (c = t.TEXTURE_3D);
    var h = L(e, a),
      u = a.source;
    n.bindTexture(c, e.__webglTexture, t.TEXTURE0 + l);
    var d = i.get(u);
    if (u.version !== d.__version || !0 === h) {
      n.activeTexture(t.TEXTURE0 + l);
      var _e98 = pi.getPrimaries(pi.workingColorSpace),
        _i87 = a.colorSpace === Xe ? null : pi.getPrimaries(a.colorSpace),
        _p8 = a.colorSpace === Xe || _e98 === _i87 ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, _p8);
      var _m5 = function (t) {
        return !o && (t.wrapS !== pt || t.wrapT !== pt || t.minFilter !== ft && t.minFilter !== yt);
      }(a) && !1 === g(a.image);
      var _M2 = f(a.image, _m5, !1, r.maxTextureSize);
      _M2 = B(a, _M2);
      var _S3 = g(_M2) || o,
        _b3 = s.convert(a.format, a.colorSpace);
      var _E3,
        _T2 = s.convert(a.type),
        _w2 = x(a.internalFormat, _b3, _T2, a.colorSpace, a.isVideoTexture);
      P(c, a, _S3);
      var _A3 = a.mipmaps,
        _R3 = o && !0 !== a.isVideoTexture && _w2 !== ee,
        _C = void 0 === d.__version || !0 === h,
        _L2 = u.dataReady,
        _I2 = y(a, _M2, _S3);
      if (a.isDepthTexture) _w2 = t.DEPTH_COMPONENT, o ? _w2 = a.type === Lt ? t.DEPTH_COMPONENT32F : a.type === Pt ? t.DEPTH_COMPONENT24 : a.type === Dt ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : a.type === Lt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), a.format === Ht && _w2 === t.DEPTH_COMPONENT && a.type !== Rt && a.type !== Pt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), a.type = Pt, _T2 = s.convert(a.type)), a.format === Vt && _w2 === t.DEPTH_COMPONENT && (_w2 = t.DEPTH_STENCIL, a.type !== Dt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), a.type = Dt, _T2 = s.convert(a.type))), _C && (_R3 ? n.texStorage2D(t.TEXTURE_2D, 1, _w2, _M2.width, _M2.height) : n.texImage2D(t.TEXTURE_2D, 0, _w2, _M2.width, _M2.height, 0, _b3, _T2, null));else if (a.isDataTexture) {
        if (_A3.length > 0 && _S3) {
          _R3 && _C && n.texStorage2D(t.TEXTURE_2D, _I2, _w2, _A3[0].width, _A3[0].height);
          for (var _e99 = 0, _i88 = _A3.length; _e99 < _i88; _e99++) _E3 = _A3[_e99], _R3 ? _L2 && n.texSubImage2D(t.TEXTURE_2D, _e99, 0, 0, _E3.width, _E3.height, _b3, _T2, _E3.data) : n.texImage2D(t.TEXTURE_2D, _e99, _w2, _E3.width, _E3.height, 0, _b3, _T2, _E3.data);
          a.generateMipmaps = !1;
        } else _R3 ? (_C && n.texStorage2D(t.TEXTURE_2D, _I2, _w2, _M2.width, _M2.height), _L2 && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, _M2.width, _M2.height, _b3, _T2, _M2.data)) : n.texImage2D(t.TEXTURE_2D, 0, _w2, _M2.width, _M2.height, 0, _b3, _T2, _M2.data);
      } else if (a.isCompressedTexture) {
        if (a.isCompressedArrayTexture) {
          _R3 && _C && n.texStorage3D(t.TEXTURE_2D_ARRAY, _I2, _w2, _A3[0].width, _A3[0].height, _M2.depth);
          for (var _e100 = 0, _i89 = _A3.length; _e100 < _i89; _e100++) _E3 = _A3[_e100], a.format !== Ft ? null !== _b3 ? _R3 ? _L2 && n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, _e100, 0, 0, 0, _E3.width, _E3.height, _M2.depth, _b3, _E3.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, _e100, _w2, _E3.width, _E3.height, _M2.depth, 0, _E3.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _R3 ? _L2 && n.texSubImage3D(t.TEXTURE_2D_ARRAY, _e100, 0, 0, 0, _E3.width, _E3.height, _M2.depth, _b3, _T2, _E3.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, _e100, _w2, _E3.width, _E3.height, _M2.depth, 0, _b3, _T2, _E3.data);
        } else {
          _R3 && _C && n.texStorage2D(t.TEXTURE_2D, _I2, _w2, _A3[0].width, _A3[0].height);
          for (var _e101 = 0, _i90 = _A3.length; _e101 < _i90; _e101++) _E3 = _A3[_e101], a.format !== Ft ? null !== _b3 ? _R3 ? _L2 && n.compressedTexSubImage2D(t.TEXTURE_2D, _e101, 0, 0, _E3.width, _E3.height, _b3, _E3.data) : n.compressedTexImage2D(t.TEXTURE_2D, _e101, _w2, _E3.width, _E3.height, 0, _E3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _R3 ? _L2 && n.texSubImage2D(t.TEXTURE_2D, _e101, 0, 0, _E3.width, _E3.height, _b3, _T2, _E3.data) : n.texImage2D(t.TEXTURE_2D, _e101, _w2, _E3.width, _E3.height, 0, _b3, _T2, _E3.data);
        }
      } else if (a.isDataArrayTexture) _R3 ? (_C && n.texStorage3D(t.TEXTURE_2D_ARRAY, _I2, _w2, _M2.width, _M2.height, _M2.depth), _L2 && n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, _M2.width, _M2.height, _M2.depth, _b3, _T2, _M2.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, _w2, _M2.width, _M2.height, _M2.depth, 0, _b3, _T2, _M2.data);else if (a.isData3DTexture) _R3 ? (_C && n.texStorage3D(t.TEXTURE_3D, _I2, _w2, _M2.width, _M2.height, _M2.depth), _L2 && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, _M2.width, _M2.height, _M2.depth, _b3, _T2, _M2.data)) : n.texImage3D(t.TEXTURE_3D, 0, _w2, _M2.width, _M2.height, _M2.depth, 0, _b3, _T2, _M2.data);else if (a.isFramebufferTexture) {
        if (_C) if (_R3) n.texStorage2D(t.TEXTURE_2D, _I2, _w2, _M2.width, _M2.height);else {
          var _e102 = _M2.width,
            _i91 = _M2.height;
          for (var _r57 = 0; _r57 < _I2; _r57++) n.texImage2D(t.TEXTURE_2D, _r57, _w2, _e102, _i91, 0, _b3, _T2, null), _e102 >>= 1, _i91 >>= 1;
        }
      } else if (_A3.length > 0 && _S3) {
        _R3 && _C && n.texStorage2D(t.TEXTURE_2D, _I2, _w2, _A3[0].width, _A3[0].height);
        for (var _e103 = 0, _i92 = _A3.length; _e103 < _i92; _e103++) _E3 = _A3[_e103], _R3 ? _L2 && n.texSubImage2D(t.TEXTURE_2D, _e103, 0, 0, _b3, _T2, _E3) : n.texImage2D(t.TEXTURE_2D, _e103, _w2, _b3, _T2, _E3);
        a.generateMipmaps = !1;
      } else _R3 ? (_C && n.texStorage2D(t.TEXTURE_2D, _I2, _w2, _M2.width, _M2.height), _L2 && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, _b3, _T2, _M2)) : n.texImage2D(t.TEXTURE_2D, 0, _w2, _b3, _T2, _M2);
      _(a, _S3) && v(c), d.__version = u.version, a.onUpdate && a.onUpdate(a);
    }
    e.__version = a.version;
  }
  function U(e, r, a, o, c, h) {
    var u = s.convert(a.format, a.colorSpace),
      d = s.convert(a.type),
      p = x(a.internalFormat, u, d, a.colorSpace);
    if (!i.get(r).__hasExternalTextures) {
      var _e104 = Math.max(1, r.width >> h),
        _i93 = Math.max(1, r.height >> h);
      c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY ? n.texImage3D(c, h, p, _e104, _i93, r.depth, 0, u, d, null) : n.texImage2D(c, h, p, _e104, _i93, 0, u, d, null);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, e), F(r) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, o, c, i.get(a).__webglTexture, 0, O(r)) : (c === t.TEXTURE_2D || c >= t.TEXTURE_CUBE_MAP_POSITIVE_X && c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, o, c, i.get(a).__webglTexture, h), n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function N(e, n, i) {
    if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
      var _r58 = !0 === o ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
      if (i || F(n)) {
        var _e105 = n.depthTexture;
        _e105 && _e105.isDepthTexture && (_e105.type === Lt ? _r58 = t.DEPTH_COMPONENT32F : _e105.type === Pt && (_r58 = t.DEPTH_COMPONENT24));
        var _i94 = O(n);
        F(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, _i94, _r58, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, _i94, _r58, n.width, n.height);
      } else t.renderbufferStorage(t.RENDERBUFFER, _r58, n.width, n.height);
      t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e);
    } else if (n.depthBuffer && n.stencilBuffer) {
      var _r59 = O(n);
      i && !1 === F(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, _r59, t.DEPTH24_STENCIL8, n.width, n.height) : F(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, _r59, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e);
    } else {
      var _e106 = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
      for (var _r60 = 0; _r60 < _e106.length; _r60++) {
        var _a26 = _e106[_r60],
          _o17 = s.convert(_a26.format, _a26.colorSpace),
          _c12 = s.convert(_a26.type),
          _h8 = x(_a26.internalFormat, _o17, _c12, _a26.colorSpace),
          _u8 = O(n);
        i && !1 === F(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, _u8, _h8, n.width, n.height) : F(n) ? l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, _u8, _h8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, _h8, n.width, n.height);
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  function D(e) {
    var r = i.get(e),
      s = !0 === e.isWebGLCubeRenderTarget;
    if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
      if (s) throw new Error("target.depthTexture not supported in Cube render targets");
      !function (e, r) {
        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (n.bindFramebuffer(t.FRAMEBUFFER, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), w(r.depthTexture, 0);
        var s = i.get(r.depthTexture).__webglTexture,
          a = O(r);
        if (r.depthTexture.format === Ht) F(r) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);else {
          if (r.depthTexture.format !== Vt) throw new Error("Unknown depthTexture format");
          F(r) ? l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0);
        }
      }(r.__webglFramebuffer, e);
    } else if (s) {
      r.__webglDepthbuffer = [];
      for (var _i95 = 0; _i95 < 6; _i95++) n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[_i95]), r.__webglDepthbuffer[_i95] = t.createRenderbuffer(), N(r.__webglDepthbuffer[_i95], e, !1);
    } else n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), N(r.__webglDepthbuffer, e, !1);
    n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function O(t) {
    return Math.min(r.maxSamples, t.samples);
  }
  function F(t) {
    var n = i.get(t);
    return o && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture;
  }
  function B(t, n) {
    var i = t.colorSpace,
      r = t.format,
      s = t.type;
    return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === On || i !== qe && i !== Xe && (pi.getTransfer(i) === Ke ? !1 === o ? !0 === e.has("EXT_sRGB") && r === Ft ? (t.format = On, t.minFilter = yt, t.generateMipmaps = !1) : n = _i.sRGBToLinear(n) : r === Ft && s === Tt || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)), n;
  }
  this.allocateTextureUnit = function () {
    var t = T;
    return t >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + r.maxTextures), T += 1, t;
  }, this.resetTextureUnits = function () {
    T = 0;
  }, this.setTexture2D = w, this.setTexture2DArray = function (e, r) {
    var s = i.get(e);
    e.version > 0 && s.__version !== e.version ? I(s, e, r) : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r);
  }, this.setTexture3D = function (e, r) {
    var s = i.get(e);
    e.version > 0 && s.__version !== e.version ? I(s, e, r) : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
  }, this.setTextureCube = function (e, a) {
    var l = i.get(e);
    e.version > 0 && l.__version !== e.version ? function (e, a, l) {
      if (6 !== a.image.length) return;
      var c = L(e, a),
        h = a.source;
      n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + l);
      var u = i.get(h);
      if (h.version !== u.__version || !0 === c) {
        n.activeTexture(t.TEXTURE0 + l);
        var _e107 = pi.getPrimaries(pi.workingColorSpace),
          _i96 = a.colorSpace === Xe ? null : pi.getPrimaries(a.colorSpace),
          _d9 = a.colorSpace === Xe || _e107 === _i96 ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, _d9);
        var _p9 = a.isCompressedTexture || a.image[0].isCompressedTexture,
          _m6 = a.image[0] && a.image[0].isDataTexture,
          _M3 = [];
        for (var _t132 = 0; _t132 < 6; _t132++) _M3[_t132] = _p9 || _m6 ? _m6 ? a.image[_t132].image : a.image[_t132] : f(a.image[_t132], !1, !0, r.maxCubemapSize), _M3[_t132] = B(a, _M3[_t132]);
        var _S4 = _M3[0],
          _b4 = g(_S4) || o,
          _E4 = s.convert(a.format, a.colorSpace),
          _T3 = s.convert(a.type),
          _w3 = x(a.internalFormat, _E4, _T3, a.colorSpace),
          _A4 = o && !0 !== a.isVideoTexture,
          _R4 = void 0 === u.__version || !0 === c,
          _C2 = h.dataReady;
        var _L3,
          _I3 = y(a, _S4, _b4);
        if (P(t.TEXTURE_CUBE_MAP, a, _b4), _p9) {
          _A4 && _R4 && n.texStorage2D(t.TEXTURE_CUBE_MAP, _I3, _w3, _S4.width, _S4.height);
          for (var _e108 = 0; _e108 < 6; _e108++) {
            _L3 = _M3[_e108].mipmaps;
            for (var _i97 = 0; _i97 < _L3.length; _i97++) {
              var _r61 = _L3[_i97];
              a.format !== Ft ? null !== _E4 ? _A4 ? _C2 && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e108, _i97, 0, 0, _r61.width, _r61.height, _E4, _r61.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e108, _i97, _w3, _r61.width, _r61.height, 0, _r61.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : _A4 ? _C2 && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e108, _i97, 0, 0, _r61.width, _r61.height, _E4, _T3, _r61.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e108, _i97, _w3, _r61.width, _r61.height, 0, _E4, _T3, _r61.data);
            }
          }
        } else {
          _L3 = a.mipmaps, _A4 && _R4 && (_L3.length > 0 && _I3++, n.texStorage2D(t.TEXTURE_CUBE_MAP, _I3, _w3, _M3[0].width, _M3[0].height));
          for (var _e109 = 0; _e109 < 6; _e109++) if (_m6) {
            _A4 ? _C2 && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e109, 0, 0, 0, _M3[_e109].width, _M3[_e109].height, _E4, _T3, _M3[_e109].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e109, 0, _w3, _M3[_e109].width, _M3[_e109].height, 0, _E4, _T3, _M3[_e109].data);
            for (var _i98 = 0; _i98 < _L3.length; _i98++) {
              var _r62 = _L3[_i98].image[_e109].image;
              _A4 ? _C2 && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e109, _i98 + 1, 0, 0, _r62.width, _r62.height, _E4, _T3, _r62.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e109, _i98 + 1, _w3, _r62.width, _r62.height, 0, _E4, _T3, _r62.data);
            }
          } else {
            _A4 ? _C2 && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e109, 0, 0, 0, _E4, _T3, _M3[_e109]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e109, 0, _w3, _E4, _T3, _M3[_e109]);
            for (var _i99 = 0; _i99 < _L3.length; _i99++) {
              var _r63 = _L3[_i99];
              _A4 ? _C2 && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e109, _i99 + 1, 0, 0, _E4, _T3, _r63.image[_e109]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + _e109, _i99 + 1, _w3, _E4, _T3, _r63.image[_e109]);
            }
          }
        }
        _(a, _b4) && v(t.TEXTURE_CUBE_MAP), u.__version = h.version, a.onUpdate && a.onUpdate(a);
      }
      e.__version = a.version;
    }(l, e, a) : n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture, t.TEXTURE0 + a);
  }, this.rebindTextures = function (e, n, r) {
    var s = i.get(e);
    void 0 !== n && U(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), void 0 !== r && D(e);
  }, this.setupRenderTarget = function (e) {
    var l = e.texture,
      c = i.get(e),
      h = i.get(l);
    e.addEventListener("dispose", b), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, a.memory.textures++);
    var u = !0 === e.isWebGLCubeRenderTarget,
      d = !0 === e.isWebGLMultipleRenderTargets,
      p = g(e) || o;
    if (u) {
      c.__webglFramebuffer = [];
      for (var _e110 = 0; _e110 < 6; _e110++) if (o && l.mipmaps && l.mipmaps.length > 0) {
        c.__webglFramebuffer[_e110] = [];
        for (var _n98 = 0; _n98 < l.mipmaps.length; _n98++) c.__webglFramebuffer[_e110][_n98] = t.createFramebuffer();
      } else c.__webglFramebuffer[_e110] = t.createFramebuffer();
    } else {
      if (o && l.mipmaps && l.mipmaps.length > 0) {
        c.__webglFramebuffer = [];
        for (var _e111 = 0; _e111 < l.mipmaps.length; _e111++) c.__webglFramebuffer[_e111] = t.createFramebuffer();
      } else c.__webglFramebuffer = t.createFramebuffer();
      if (d) if (r.drawBuffers) {
        var _n99 = e.texture;
        for (var _e112 = 0, _r64 = _n99.length; _e112 < _r64; _e112++) {
          var _r65 = i.get(_n99[_e112]);
          void 0 === _r65.__webglTexture && (_r65.__webglTexture = t.createTexture(), a.memory.textures++);
        }
      } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (o && e.samples > 0 && !1 === F(e)) {
        var _i100 = d ? l : [l];
        c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
        for (var _n100 = 0; _n100 < _i100.length; _n100++) {
          var _r66 = _i100[_n100];
          c.__webglColorRenderbuffer[_n100] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer[_n100]);
          var _a27 = s.convert(_r66.format, _r66.colorSpace),
            _o18 = s.convert(_r66.type),
            _l12 = x(_r66.internalFormat, _a27, _o18, _r66.colorSpace, !0 === e.isXRRenderTarget),
            _h9 = O(e);
          t.renderbufferStorageMultisample(t.RENDERBUFFER, _h9, _l12, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + _n100, t.RENDERBUFFER, c.__webglColorRenderbuffer[_n100]);
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), N(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
    }
    if (u) {
      n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), P(t.TEXTURE_CUBE_MAP, l, p);
      for (var _n101 = 0; _n101 < 6; _n101++) if (o && l.mipmaps && l.mipmaps.length > 0) for (var _i101 = 0; _i101 < l.mipmaps.length; _i101++) U(c.__webglFramebuffer[_n101][_i101], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + _n101, _i101);else U(c.__webglFramebuffer[_n101], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + _n101, 0);
      _(l, p) && v(t.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (d) {
      var _r67 = e.texture;
      for (var _s34 = 0, _a28 = _r67.length; _s34 < _a28; _s34++) {
        var _a29 = _r67[_s34],
          _o19 = i.get(_a29);
        n.bindTexture(t.TEXTURE_2D, _o19.__webglTexture), P(t.TEXTURE_2D, _a29, p), U(c.__webglFramebuffer, e, _a29, t.COLOR_ATTACHMENT0 + _s34, t.TEXTURE_2D, 0), _(_a29, p) && v(t.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      var _i102 = t.TEXTURE_2D;
      if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (o ? _i102 = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(_i102, h.__webglTexture), P(_i102, l, p), o && l.mipmaps && l.mipmaps.length > 0) for (var _n102 = 0; _n102 < l.mipmaps.length; _n102++) U(c.__webglFramebuffer[_n102], e, l, t.COLOR_ATTACHMENT0, _i102, _n102);else U(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, _i102, 0);
      _(l, p) && v(_i102), n.unbindTexture();
    }
    e.depthBuffer && D(e);
  }, this.updateRenderTargetMipmap = function (e) {
    var r = g(e) || o,
      s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
    for (var _a30 = 0, _o20 = s.length; _a30 < _o20; _a30++) {
      var _o21 = s[_a30];
      if (_(_o21, r)) {
        var _r68 = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
          _s35 = i.get(_o21).__webglTexture;
        n.bindTexture(_r68, _s35), v(_r68), n.unbindTexture();
      }
    }
  }, this.updateMultisampleRenderTarget = function (e) {
    if (o && e.samples > 0 && !1 === F(e)) {
      var _r69 = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
        _s36 = e.width,
        _a31 = e.height;
      var _o22 = t.COLOR_BUFFER_BIT;
      var _l13 = [],
        _h10 = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
        _u9 = i.get(e),
        _d10 = !0 === e.isWebGLMultipleRenderTargets;
      if (_d10) for (var _e113 = 0; _e113 < _r69.length; _e113++) n.bindFramebuffer(t.FRAMEBUFFER, _u9.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + _e113, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, _u9.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + _e113, t.TEXTURE_2D, null, 0);
      n.bindFramebuffer(t.READ_FRAMEBUFFER, _u9.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, _u9.__webglFramebuffer);
      for (var _n103 = 0; _n103 < _r69.length; _n103++) {
        _l13.push(t.COLOR_ATTACHMENT0 + _n103), e.depthBuffer && _l13.push(_h10);
        var _p10 = void 0 !== _u9.__ignoreDepthValues && _u9.__ignoreDepthValues;
        if (!1 === _p10 && (e.depthBuffer && (_o22 |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (_o22 |= t.STENCIL_BUFFER_BIT)), _d10 && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, _u9.__webglColorRenderbuffer[_n103]), !0 === _p10 && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [_h10]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [_h10])), _d10) {
          var _e114 = i.get(_r69[_n103]).__webglTexture;
          t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, _e114, 0);
        }
        t.blitFramebuffer(0, 0, _s36, _a31, 0, 0, _s36, _a31, _o22, t.NEAREST), c && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, _l13);
      }
      if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), _d10) for (var _e115 = 0; _e115 < _r69.length; _e115++) {
        n.bindFramebuffer(t.FRAMEBUFFER, _u9.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + _e115, t.RENDERBUFFER, _u9.__webglColorRenderbuffer[_e115]);
        var _s37 = i.get(_r69[_e115]).__webglTexture;
        n.bindFramebuffer(t.FRAMEBUFFER, _u9.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + _e115, t.TEXTURE_2D, _s37, 0);
      }
      n.bindFramebuffer(t.DRAW_FRAMEBUFFER, _u9.__webglMultisampledFramebuffer);
    }
  }, this.setupDepthRenderbuffer = D, this.setupFrameBufferTexture = U, this.useMultisampledRTT = F;
}
function Gl(t, e, n) {
  var i = n.isWebGL2;
  return {
    convert: function convert(n) {
      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var s;
      var a = pi.getTransfer(r);
      if (n === Tt) return t.UNSIGNED_BYTE;
      if (n === Ut) return t.UNSIGNED_SHORT_4_4_4_4;
      if (n === Nt) return t.UNSIGNED_SHORT_5_5_5_1;
      if (1010 === n) return t.BYTE;
      if (1011 === n) return t.SHORT;
      if (n === Rt) return t.UNSIGNED_SHORT;
      if (n === Ct) return t.INT;
      if (n === Pt) return t.UNSIGNED_INT;
      if (n === Lt) return t.FLOAT;
      if (n === It) return i ? t.HALF_FLOAT : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
      if (1021 === n) return t.ALPHA;
      if (n === Ft) return t.RGBA;
      if (1024 === n) return t.LUMINANCE;
      if (1025 === n) return t.LUMINANCE_ALPHA;
      if (n === Ht) return t.DEPTH_COMPONENT;
      if (n === Vt) return t.DEPTH_STENCIL;
      if (n === On) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
      if (1028 === n) return t.RED;
      if (n === Gt) return t.RED_INTEGER;
      if (1030 === n) return t.RG;
      if (n === Xt) return t.RG_INTEGER;
      if (n === jt) return t.RGBA_INTEGER;
      if (n === qt || n === Yt || n === Zt || n === Jt) if (a === Ke) {
        if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
        if (n === qt) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (n === Yt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (n === Zt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (n === Jt) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else {
        if (s = e.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
        if (n === qt) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Yt) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Zt) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Jt) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      if (n === Kt || n === $t || n === Qt || n === te) {
        if (s = e.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
        if (n === Kt) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === $t) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === Qt) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === te) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (n === ee) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
      if (n === ne || n === ie) {
        if (s = e.get("WEBGL_compressed_texture_etc"), null === s) return null;
        if (n === ne) return a === Ke ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (n === ie) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
      }
      if (n === re || n === se || n === ae || n === oe || n === le || n === ce || n === he || n === ue || n === de || n === pe || n === me || n === fe || n === ge || n === _e) {
        if (s = e.get("WEBGL_compressed_texture_astc"), null === s) return null;
        if (n === re) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === se) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === ae) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === oe) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === le) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === ce) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === he) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === ue) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === de) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === pe) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === me) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === fe) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === ge) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === _e) return a === Ke ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      }
      if (n === ve || n === xe || n === ye) {
        if (s = e.get("EXT_texture_compression_bptc"), null === s) return null;
        if (n === ve) return a === Ke ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === xe) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === ye) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      }
      if (36283 === n || n === Se || n === be || n === Ee) {
        if (s = e.get("EXT_texture_compression_rgtc"), null === s) return null;
        if (n === ve) return s.COMPRESSED_RED_RGTC1_EXT;
        if (n === Se) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === be) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Ee) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      }
      return n === Dt ? i ? t.UNSIGNED_INT_24_8 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null;
    }
  };
}
var Wl = exports.ArrayCamera = /*#__PURE__*/function (_ea) {
  function Wl() {
    var _this27;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    _classCallCheck(this, Wl);
    _this27 = _callSuper(this, Wl), _this27.isArrayCamera = !0, _this27.cameras = t;
    return _this27;
  }
  _inherits(Wl, _ea);
  return _createClass(Wl);
}(ea);
var Xl = exports.Group = /*#__PURE__*/function (_Ur4) {
  function Xl() {
    var _this28;
    _classCallCheck(this, Xl);
    _this28 = _callSuper(this, Xl), _this28.isGroup = !0, _this28.type = "Group";
    return _this28;
  }
  _inherits(Xl, _Ur4);
  return _createClass(Xl);
}(Ur);
var jl = {
  type: "move"
};
var ql = /*#__PURE__*/function () {
  function ql() {
    _classCallCheck(this, ql);
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  return _createClass(ql, [{
    key: "getHandSpace",
    value: function getHandSpace() {
      return null === this._hand && (this._hand = new Xl(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
        pinching: !1
      }), this._hand;
    }
  }, {
    key: "getTargetRaySpace",
    value: function getTargetRaySpace() {
      return null === this._targetRay && (this._targetRay = new Xl(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Ii(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Ii()), this._targetRay;
    }
  }, {
    key: "getGripSpace",
    value: function getGripSpace() {
      return null === this._grip && (this._grip = new Xl(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Ii(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Ii()), this._grip;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(t) {
      return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this;
    }
  }, {
    key: "connect",
    value: function connect(t) {
      if (t && t.hand) {
        var _e116 = this._hand;
        if (_e116) {
          var _iterator4 = _createForOfIteratorHelper(t.hand.values()),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _n104 = _step4.value;
              this._getHandJoint(_e116, _n104);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      }
      return this.dispatchEvent({
        type: "connected",
        data: t
      }), this;
    }
  }, {
    key: "disconnect",
    value: function disconnect(t) {
      return this.dispatchEvent({
        type: "disconnected",
        data: t
      }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
    }
  }, {
    key: "update",
    value: function update(t, e, n) {
      var i = null,
        r = null,
        s = null;
      var a = this._targetRay,
        o = this._grip,
        l = this._hand;
      if (t && "visible-blurred" !== e.session.visibilityState) {
        if (l && t.hand) {
          s = !0;
          var _iterator5 = _createForOfIteratorHelper(t.hand.values()),
            _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _i104 = _step5.value;
              var _t133 = e.getJointPose(_i104, n),
                _r71 = this._getHandJoint(l, _i104);
              null !== _t133 && (_r71.matrix.fromArray(_t133.transform.matrix), _r71.matrix.decompose(_r71.position, _r71.rotation, _r71.scale), _r71.matrixWorldNeedsUpdate = !0, _r71.jointRadius = _t133.radius), _r71.visible = null !== _t133;
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          var _i103 = l.joints["index-finger-tip"],
            _r70 = l.joints["thumb-tip"],
            _a32 = _i103.position.distanceTo(_r70.position),
            _o23 = .02,
            _c13 = .005;
          l.inputState.pinching && _a32 > _o23 + _c13 ? (l.inputState.pinching = !1, this.dispatchEvent({
            type: "pinchend",
            handedness: t.handedness,
            target: this
          })) : !l.inputState.pinching && _a32 <= _o23 - _c13 && (l.inputState.pinching = !0, this.dispatchEvent({
            type: "pinchstart",
            handedness: t.handedness,
            target: this
          }));
        } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
        null !== a && (i = e.getPose(t.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(jl)));
      }
      return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this;
    }
  }, {
    key: "_getHandJoint",
    value: function _getHandJoint(t, e) {
      if (void 0 === t.joints[e.jointName]) {
        var _n105 = new Xl();
        _n105.matrixAutoUpdate = !1, _n105.visible = !1, t.joints[e.jointName] = _n105, t.add(_n105);
      }
      return t.joints[e.jointName];
    }
  }]);
}();
var Yl = /*#__PURE__*/function () {
  function Yl() {
    _classCallCheck(this, Yl);
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  return _createClass(Yl, [{
    key: "init",
    value: function init(t, e, n) {
      if (null === this.texture) {
        var _i105 = new Si();
        t.properties.get(_i105).__webglTexture = e.texture, e.depthNear == n.depthNear && e.depthFar == n.depthFar || (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = _i105;
      }
    }
  }, {
    key: "render",
    value: function render(t, e) {
      if (null !== this.texture) {
        if (null === this.mesh) {
          var _t134 = e.cameras[0].viewport,
            _n106 = new Js({
              extensions: {
                fragDepth: !0
              },
              vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
              fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
              uniforms: {
                depthColor: {
                  value: this.texture
                },
                depthWidth: {
                  value: _t134.z
                },
                depthHeight: {
                  value: _t134.w
                }
              }
            });
          this.mesh = new Gs(new fa(20, 20), _n106);
        }
        t.render(this.mesh, e);
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.texture = null, this.mesh = null;
    }
  }]);
}();
var Zl = /*#__PURE__*/function (_zn6) {
  function Zl(t, e) {
    var _this29;
    _classCallCheck(this, Zl);
    _this29 = _callSuper(this, Zl);
    var n = _this29;
    var i = null,
      r = 1,
      s = null,
      a = "local-floor",
      o = 1,
      l = null,
      c = null,
      h = null,
      u = null,
      d = null,
      p = null;
    var m = new Yl(),
      f = e.getContextAttributes();
    var g = null,
      _ = null;
    var v = [],
      x = [],
      y = new Qn();
    var M = null;
    var S = new ea();
    S.layers.enable(1), S.viewport = new bi();
    var b = new ea();
    b.layers.enable(2), b.viewport = new bi();
    var E = [S, b],
      T = new Wl();
    T.layers.enable(1), T.layers.enable(2);
    var w = null,
      A = null;
    function R(t) {
      var e = x.indexOf(t.inputSource);
      if (-1 === e) return;
      var n = v[e];
      void 0 !== n && (n.update(t.inputSource, t.frame, l || s), n.dispatchEvent({
        type: t.type,
        data: t.inputSource
      }));
    }
    function C() {
      i.removeEventListener("select", R), i.removeEventListener("selectstart", R), i.removeEventListener("selectend", R), i.removeEventListener("squeeze", R), i.removeEventListener("squeezestart", R), i.removeEventListener("squeezeend", R), i.removeEventListener("end", C), i.removeEventListener("inputsourceschange", P);
      for (var _t135 = 0; _t135 < v.length; _t135++) {
        var _e117 = x[_t135];
        null !== _e117 && (x[_t135] = null, v[_t135].disconnect(_e117));
      }
      w = null, A = null, m.reset(), t.setRenderTarget(g), d = null, u = null, h = null, i = null, _ = null, D.stop(), n.isPresenting = !1, t.setPixelRatio(M), t.setSize(y.width, y.height, !1), n.dispatchEvent({
        type: "sessionend"
      });
    }
    function P(t) {
      for (var _e118 = 0; _e118 < t.removed.length; _e118++) {
        var _n107 = t.removed[_e118],
          _i106 = x.indexOf(_n107);
        _i106 >= 0 && (x[_i106] = null, v[_i106].disconnect(_n107));
      }
      for (var _e119 = 0; _e119 < t.added.length; _e119++) {
        var _n108 = t.added[_e119];
        var _i107 = x.indexOf(_n108);
        if (-1 === _i107) {
          for (var _t136 = 0; _t136 < v.length; _t136++) {
            if (_t136 >= x.length) {
              x.push(_n108), _i107 = _t136;
              break;
            }
            if (null === x[_t136]) {
              x[_t136] = _n108, _i107 = _t136;
              break;
            }
          }
          if (-1 === _i107) break;
        }
        var _r72 = v[_i107];
        _r72 && _r72.connect(_n108);
      }
    }
    _this29.cameraAutoUpdate = !0, _this29.enabled = !1, _this29.isPresenting = !1, _this29.getController = function (t) {
      var e = v[t];
      return void 0 === e && (e = new ql(), v[t] = e), e.getTargetRaySpace();
    }, _this29.getControllerGrip = function (t) {
      var e = v[t];
      return void 0 === e && (e = new ql(), v[t] = e), e.getGripSpace();
    }, _this29.getHand = function (t) {
      var e = v[t];
      return void 0 === e && (e = new ql(), v[t] = e), e.getHandSpace();
    }, _this29.setFramebufferScaleFactor = function (t) {
      r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, _this29.setReferenceSpaceType = function (t) {
      a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, _this29.getReferenceSpace = function () {
      return l || s;
    }, _this29.setReferenceSpace = function (t) {
      l = t;
    }, _this29.getBaseLayer = function () {
      return null !== u ? u : d;
    }, _this29.getBinding = function () {
      return h;
    }, _this29.getFrame = function () {
      return p;
    }, _this29.getSession = function () {
      return i;
    }, _this29.setSession = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(c) {
        var _n109, _n110, _s38, _a33, _o24;
        return _regeneratorRuntime().wrap(function _callee$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!(i = c, null !== i)) {
                _context7.next = 36;
                break;
              }
              g = t.getRenderTarget();
              i.addEventListener("select", R);
              i.addEventListener("selectstart", R);
              i.addEventListener("selectend", R);
              i.addEventListener("squeeze", R);
              i.addEventListener("squeezestart", R);
              i.addEventListener("squeezeend", R);
              i.addEventListener("end", C);
              i.addEventListener("inputsourceschange", P);
              _context7.t0 = !0 !== f.xrCompatible;
              if (!_context7.t0) {
                _context7.next = 14;
                break;
              }
              _context7.next = 14;
              return e.makeXRCompatible();
            case 14:
              M = t.getPixelRatio();
              t.getSize(y);
              if (!(void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2)) {
                _context7.next = 21;
                break;
              }
              _n109 = {
                antialias: void 0 !== i.renderState.layers || f.antialias,
                alpha: !0,
                depth: f.depth,
                stencil: f.stencil,
                framebufferScaleFactor: r
              };
              d = new XRWebGLLayer(i, e, _n109), i.updateRenderState({
                baseLayer: d
              }), t.setPixelRatio(1), t.setSize(d.framebufferWidth, d.framebufferHeight, !1), _ = new Ti(d.framebufferWidth, d.framebufferHeight, {
                format: Ft,
                type: Tt,
                colorSpace: t.outputColorSpace,
                stencilBuffer: f.stencil
              });
              _context7.next = 26;
              break;
            case 21:
              _n110 = null, _s38 = null, _a33 = null;
              f.depth && (_a33 = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, _n110 = f.stencil ? Vt : Ht, _s38 = f.stencil ? Dt : Pt);
              _o24 = {
                colorFormat: e.RGBA8,
                depthFormat: _a33,
                scaleFactor: r
              };
              h = new XRWebGLBinding(i, e), u = h.createProjectionLayer(_o24), i.updateRenderState({
                layers: [u]
              }), t.setPixelRatio(1), t.setSize(u.textureWidth, u.textureHeight, !1), _ = new Ti(u.textureWidth, u.textureHeight, {
                format: Ft,
                type: Tt,
                depthTexture: new $a(u.textureWidth, u.textureHeight, _s38, void 0, void 0, void 0, void 0, void 0, void 0, _n110),
                stencilBuffer: f.stencil,
                colorSpace: t.outputColorSpace,
                samples: f.antialias ? 4 : 0
              });
              t.properties.get(_).__ignoreDepthValues = u.ignoreDepthValues;
            case 26:
              _.isXRRenderTarget = !0;
              this.setFoveation(o);
              l = null;
              _context7.next = 31;
              return i.requestReferenceSpace(a);
            case 31:
              s = _context7.sent;
              D.setContext(i);
              D.start();
              n.isPresenting = !0;
              n.dispatchEvent({
                type: "sessionstart"
              });
            case 36:
            case "end":
              return _context7.stop();
          }
        }, _callee, this);
      }));
      return function (_x4) {
        return _ref2.apply(this, arguments);
      };
    }(), _this29.getEnvironmentBlendMode = function () {
      if (null !== i) return i.environmentBlendMode;
    };
    var L = new Ii(),
      I = new Ii();
    function U(t, e) {
      null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert();
    }
    _this29.updateCamera = function (t) {
      if (null === i) return;
      null !== m.texture && (t.near = m.depthNear, t.far = m.depthFar), T.near = b.near = S.near = t.near, T.far = b.far = S.far = t.far, w === T.near && A === T.far || (i.updateRenderState({
        depthNear: T.near,
        depthFar: T.far
      }), w = T.near, A = T.far, S.near = w, S.far = A, b.near = w, b.far = A, S.updateProjectionMatrix(), b.updateProjectionMatrix(), t.updateProjectionMatrix());
      var e = t.parent,
        n = T.cameras;
      U(T, e);
      for (var _t137 = 0; _t137 < n.length; _t137++) U(n[_t137], e);
      2 === n.length ? function (t, e, n) {
        L.setFromMatrixPosition(e.matrixWorld), I.setFromMatrixPosition(n.matrixWorld);
        var i = L.distanceTo(I),
          r = e.projectionMatrix.elements,
          s = n.projectionMatrix.elements,
          a = r[14] / (r[10] - 1),
          o = r[14] / (r[10] + 1),
          l = (r[9] + 1) / r[5],
          c = (r[9] - 1) / r[5],
          h = (r[8] - 1) / r[0],
          u = (s[8] + 1) / s[0],
          d = a * h,
          p = a * u,
          m = i / (-h + u),
          f = m * -h;
        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
        var g = a + m,
          _ = o + m,
          v = d - f,
          x = p + (i - f),
          y = l * o / _ * g,
          M = c * o / _ * g;
        t.projectionMatrix.makePerspective(v, x, y, M, g, _), t.projectionMatrixInverse.copy(t.projectionMatrix).invert();
      }(T, S, b) : T.projectionMatrix.copy(S.projectionMatrix), function (t, e, n) {
        null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld), t.matrix.invert(), t.matrix.multiply(e.matrixWorld));
        t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(!0), t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse), t.isPerspectiveCamera && (t.fov = 2 * Gn * Math.atan(1 / t.projectionMatrix.elements[5]), t.zoom = 1);
      }(t, T, e);
    }, _this29.getCamera = function () {
      return T;
    }, _this29.getFoveation = function () {
      if (null !== u || null !== d) return o;
    }, _this29.setFoveation = function (t) {
      o = t, null !== u && (u.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t);
    }, _this29.hasDepthSensing = function () {
      return null !== m.texture;
    };
    var N = null;
    var D = new pa();
    D.setAnimationLoop(function (e, r) {
      if (c = r.getViewerPose(l || s), p = r, null !== c) {
        var _e120 = c.views;
        null !== d && (t.setRenderTargetFramebuffer(_, d.framebuffer), t.setRenderTarget(_));
        var _n111 = !1;
        _e120.length !== T.cameras.length && (T.cameras.length = 0, _n111 = !0);
        for (var _i108 = 0; _i108 < _e120.length; _i108++) {
          var _r73 = _e120[_i108];
          var _s39 = null;
          if (null !== d) _s39 = d.getViewport(_r73);else {
            var _e121 = h.getViewSubImage(u, _r73);
            _s39 = _e121.viewport, 0 === _i108 && (t.setRenderTargetTextures(_, _e121.colorTexture, u.ignoreDepthValues ? void 0 : _e121.depthStencilTexture), t.setRenderTarget(_));
          }
          var _a34 = E[_i108];
          void 0 === _a34 && (_a34 = new ea(), _a34.layers.enable(_i108), _a34.viewport = new bi(), E[_i108] = _a34), _a34.matrix.fromArray(_r73.transform.matrix), _a34.matrix.decompose(_a34.position, _a34.quaternion, _a34.scale), _a34.projectionMatrix.fromArray(_r73.projectionMatrix), _a34.projectionMatrixInverse.copy(_a34.projectionMatrix).invert(), _a34.viewport.set(_s39.x, _s39.y, _s39.width, _s39.height), 0 === _i108 && (T.matrix.copy(_a34.matrix), T.matrix.decompose(T.position, T.quaternion, T.scale)), !0 === _n111 && T.cameras.push(_a34);
        }
        var _r74 = i.enabledFeatures;
        if (_r74 && _r74.includes("depth-sensing")) {
          var _n112 = h.getDepthInformation(_e120[0]);
          _n112 && _n112.isValid && _n112.texture && m.init(t, _n112, i.renderState);
        }
      }
      for (var _t138 = 0; _t138 < v.length; _t138++) {
        var _e122 = x[_t138],
          _n113 = v[_t138];
        null !== _e122 && void 0 !== _n113 && _n113.update(_e122, r, l || s);
      }
      m.render(t, T), N && N(e, r), r.detectedPlanes && n.dispatchEvent({
        type: "planesdetected",
        data: r
      }), p = null;
    }), _this29.setAnimationLoop = function (t) {
      N = t;
    }, _this29.dispose = function () {};
    return _this29;
  }
  _inherits(Zl, _zn6);
  return _createClass(Zl);
}(zn);
function Jl(t, e) {
  function n(t, e) {
    !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix);
  }
  function i(i, r) {
    i.opacity.value = r.opacity, r.color && i.diffuse.value.copy(r.color), r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (i.map.value = r.map, n(r.map, i.mapTransform)), r.alphaMap && (i.alphaMap.value = r.alphaMap, n(r.alphaMap, i.alphaMapTransform)), r.bumpMap && (i.bumpMap.value = r.bumpMap, n(r.bumpMap, i.bumpMapTransform), i.bumpScale.value = r.bumpScale, r.side === d && (i.bumpScale.value *= -1)), r.normalMap && (i.normalMap.value = r.normalMap, n(r.normalMap, i.normalMapTransform), i.normalScale.value.copy(r.normalScale), r.side === d && i.normalScale.value.negate()), r.displacementMap && (i.displacementMap.value = r.displacementMap, n(r.displacementMap, i.displacementMapTransform), i.displacementScale.value = r.displacementScale, i.displacementBias.value = r.displacementBias), r.emissiveMap && (i.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, i.emissiveMapTransform)), r.specularMap && (i.specularMap.value = r.specularMap, n(r.specularMap, i.specularMapTransform)), r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
    var s = e.get(r).envMap;
    if (s && (i.envMap.value = s, i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = r.reflectivity, i.ior.value = r.ior, i.refractionRatio.value = r.refractionRatio), r.lightMap) {
      i.lightMap.value = r.lightMap;
      var _e123 = !0 === t._useLegacyLights ? Math.PI : 1;
      i.lightMapIntensity.value = r.lightMapIntensity * _e123, n(r.lightMap, i.lightMapTransform);
    }
    r.aoMap && (i.aoMap.value = r.aoMap, i.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, i.aoMapTransform));
  }
  return {
    refreshFogUniforms: function refreshFogUniforms(e, n) {
      n.color.getRGB(e.fogColor.value, Ys(t)), n.isFog ? (e.fogNear.value = n.near, e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density);
    },
    refreshMaterialUniforms: function refreshMaterialUniforms(t, r, s, a, o) {
      r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(t, r) : r.isMeshToonMaterial ? (i(t, r), function (t, e) {
        e.gradientMap && (t.gradientMap.value = e.gradientMap);
      }(t, r)) : r.isMeshPhongMaterial ? (i(t, r), function (t, e) {
        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4);
      }(t, r)) : r.isMeshStandardMaterial ? (i(t, r), function (t, i) {
        t.metalness.value = i.metalness, i.metalnessMap && (t.metalnessMap.value = i.metalnessMap, n(i.metalnessMap, t.metalnessMapTransform));
        t.roughness.value = i.roughness, i.roughnessMap && (t.roughnessMap.value = i.roughnessMap, n(i.roughnessMap, t.roughnessMapTransform));
        var r = e.get(i).envMap;
        r && (t.envMapIntensity.value = i.envMapIntensity);
      }(t, r), r.isMeshPhysicalMaterial && function (t, e, i) {
        t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap, n(e.sheenColorMap, t.sheenColorMapTransform)), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap, n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform)));
        e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap, n(e.clearcoatMap, t.clearcoatMapTransform)), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap, n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform), t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), e.side === d && t.clearcoatNormalScale.value.negate()));
        e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap, n(e.iridescenceMap, t.iridescenceMapTransform)), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap, n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform)));
        e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap, n(e.transmissionMap, t.transmissionMapTransform)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap, n(e.thicknessMap, t.thicknessMapTransform)), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor));
        e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap, n(e.anisotropyMap, t.anisotropyMapTransform)));
        t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap, n(e.specularColorMap, t.specularColorMapTransform));
        e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap, n(e.specularIntensityMap, t.specularIntensityMapTransform));
      }(t, r, o)) : r.isMeshMatcapMaterial ? (i(t, r), function (t, e) {
        e.matcap && (t.matcap.value = e.matcap);
      }(t, r)) : r.isMeshDepthMaterial ? i(t, r) : r.isMeshDistanceMaterial ? (i(t, r), function (t, n) {
        var i = e.get(n).light;
        t.referencePosition.value.setFromMatrixPosition(i.matrixWorld), t.nearDistance.value = i.shadow.camera.near, t.farDistance.value = i.shadow.camera.far;
      }(t, r)) : r.isMeshNormalMaterial ? i(t, r) : r.isLineBasicMaterial ? (function (t, e) {
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, e.map && (t.map.value = e.map, n(e.map, t.mapTransform));
      }(t, r), r.isLineDashedMaterial && function (t, e) {
        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale;
      }(t, r)) : r.isPointsMaterial ? function (t, e, i, r) {
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * r, e.map && (t.map.value = e.map, n(e.map, t.uvTransform));
        e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform));
        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
      }(t, r, s, a) : r.isSpriteMaterial ? function (t, e) {
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map, n(e.map, t.mapTransform));
        e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform));
        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
      }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
    }
  };
}
function Kl(t, e, n, i) {
  var r = {},
    s = {},
    a = [];
  var o = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(t, e, n, i) {
    var r = t.value,
      s = e + "_" + n;
    if (void 0 === i[s]) return i[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0;
    {
      var _t139 = i[s];
      if ("number" == typeof r || "boolean" == typeof r) {
        if (_t139 !== r) return i[s] = r, !0;
      } else if (!1 === _t139.equals(r)) return _t139.copy(r), !0;
    }
    return !1;
  }
  function c(t) {
    var e = {
      boundary: 0,
      storage: 0
    };
    return "number" == typeof t || "boolean" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), e;
  }
  function h(e) {
    var n = e.target;
    n.removeEventListener("dispose", h);
    var i = a.indexOf(n.__bindingPointIndex);
    a.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id];
  }
  return {
    bind: function bind(t, e) {
      var n = e.program;
      i.uniformBlockBinding(t, n);
    },
    update: function update(n, u) {
      var d = r[n.id];
      void 0 === d && (!function (t) {
        var e = t.uniforms;
        var n = 0;
        var i = 16;
        for (var _t140 = 0, _r75 = e.length; _t140 < _r75; _t140++) {
          var _r76 = Array.isArray(e[_t140]) ? e[_t140] : [e[_t140]];
          for (var _t141 = 0, _e124 = _r76.length; _t141 < _e124; _t141++) {
            var _e125 = _r76[_t141],
              _s40 = Array.isArray(_e125.value) ? _e125.value : [_e125.value];
            for (var _t142 = 0, _r77 = _s40.length; _t142 < _r77; _t142++) {
              var _r78 = c(_s40[_t142]),
                _a35 = n % i;
              0 !== _a35 && i - _a35 < _r78.boundary && (n += i - _a35), _e125.__data = new Float32Array(_r78.storage / Float32Array.BYTES_PER_ELEMENT), _e125.__offset = n, n += _r78.storage;
            }
          }
        }
        var r = n % i;
        r > 0 && (n += i - r);
        t.__size = n, t.__cache = {};
      }(n), d = function (e) {
        var n = function () {
          for (var _t143 = 0; _t143 < o; _t143++) if (-1 === a.indexOf(_t143)) return a.push(_t143), _t143;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }();
        e.__bindingPointIndex = n;
        var i = t.createBuffer(),
          r = e.__size,
          s = e.usage;
        return t.bindBuffer(t.UNIFORM_BUFFER, i), t.bufferData(t.UNIFORM_BUFFER, r, s), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, n, i), i;
      }(n), r[n.id] = d, n.addEventListener("dispose", h));
      var p = u.program;
      i.updateUBOMapping(n, p);
      var m = e.render.frame;
      s[n.id] !== m && (!function (e) {
        var n = r[e.id],
          i = e.uniforms,
          s = e.__cache;
        t.bindBuffer(t.UNIFORM_BUFFER, n);
        for (var _e126 = 0, _n114 = i.length; _e126 < _n114; _e126++) {
          var _n115 = Array.isArray(i[_e126]) ? i[_e126] : [i[_e126]];
          for (var _i109 = 0, _r79 = _n115.length; _i109 < _r79; _i109++) {
            var _r80 = _n115[_i109];
            if (!0 === l(_r80, _e126, _i109, s)) {
              var _e127 = _r80.__offset,
                _n116 = Array.isArray(_r80.value) ? _r80.value : [_r80.value];
              var _i110 = 0;
              for (var _s41 = 0; _s41 < _n116.length; _s41++) {
                var _a36 = _n116[_s41],
                  _o25 = c(_a36);
                "number" == typeof _a36 || "boolean" == typeof _a36 ? (_r80.__data[0] = _a36, t.bufferSubData(t.UNIFORM_BUFFER, _e127 + _i110, _r80.__data)) : _a36.isMatrix3 ? (_r80.__data[0] = _a36.elements[0], _r80.__data[1] = _a36.elements[1], _r80.__data[2] = _a36.elements[2], _r80.__data[3] = 0, _r80.__data[4] = _a36.elements[3], _r80.__data[5] = _a36.elements[4], _r80.__data[6] = _a36.elements[5], _r80.__data[7] = 0, _r80.__data[8] = _a36.elements[6], _r80.__data[9] = _a36.elements[7], _r80.__data[10] = _a36.elements[8], _r80.__data[11] = 0) : (_a36.toArray(_r80.__data, _i110), _i110 += _o25.storage / Float32Array.BYTES_PER_ELEMENT);
              }
              t.bufferSubData(t.UNIFORM_BUFFER, _e127, _r80.__data);
            }
          }
        }
        t.bindBuffer(t.UNIFORM_BUFFER, null);
      }(n), s[n.id] = m);
    },
    dispose: function dispose() {
      for (var _e128 in r) t.deleteBuffer(r[_e128]);
      a = [], r = {}, s = {};
    }
  };
}
var $l = exports.WebGLRenderer = /*#__PURE__*/function () {
  function $l() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, $l);
    var _e$canvas = e.canvas,
      n = _e$canvas === void 0 ? ai() : _e$canvas,
      _e$context = e.context,
      i = _e$context === void 0 ? null : _e$context,
      _e$depth = e.depth,
      r = _e$depth === void 0 ? !0 : _e$depth,
      _e$stencil = e.stencil,
      s = _e$stencil === void 0 ? !0 : _e$stencil,
      _e$alpha = e.alpha,
      a = _e$alpha === void 0 ? !1 : _e$alpha,
      _e$antialias = e.antialias,
      o = _e$antialias === void 0 ? !1 : _e$antialias,
      _e$premultipliedAlpha = e.premultipliedAlpha,
      l = _e$premultipliedAlpha === void 0 ? !0 : _e$premultipliedAlpha,
      _e$preserveDrawingBuf = e.preserveDrawingBuffer,
      c = _e$preserveDrawingBuf === void 0 ? !1 : _e$preserveDrawingBuf,
      _e$powerPreference = e.powerPreference,
      h = _e$powerPreference === void 0 ? "default" : _e$powerPreference,
      _e$failIfMajorPerform = e.failIfMajorPerformanceCaveat,
      p = _e$failIfMajorPerform === void 0 ? !1 : _e$failIfMajorPerform;
    var m;
    this.isWebGLRenderer = !0, m = null !== i ? i.getContextAttributes().alpha : a;
    var f = new Uint32Array(4),
      g = new Int32Array(4);
    var _ = null,
      v = null;
    var x = [],
      y = [];
    this.domElement = n, this.debug = {
      checkShaderErrors: !0,
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = je, this._useLegacyLights = !1, this.toneMapping = K, this.toneMappingExposure = 1;
    var M = this;
    var S = !1,
      b = 0,
      E = 0,
      T = null,
      w = -1,
      A = null;
    var R = new bi(),
      C = new bi();
    var P = null;
    var L = new Zr(0);
    var I = 0,
      U = n.width,
      N = n.height,
      D = 1,
      O = null,
      F = null;
    var B = new bi(0, 0, U, N),
      z = new bi(0, 0, U, N);
    var H = !1;
    var V = new da();
    var k = !1,
      G = !1,
      W = null;
    var X = new lr(),
      j = new Qn(),
      q = new Ii(),
      Y = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
      };
    function Z() {
      return null === T ? D : 1;
    }
    var J,
      $,
      Q,
      tt,
      et,
      nt,
      it,
      rt,
      st,
      at,
      ot,
      lt,
      ct,
      ht,
      ut,
      dt,
      pt,
      mt,
      ft,
      gt,
      _t,
      vt,
      xt,
      yt,
      Mt = i;
    function St(t, e) {
      for (var _i111 = 0; _i111 < t.length; _i111++) {
        var _r81 = t[_i111],
          _s42 = n.getContext(_r81, e);
        if (null !== _s42) return _s42;
      }
      return null;
    }
    try {
      var _e129 = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: p
      };
      if ("setAttribute" in n && n.setAttribute("data-engine", "three.js r".concat(t)), n.addEventListener("webglcontextlost", At, !1), n.addEventListener("webglcontextrestored", Ct, !1), n.addEventListener("webglcontextcreationerror", Ot, !1), null === Mt) {
        var _t144 = ["webgl2", "webgl", "experimental-webgl"];
        if (!0 === M.isWebGL1Renderer && _t144.shift(), Mt = St(_t144, _e129), null === Mt) throw St(_t144) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      "undefined" != typeof WebGLRenderingContext && Mt instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === Mt.getShaderPrecisionFormat && (Mt.getShaderPrecisionFormat = function () {
        return {
          rangeMin: 1,
          rangeMax: 1,
          precision: 1
        };
      });
    } catch (t) {
      throw console.error("THREE.WebGLRenderer: " + t.message), t;
    }
    function Et() {
      J = new Wa(Mt), $ = new ba(Mt, J, e), J.init($), vt = new Gl(Mt, J, $), Q = new Vl(Mt, J, $), tt = new qa(Mt), et = new Al(), nt = new kl(Mt, J, Q, et, $, vt, tt), it = new Ta(M), rt = new Ga(M), st = new ma(Mt, $), xt = new Ma(Mt, J, st, $), at = new Xa(Mt, st, tt, xt), ot = new Ka(Mt, at, st, tt), ft = new Ja(Mt, $, nt), dt = new Ea(et), lt = new wl(M, it, rt, J, $, xt, dt), ct = new Jl(M, et), ht = new Ll(), ut = new Fl(J, $), mt = new ya(M, it, rt, Q, ot, m, l), pt = new Hl(M, ot, $), yt = new Kl(Mt, tt, $, Q), gt = new Sa(Mt, J, tt, $), _t = new ja(Mt, J, tt, $), tt.programs = lt.programs, M.capabilities = $, M.extensions = J, M.properties = et, M.renderLists = ht, M.shadowMap = pt, M.state = Q, M.info = tt;
    }
    Et();
    var wt = new Zl(M, Mt);
    function At(t) {
      t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = !0;
    }
    function Ct() {
      console.log("THREE.WebGLRenderer: Context Restored."), S = !1;
      var t = tt.autoReset,
        e = pt.enabled,
        n = pt.autoUpdate,
        i = pt.needsUpdate,
        r = pt.type;
      Et(), tt.autoReset = t, pt.enabled = e, pt.autoUpdate = n, pt.needsUpdate = i, pt.type = r;
    }
    function Ot(t) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage);
    }
    function Bt(t) {
      var e = t.target;
      e.removeEventListener("dispose", Bt), function (t) {
        (function (t) {
          var e = et.get(t).programs;
          void 0 !== e && (e.forEach(function (t) {
            lt.releaseProgram(t);
          }), t.isShaderMaterial && lt.releaseShaderCache(t));
        })(t), et.remove(t);
      }(e);
    }
    function zt(t, e, n) {
      !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass ? (t.side = d, t.needsUpdate = !0, Kt(t, e, n), t.side = u, t.needsUpdate = !0, Kt(t, e, n), t.side = 2) : Kt(t, e, n);
    }
    this.xr = wt, this.getContext = function () {
      return Mt;
    }, this.getContextAttributes = function () {
      return Mt.getContextAttributes();
    }, this.forceContextLoss = function () {
      var t = J.get("WEBGL_lose_context");
      t && t.loseContext();
    }, this.forceContextRestore = function () {
      var t = J.get("WEBGL_lose_context");
      t && t.restoreContext();
    }, this.getPixelRatio = function () {
      return D;
    }, this.setPixelRatio = function (t) {
      void 0 !== t && (D = t, this.setSize(U, N, !1));
    }, this.getSize = function (t) {
      return t.set(U, N);
    }, this.setSize = function (t, e) {
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      wt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (U = t, N = e, n.width = Math.floor(t * D), n.height = Math.floor(e * D), !0 === i && (n.style.width = t + "px", n.style.height = e + "px"), this.setViewport(0, 0, t, e));
    }, this.getDrawingBufferSize = function (t) {
      return t.set(U * D, N * D).floor();
    }, this.setDrawingBufferSize = function (t, e, i) {
      U = t, N = e, D = i, n.width = Math.floor(t * i), n.height = Math.floor(e * i), this.setViewport(0, 0, t, e);
    }, this.getCurrentViewport = function (t) {
      return t.copy(R);
    }, this.getViewport = function (t) {
      return t.copy(B);
    }, this.setViewport = function (t, e, n, i) {
      t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i), Q.viewport(R.copy(B).multiplyScalar(D).floor());
    }, this.getScissor = function (t) {
      return t.copy(z);
    }, this.setScissor = function (t, e, n, i) {
      t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, n, i), Q.scissor(C.copy(z).multiplyScalar(D).floor());
    }, this.getScissorTest = function () {
      return H;
    }, this.setScissorTest = function (t) {
      Q.setScissorTest(H = t);
    }, this.setOpaqueSort = function (t) {
      O = t;
    }, this.setTransparentSort = function (t) {
      F = t;
    }, this.getClearColor = function (t) {
      return t.copy(mt.getClearColor());
    }, this.setClearColor = function () {
      mt.setClearColor.apply(mt, arguments);
    }, this.getClearAlpha = function () {
      return mt.getClearAlpha();
    }, this.setClearAlpha = function () {
      mt.setClearAlpha.apply(mt, arguments);
    }, this.clear = function () {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      var i = 0;
      if (t) {
        var _t145 = !1;
        if (null !== T) {
          var _e130 = T.texture.format;
          _t145 = _e130 === jt || _e130 === Xt || _e130 === Gt;
        }
        if (_t145) {
          var _t146 = T.texture.type,
            _e131 = _t146 === Tt || _t146 === Pt || _t146 === Rt || _t146 === Dt || _t146 === Ut || _t146 === Nt,
            _n117 = mt.getClearColor(),
            _i112 = mt.getClearAlpha(),
            _r82 = _n117.r,
            _s43 = _n117.g,
            _a37 = _n117.b;
          _e131 ? (f[0] = _r82, f[1] = _s43, f[2] = _a37, f[3] = _i112, Mt.clearBufferuiv(Mt.COLOR, 0, f)) : (g[0] = _r82, g[1] = _s43, g[2] = _a37, g[3] = _i112, Mt.clearBufferiv(Mt.COLOR, 0, g));
        } else i |= Mt.COLOR_BUFFER_BIT;
      }
      e && (i |= Mt.DEPTH_BUFFER_BIT), n && (i |= Mt.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Mt.clear(i);
    }, this.clearColor = function () {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }, this.dispose = function () {
      n.removeEventListener("webglcontextlost", At, !1), n.removeEventListener("webglcontextrestored", Ct, !1), n.removeEventListener("webglcontextcreationerror", Ot, !1), ht.dispose(), ut.dispose(), et.dispose(), it.dispose(), rt.dispose(), ot.dispose(), xt.dispose(), yt.dispose(), lt.dispose(), wt.dispose(), wt.removeEventListener("sessionstart", Vt), wt.removeEventListener("sessionend", kt), W && (W.dispose(), W = null), Wt.stop();
    }, this.renderBufferDirect = function (t, e, n, i, r, s) {
      null === e && (e = Y);
      var a = r.isMesh && r.matrixWorld.determinant() < 0,
        o = function (t, e, n, i, r) {
          !0 !== e.isScene && (e = Y);
          nt.resetTextureUnits();
          var s = e.fog,
            a = i.isMeshStandardMaterial ? e.environment : null,
            o = null === T ? M.outputColorSpace : !0 === T.isXRRenderTarget ? T.texture.colorSpace : qe,
            l = (i.isMeshStandardMaterial ? rt : it).get(i.envMap || a),
            c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
            h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
            u = !!n.morphAttributes.position,
            d = !!n.morphAttributes.normal,
            p = !!n.morphAttributes.color;
          var m = K;
          i.toneMapped && (null !== T && !0 !== T.isXRRenderTarget || (m = M.toneMapping));
          var f = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
            g = void 0 !== f ? f.length : 0,
            _ = et.get(i),
            x = v.state.lights;
          if (!0 === k && (!0 === G || t !== A)) {
            var _e132 = t === A && i.id === w;
            dt.setState(i, t, _e132);
          }
          var y = !1;
          i.version === _.__version ? _.needsLights && _.lightsStateVersion !== x.state.version || _.outputColorSpace !== o || r.isBatchedMesh && !1 === _.batching ? y = !0 : r.isBatchedMesh || !0 !== _.batching ? r.isInstancedMesh && !1 === _.instancing ? y = !0 : r.isInstancedMesh || !0 !== _.instancing ? r.isSkinnedMesh && !1 === _.skinning ? y = !0 : r.isSkinnedMesh || !0 !== _.skinning ? r.isInstancedMesh && !0 === _.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === _.instancingColor && null !== r.instanceColor || _.envMap !== l || !0 === i.fog && _.fog !== s ? y = !0 : void 0 === _.numClippingPlanes || _.numClippingPlanes === dt.numPlanes && _.numIntersection === dt.numIntersection ? (_.vertexAlphas !== c || _.vertexTangents !== h || _.morphTargets !== u || _.morphNormals !== d || _.morphColors !== p || _.toneMapping !== m || !0 === $.isWebGL2 && _.morphTargetsCount !== g) && (y = !0) : y = !0 : y = !0 : y = !0 : y = !0 : (y = !0, _.__version = i.version);
          var S = _.currentProgram;
          !0 === y && (S = Kt(i, e, r));
          var b = !1,
            E = !1,
            R = !1;
          var C = S.getUniforms(),
            P = _.uniforms;
          Q.useProgram(S.program) && (b = !0, E = !0, R = !0);
          i.id !== w && (w = i.id, E = !0);
          if (b || A !== t) {
            C.setValue(Mt, "projectionMatrix", t.projectionMatrix), C.setValue(Mt, "viewMatrix", t.matrixWorldInverse);
            var _e133 = C.map.cameraPosition;
            void 0 !== _e133 && _e133.setValue(Mt, q.setFromMatrixPosition(t.matrixWorld)), $.logarithmicDepthBuffer && C.setValue(Mt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && C.setValue(Mt, "isOrthographic", !0 === t.isOrthographicCamera), A !== t && (A = t, E = !0, R = !0);
          }
          if (r.isSkinnedMesh) {
            C.setOptional(Mt, r, "bindMatrix"), C.setOptional(Mt, r, "bindMatrixInverse");
            var _t147 = r.skeleton;
            _t147 && ($.floatVertexTextures ? (null === _t147.boneTexture && _t147.computeBoneTexture(), C.setValue(Mt, "boneTexture", _t147.boneTexture, nt)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
          }
          r.isBatchedMesh && (C.setOptional(Mt, r, "batchingTexture"), C.setValue(Mt, "batchingTexture", r._matricesTexture, nt));
          var L = n.morphAttributes;
          (void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color && !0 === $.isWebGL2) && ft.update(r, n, S);
          (E || _.receiveShadow !== r.receiveShadow) && (_.receiveShadow = r.receiveShadow, C.setValue(Mt, "receiveShadow", r.receiveShadow));
          i.isMeshGouraudMaterial && null !== i.envMap && (P.envMap.value = l, P.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
          E && (C.setValue(Mt, "toneMappingExposure", M.toneMappingExposure), _.needsLights && (U = R, (I = P).ambientLightColor.needsUpdate = U, I.lightProbe.needsUpdate = U, I.directionalLights.needsUpdate = U, I.directionalLightShadows.needsUpdate = U, I.pointLights.needsUpdate = U, I.pointLightShadows.needsUpdate = U, I.spotLights.needsUpdate = U, I.spotLightShadows.needsUpdate = U, I.rectAreaLights.needsUpdate = U, I.hemisphereLights.needsUpdate = U), s && !0 === i.fog && ct.refreshFogUniforms(P, s), ct.refreshMaterialUniforms(P, i, D, N, W), rl.upload(Mt, $t(_), P, nt));
          var I, U;
          i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (rl.upload(Mt, $t(_), P, nt), i.uniformsNeedUpdate = !1);
          i.isSpriteMaterial && C.setValue(Mt, "center", r.center);
          if (C.setValue(Mt, "modelViewMatrix", r.modelViewMatrix), C.setValue(Mt, "normalMatrix", r.normalMatrix), C.setValue(Mt, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
            var _t148 = i.uniformsGroups;
            for (var _e134 = 0, _n118 = _t148.length; _e134 < _n118; _e134++) if ($.isWebGL2) {
              var _n119 = _t148[_e134];
              yt.update(_n119, S), yt.bind(_n119, S);
            } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
          }
          return S;
        }(t, e, n, i, r);
      Q.setMaterial(i, a);
      var l = n.index,
        c = 1;
      if (!0 === i.wireframe) {
        if (l = at.getWireframeAttribute(n), void 0 === l) return;
        c = 2;
      }
      var h = n.drawRange,
        u = n.attributes.position;
      var d = h.start * c,
        p = (h.start + h.count) * c;
      null !== s && (d = Math.max(d, s.start * c), p = Math.min(p, (s.start + s.count) * c)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != u && (d = Math.max(d, 0), p = Math.min(p, u.count));
      var m = p - d;
      if (m < 0 || m === 1 / 0) return;
      var f;
      xt.setup(r, i, o, n, l);
      var g = gt;
      if (null !== l && (f = st.get(l), g = _t, g.setIndex(f)), r.isMesh) !0 === i.wireframe ? (Q.setLineWidth(i.wireframeLinewidth * Z()), g.setMode(Mt.LINES)) : g.setMode(Mt.TRIANGLES);else if (r.isLine) {
        var _t149 = i.linewidth;
        void 0 === _t149 && (_t149 = 1), Q.setLineWidth(_t149 * Z()), r.isLineSegments ? g.setMode(Mt.LINES) : r.isLineLoop ? g.setMode(Mt.LINE_LOOP) : g.setMode(Mt.LINE_STRIP);
      } else r.isPoints ? g.setMode(Mt.POINTS) : r.isSprite && g.setMode(Mt.TRIANGLES);
      if (r.isBatchedMesh) g.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);else if (r.isInstancedMesh) g.renderInstances(d, m, r.count);else if (n.isInstancedBufferGeometry) {
        var _t150 = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
          _e135 = Math.min(n.instanceCount, _t150);
        g.renderInstances(d, m, _e135);
      } else g.render(d, m);
    }, this.compile = function (t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      null === n && (n = t), v = ut.get(n), v.init(), y.push(v), n.traverseVisible(function (t) {
        t.isLight && t.layers.test(e.layers) && (v.pushLight(t), t.castShadow && v.pushShadow(t));
      }), t !== n && t.traverseVisible(function (t) {
        t.isLight && t.layers.test(e.layers) && (v.pushLight(t), t.castShadow && v.pushShadow(t));
      }), v.setupLights(M._useLegacyLights);
      var i = new Set();
      return t.traverse(function (t) {
        var e = t.material;
        if (e) if (Array.isArray(e)) for (var _r83 = 0; _r83 < e.length; _r83++) {
          var _s44 = e[_r83];
          zt(_s44, n, t), i.add(_s44);
        } else zt(e, n, t), i.add(e);
      }), y.pop(), v = null, i;
    }, this.compileAsync = function (t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var i = this.compile(t, e, n);
      return new Promise(function (e) {
        function n() {
          i.forEach(function (t) {
            et.get(t).currentProgram.isReady() && i.delete(t);
          }), 0 !== i.size ? setTimeout(n, 10) : e(t);
        }
        null !== J.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10);
      });
    };
    var Ht = null;
    function Vt() {
      Wt.stop();
    }
    function kt() {
      Wt.start();
    }
    var Wt = new pa();
    function qt(t, e, n, i) {
      if (!1 === t.visible) return;
      if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder;else if (t.isLOD) !0 === t.autoUpdate && t.update(e);else if (t.isLight) v.pushLight(t), t.castShadow && v.pushShadow(t);else if (t.isSprite) {
        if (!t.frustumCulled || V.intersectsSprite(t)) {
          i && q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(X);
          var _e136 = ot.update(t),
            _r84 = t.material;
          _r84.visible && _.push(t, _e136, _r84, n, q.z, null);
        }
      } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || V.intersectsObject(t))) {
        var _e137 = ot.update(t),
          _r85 = t.material;
        if (i && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(), q.copy(t.boundingSphere.center)) : (null === _e137.boundingSphere && _e137.computeBoundingSphere(), q.copy(_e137.boundingSphere.center)), q.applyMatrix4(t.matrixWorld).applyMatrix4(X)), Array.isArray(_r85)) {
          var _i113 = _e137.groups;
          for (var _s45 = 0, _a38 = _i113.length; _s45 < _a38; _s45++) {
            var _a39 = _i113[_s45],
              _o26 = _r85[_a39.materialIndex];
            _o26 && _o26.visible && _.push(t, _e137, _o26, n, q.z, _a39);
          }
        } else _r85.visible && _.push(t, _e137, _r85, n, q.z, null);
      }
      var r = t.children;
      for (var _t151 = 0, _s46 = r.length; _t151 < _s46; _t151++) qt(r[_t151], e, n, i);
    }
    function Yt(t, e, n, i) {
      var r = t.opaque,
        s = t.transmissive,
        a = t.transparent;
      v.setupLightsView(n), !0 === k && dt.setGlobalState(M.clippingPlanes, n), s.length > 0 && function (t, e, n, i) {
        var r = !0 === n.isScene ? n.overrideMaterial : null;
        if (null !== r) return;
        var s = $.isWebGL2;
        null === W && (W = new Ti(1, 1, {
          generateMipmaps: !0,
          type: J.has("EXT_color_buffer_half_float") ? It : Tt,
          minFilter: bt,
          samples: s ? 4 : 0
        }));
        M.getDrawingBufferSize(j), s ? W.setSize(j.x, j.y) : W.setSize(Zn(j.x), Zn(j.y));
        var a = M.getRenderTarget();
        M.setRenderTarget(W), M.getClearColor(L), I = M.getClearAlpha(), I < 1 && M.setClearColor(16777215, .5);
        M.clear();
        var o = M.toneMapping;
        M.toneMapping = K, Zt(t, n, i), nt.updateMultisampleRenderTarget(W), nt.updateRenderTargetMipmap(W);
        var l = !1;
        for (var _t152 = 0, _r86 = e.length; _t152 < _r86; _t152++) {
          var _r87 = e[_t152],
            _s47 = _r87.object,
            _a40 = _r87.geometry,
            _o27 = _r87.material,
            _c14 = _r87.group;
          if (2 === _o27.side && _s47.layers.test(i.layers)) {
            var _t153 = _o27.side;
            _o27.side = d, _o27.needsUpdate = !0, Jt(_s47, n, i, _a40, _o27, _c14), _o27.side = _t153, _o27.needsUpdate = !0, l = !0;
          }
        }
        !0 === l && (nt.updateMultisampleRenderTarget(W), nt.updateRenderTargetMipmap(W));
        M.setRenderTarget(a), M.setClearColor(L, I), M.toneMapping = o;
      }(r, s, e, n), i && Q.viewport(R.copy(i)), r.length > 0 && Zt(r, e, n), s.length > 0 && Zt(s, e, n), a.length > 0 && Zt(a, e, n), Q.buffers.depth.setTest(!0), Q.buffers.depth.setMask(!0), Q.buffers.color.setMask(!0), Q.setPolygonOffset(!1);
    }
    function Zt(t, e, n) {
      var i = !0 === e.isScene ? e.overrideMaterial : null;
      for (var _r88 = 0, _s48 = t.length; _r88 < _s48; _r88++) {
        var _s49 = t[_r88],
          _a41 = _s49.object,
          _o28 = _s49.geometry,
          _l14 = null === i ? _s49.material : i,
          _c15 = _s49.group;
        _a41.layers.test(n.layers) && Jt(_a41, e, n, _o28, _l14, _c15);
      }
    }
    function Jt(t, e, n, i, r, s) {
      t.onBeforeRender(M, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(M, e, n, i, t, s), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = d, r.needsUpdate = !0, M.renderBufferDirect(n, e, i, r, t, s), r.side = u, r.needsUpdate = !0, M.renderBufferDirect(n, e, i, r, t, s), r.side = 2) : M.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(M, e, n, i, r, s);
    }
    function Kt(t, e, n) {
      !0 !== e.isScene && (e = Y);
      var i = et.get(t),
        r = v.state.lights,
        s = v.state.shadowsArray,
        a = r.state.version,
        o = lt.getParameters(t, r.state, s, e, n),
        l = lt.getProgramCacheKey(o);
      var c = i.programs;
      i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? rt : it).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Bt), c = new Map(), i.programs = c);
      var h = c.get(l);
      if (void 0 !== h) {
        if (i.currentProgram === h && i.lightsStateVersion === a) return Qt(t, o), h;
      } else o.uniforms = lt.getUniforms(t), t.onBuild(n, o, M), t.onBeforeCompile(o, M), h = lt.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
      var u = i.uniforms;
      return (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = dt.uniform), Qt(t, o), i.needsLights = function (t) {
        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights;
      }(t), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotLightMatrix.value = r.state.spotLightMatrix, u.spotLightMap.value = r.state.spotLightMap, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix), i.currentProgram = h, i.uniformsList = null, h;
    }
    function $t(t) {
      if (null === t.uniformsList) {
        var _e138 = t.currentProgram.getUniforms();
        t.uniformsList = rl.seqWithValue(_e138.seq, t.uniforms);
      }
      return t.uniformsList;
    }
    function Qt(t, e) {
      var n = et.get(t);
      n.outputColorSpace = e.outputColorSpace, n.batching = e.batching, n.instancing = e.instancing, n.instancingColor = e.instancingColor, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping;
    }
    Wt.setAnimationLoop(function (t) {
      Ht && Ht(t);
    }), "undefined" != typeof self && Wt.setContext(self), this.setAnimationLoop = function (t) {
      Ht = t, wt.setAnimationLoop(t), null === t ? Wt.stop() : Wt.start();
    }, wt.addEventListener("sessionstart", Vt), wt.addEventListener("sessionend", kt), this.render = function (t, e) {
      if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      if (!0 === S) return;
      !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === wt.enabled && !0 === wt.isPresenting && (!0 === wt.cameraAutoUpdate && wt.updateCamera(e), e = wt.getCamera()), !0 === t.isScene && t.onBeforeRender(M, t, e, T), v = ut.get(t, y.length), v.init(), y.push(v), X.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), V.setFromProjectionMatrix(X), G = this.localClippingEnabled, k = dt.init(this.clippingPlanes, G), _ = ht.get(t, x.length), _.init(), x.push(_), qt(t, e, 0, M.sortObjects), _.finish(), !0 === M.sortObjects && _.sort(O, F), this.info.render.frame++, !0 === k && dt.beginShadows();
      var n = v.state.shadowsArray;
      if (pt.render(n, t, e), !0 === k && dt.endShadows(), !0 === this.info.autoReset && this.info.reset(), !1 !== wt.enabled && !1 !== wt.isPresenting && !1 !== wt.hasDepthSensing() || mt.render(_, t), v.setupLights(M._useLegacyLights), e.isArrayCamera) {
        var _n120 = e.cameras;
        for (var _e139 = 0, _i114 = _n120.length; _e139 < _i114; _e139++) {
          var _i115 = _n120[_e139];
          Yt(_, t, _i115, _i115.viewport);
        }
      } else Yt(_, t, e);
      null !== T && (nt.updateMultisampleRenderTarget(T), nt.updateRenderTargetMipmap(T)), !0 === t.isScene && t.onAfterRender(M, t, e), xt.resetDefaultState(), w = -1, A = null, y.pop(), v = y.length > 0 ? y[y.length - 1] : null, x.pop(), _ = x.length > 0 ? x[x.length - 1] : null;
    }, this.getActiveCubeFace = function () {
      return b;
    }, this.getActiveMipmapLevel = function () {
      return E;
    }, this.getRenderTarget = function () {
      return T;
    }, this.setRenderTargetTextures = function (t, e, n) {
      et.get(t.texture).__webglTexture = e, et.get(t.depthTexture).__webglTexture = n;
      var i = et.get(t);
      i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === J.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function (t, e) {
      var n = et.get(t);
      n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e;
    }, this.setRenderTarget = function (t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      T = t, b = e, E = n;
      var i = !0,
        r = null,
        s = !1,
        a = !1;
      if (t) {
        var _o29 = et.get(t);
        void 0 !== _o29.__useDefaultFramebuffer ? (Q.bindFramebuffer(Mt.FRAMEBUFFER, null), i = !1) : void 0 === _o29.__webglFramebuffer ? nt.setupRenderTarget(t) : _o29.__hasExternalTextures && nt.rebindTextures(t, et.get(t.texture).__webglTexture, et.get(t.depthTexture).__webglTexture);
        var _l15 = t.texture;
        (_l15.isData3DTexture || _l15.isDataArrayTexture || _l15.isCompressedArrayTexture) && (a = !0);
        var _c16 = et.get(t).__webglFramebuffer;
        t.isWebGLCubeRenderTarget ? (r = Array.isArray(_c16[e]) ? _c16[e][n] : _c16[e], s = !0) : r = $.isWebGL2 && t.samples > 0 && !1 === nt.useMultisampledRTT(t) ? et.get(t).__webglMultisampledFramebuffer : Array.isArray(_c16) ? _c16[n] : _c16, R.copy(t.viewport), C.copy(t.scissor), P = t.scissorTest;
      } else R.copy(B).multiplyScalar(D).floor(), C.copy(z).multiplyScalar(D).floor(), P = H;
      if (Q.bindFramebuffer(Mt.FRAMEBUFFER, r) && $.drawBuffers && i && Q.drawBuffers(t, r), Q.viewport(R), Q.scissor(C), Q.setScissorTest(P), s) {
        var _i116 = et.get(t.texture);
        Mt.framebufferTexture2D(Mt.FRAMEBUFFER, Mt.COLOR_ATTACHMENT0, Mt.TEXTURE_CUBE_MAP_POSITIVE_X + e, _i116.__webglTexture, n);
      } else if (a) {
        var _i117 = et.get(t.texture),
          _r89 = e || 0;
        Mt.framebufferTextureLayer(Mt.FRAMEBUFFER, Mt.COLOR_ATTACHMENT0, _i117.__webglTexture, n || 0, _r89);
      }
      w = -1;
    }, this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
      if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      var o = et.get(t).__webglFramebuffer;
      if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
        Q.bindFramebuffer(Mt.FRAMEBUFFER, o);
        try {
          var _a42 = t.texture,
            _o30 = _a42.format,
            _l16 = _a42.type;
          if (_o30 !== Ft && vt.convert(_o30) !== Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          var _c17 = _l16 === It && (J.has("EXT_color_buffer_half_float") || $.isWebGL2 && J.has("EXT_color_buffer_float"));
          if (!(_l16 === Tt || vt.convert(_l16) === Mt.getParameter(Mt.IMPLEMENTATION_COLOR_READ_TYPE) || _l16 === Lt && ($.isWebGL2 || J.has("OES_texture_float") || J.has("WEBGL_color_buffer_float")) || _c17)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Mt.readPixels(e, n, i, r, vt.convert(_o30), vt.convert(_l16), s);
        } finally {
          var _t154 = null !== T ? et.get(T).__webglFramebuffer : null;
          Q.bindFramebuffer(Mt.FRAMEBUFFER, _t154);
        }
      }
    }, this.copyFramebufferToTexture = function (t, e) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var i = Math.pow(2, -n),
        r = Math.floor(e.image.width * i),
        s = Math.floor(e.image.height * i);
      nt.setTexture2D(e, 0), Mt.copyTexSubImage2D(Mt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s), Q.unbindTexture();
    }, this.copyTextureToTexture = function (t, e, n) {
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var r = e.image.width,
        s = e.image.height,
        a = vt.convert(n.format),
        o = vt.convert(n.type);
      nt.setTexture2D(n, 0), Mt.pixelStorei(Mt.UNPACK_FLIP_Y_WEBGL, n.flipY), Mt.pixelStorei(Mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), Mt.pixelStorei(Mt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? Mt.texSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? Mt.compressedTexSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : Mt.texSubImage2D(Mt.TEXTURE_2D, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && Mt.generateMipmap(Mt.TEXTURE_2D), Q.unbindTexture();
    }, this.copyTextureToTexture3D = function (t, e, n, i) {
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      if (M.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      var s = t.max.x - t.min.x + 1,
        a = t.max.y - t.min.y + 1,
        o = t.max.z - t.min.z + 1,
        l = vt.convert(i.format),
        c = vt.convert(i.type);
      var h;
      if (i.isData3DTexture) nt.setTexture3D(i, 0), h = Mt.TEXTURE_3D;else {
        if (!i.isDataArrayTexture && !i.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        nt.setTexture2DArray(i, 0), h = Mt.TEXTURE_2D_ARRAY;
      }
      Mt.pixelStorei(Mt.UNPACK_FLIP_Y_WEBGL, i.flipY), Mt.pixelStorei(Mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), Mt.pixelStorei(Mt.UNPACK_ALIGNMENT, i.unpackAlignment);
      var u = Mt.getParameter(Mt.UNPACK_ROW_LENGTH),
        d = Mt.getParameter(Mt.UNPACK_IMAGE_HEIGHT),
        p = Mt.getParameter(Mt.UNPACK_SKIP_PIXELS),
        m = Mt.getParameter(Mt.UNPACK_SKIP_ROWS),
        f = Mt.getParameter(Mt.UNPACK_SKIP_IMAGES),
        g = n.isCompressedTexture ? n.mipmaps[r] : n.image;
      Mt.pixelStorei(Mt.UNPACK_ROW_LENGTH, g.width), Mt.pixelStorei(Mt.UNPACK_IMAGE_HEIGHT, g.height), Mt.pixelStorei(Mt.UNPACK_SKIP_PIXELS, t.min.x), Mt.pixelStorei(Mt.UNPACK_SKIP_ROWS, t.min.y), Mt.pixelStorei(Mt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isData3DTexture ? Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Mt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : Mt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), Mt.pixelStorei(Mt.UNPACK_ROW_LENGTH, u), Mt.pixelStorei(Mt.UNPACK_IMAGE_HEIGHT, d), Mt.pixelStorei(Mt.UNPACK_SKIP_PIXELS, p), Mt.pixelStorei(Mt.UNPACK_SKIP_ROWS, m), Mt.pixelStorei(Mt.UNPACK_SKIP_IMAGES, f), 0 === r && i.generateMipmaps && Mt.generateMipmap(h), Q.unbindTexture();
    }, this.initTexture = function (t) {
      t.isCubeTexture ? nt.setTextureCube(t, 0) : t.isData3DTexture ? nt.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? nt.setTexture2DArray(t, 0) : nt.setTexture2D(t, 0), Q.unbindTexture();
    }, this.resetState = function () {
      b = 0, E = 0, T = null, Q.reset(), xt.reset();
    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
      detail: this
    }));
  }
  return _createClass($l, [{
    key: "coordinateSystem",
    get: function get() {
      return Fn;
    }
  }, {
    key: "outputColorSpace",
    get: function get() {
      return this._outputColorSpace;
    },
    set: function set(t) {
      this._outputColorSpace = t;
      var e = this.getContext();
      e.drawingBufferColorSpace = t === Ye ? "display-p3" : "srgb", e.unpackColorSpace = pi.workingColorSpace === Ze ? "display-p3" : "srgb";
    }
  }, {
    key: "outputEncoding",
    get: function get() {
      return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === je ? He : ze;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = t === He ? je : qe;
    }
  }, {
    key: "useLegacyLights",
    get: function get() {
      return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
    },
    set: function set(t) {
      console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = t;
    }
  }]);
}();
var Ql = exports.WebGL1Renderer = /*#__PURE__*/function (_$l) {
  function Ql() {
    _classCallCheck(this, Ql);
    return _callSuper(this, Ql, arguments);
  }
  _inherits(Ql, _$l);
  return _createClass(Ql);
}($l);
Ql.prototype.isWebGL1Renderer = !0;
var tc = exports.FogExp2 = /*#__PURE__*/function () {
  function tc(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25e-5;
    _classCallCheck(this, tc);
    this.isFogExp2 = !0, this.name = "", this.color = new Zr(t), this.density = e;
  }
  return _createClass(tc, [{
    key: "clone",
    value: function clone() {
      return new tc(this.color, this.density);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "FogExp2",
        name: this.name,
        color: this.color.getHex(),
        density: this.density
      };
    }
  }]);
}();
var ec = exports.Fog = /*#__PURE__*/function () {
  function ec(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e3;
    _classCallCheck(this, ec);
    this.isFog = !0, this.name = "", this.color = new Zr(t), this.near = e, this.far = n;
  }
  return _createClass(ec, [{
    key: "clone",
    value: function clone() {
      return new ec(this.color, this.near, this.far);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "Fog",
        name: this.name,
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  }]);
}();
var nc = exports.Scene = /*#__PURE__*/function (_Ur5) {
  function nc() {
    var _this30;
    _classCallCheck(this, nc);
    _this30 = _callSuper(this, nc), _this30.isScene = !0, _this30.type = "Scene", _this30.background = null, _this30.environment = null, _this30.fog = null, _this30.backgroundBlurriness = 0, _this30.backgroundIntensity = 1, _this30.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
      detail: _assertThisInitialized(_this30)
    }));
    return _this30;
  }
  _inherits(nc, _Ur5);
  return _createClass(nc, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(nc.prototype), "copy", this).call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(nc.prototype), "toJSON", this).call(this, t);
      return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e;
    }
  }]);
}(Ur);
var ic = exports.InterleavedBuffer = /*#__PURE__*/function () {
  function ic(t, e) {
    _classCallCheck(this, ic);
    this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Tn, this._updateRange = {
      offset: 0,
      count: -1
    }, this.updateRanges = [], this.version = 0, this.uuid = Wn();
  }
  return _createClass(ic, [{
    key: "onUploadCallback",
    value: function onUploadCallback() {}
  }, {
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && this.version++;
    }
  }, {
    key: "updateRange",
    get: function get() {
      return li("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
    }
  }, {
    key: "setUsage",
    value: function setUsage(t) {
      return this.usage = t, this;
    }
  }, {
    key: "addUpdateRange",
    value: function addUpdateRange(t, e) {
      this.updateRanges.push({
        start: t,
        count: e
      });
    }
  }, {
    key: "clearUpdateRanges",
    value: function clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(t, e, n) {
      t *= this.stride, n *= e.stride;
      for (var _i118 = 0, _r90 = this.stride; _i118 < _r90; _i118++) this.array[t + _i118] = e.array[n + _i118];
      return this;
    }
  }, {
    key: "set",
    value: function set(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.array.set(t, e), this;
    }
  }, {
    key: "clone",
    value: function clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Wn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      var e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
        n = new this.constructor(e, this.stride);
      return n.setUsage(this.usage), n;
    }
  }, {
    key: "onUpload",
    value: function onUpload(t) {
      return this.onUploadCallback = t, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Wn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }]);
}();
var rc = new Ii();
var sc = exports.InterleavedBufferAttribute = /*#__PURE__*/function () {
  function sc(t, e, n) {
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    _classCallCheck(this, sc);
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = i;
  }
  return _createClass(sc, [{
    key: "count",
    get: function get() {
      return this.data.count;
    }
  }, {
    key: "array",
    get: function get() {
      return this.data.array;
    }
  }, {
    key: "needsUpdate",
    set: function set(t) {
      this.data.needsUpdate = t;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      for (var _e140 = 0, _n121 = this.data.count; _e140 < _n121; _e140++) rc.fromBufferAttribute(this, _e140), rc.applyMatrix4(t), this.setXYZ(_e140, rc.x, rc.y, rc.z);
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(t) {
      for (var _e141 = 0, _n122 = this.count; _e141 < _n122; _e141++) rc.fromBufferAttribute(this, _e141), rc.applyNormalMatrix(t), this.setXYZ(_e141, rc.x, rc.y, rc.z);
      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(t) {
      for (var _e142 = 0, _n123 = this.count; _e142 < _n123; _e142++) rc.fromBufferAttribute(this, _e142), rc.transformDirection(t), this.setXYZ(_e142, rc.x, rc.y, rc.z);
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(t, e) {
      var n = this.array[t * this.data.stride + this.offset + e];
      return this.normalized && (n = Jn(n, this.array)), n;
    }
  }, {
    key: "setComponent",
    value: function setComponent(t, e, n) {
      return this.normalized && (n = Kn(n, this.array)), this.data.array[t * this.data.stride + this.offset + e] = n, this;
    }
  }, {
    key: "setX",
    value: function setX(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this;
    }
  }, {
    key: "setY",
    value: function setY(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    }
  }, {
    key: "setZ",
    value: function setZ(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    }
  }, {
    key: "setW",
    value: function setW(t, e) {
      return this.normalized && (e = Kn(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    }
  }, {
    key: "getX",
    value: function getX(t) {
      var e = this.data.array[t * this.data.stride + this.offset];
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "getY",
    value: function getY(t) {
      var e = this.data.array[t * this.data.stride + this.offset + 1];
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "getZ",
    value: function getZ(t) {
      var e = this.data.array[t * this.data.stride + this.offset + 2];
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "getW",
    value: function getW(t) {
      var e = this.data.array[t * this.data.stride + this.offset + 3];
      return this.normalized && (e = Jn(e, this.array)), e;
    }
  }, {
    key: "setXY",
    value: function setXY(t, e, n) {
      return t = t * this.data.stride + this.offset, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(t, e, n, i) {
      return t = t * this.data.stride + this.offset, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array), i = Kn(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(t, e, n, i, r) {
      return t = t * this.data.stride + this.offset, this.normalized && (e = Kn(e, this.array), n = Kn(n, this.array), i = Kn(i, this.array), r = Kn(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this;
    }
  }, {
    key: "clone",
    value: function clone(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
        var _t155 = [];
        for (var _e143 = 0; _e143 < this.count; _e143++) {
          var _n124 = _e143 * this.data.stride + this.offset;
          for (var _e144 = 0; _e144 < this.itemSize; _e144++) _t155.push(this.data.array[_n124 + _e144]);
        }
        return new os(new this.array.constructor(_t155), this.itemSize, this.normalized);
      }
      return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new sc(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
        var _t156 = [];
        for (var _e145 = 0; _e145 < this.count; _e145++) {
          var _n125 = _e145 * this.data.stride + this.offset;
          for (var _e146 = 0; _e146 < this.itemSize; _e146++) _t156.push(this.data.array[_n125 + _e146]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: _t156,
          normalized: this.normalized
        };
      }
      return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }]);
}();
var ac = exports.SpriteMaterial = /*#__PURE__*/function (_$r5) {
  function ac(t) {
    var _this31;
    _classCallCheck(this, ac);
    _this31 = _callSuper(this, ac), _this31.isSpriteMaterial = !0, _this31.type = "SpriteMaterial", _this31.color = new Zr(16777215), _this31.map = null, _this31.alphaMap = null, _this31.rotation = 0, _this31.sizeAttenuation = !0, _this31.transparent = !0, _this31.fog = !0, _this31.setValues(t);
    return _this31;
  }
  _inherits(ac, _$r5);
  return _createClass(ac, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(ac.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
    }
  }]);
}($r);
var oc;
var lc = new Ii(),
  cc = new Ii(),
  hc = new Ii(),
  uc = new Qn(),
  dc = new Qn(),
  pc = new lr(),
  mc = new Ii(),
  fc = new Ii(),
  gc = new Ii(),
  _c = new Qn(),
  vc = new Qn(),
  xc = new Qn();
var yc = exports.Sprite = /*#__PURE__*/function (_Ur6) {
  function yc() {
    var _this32;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ac();
    _classCallCheck(this, yc);
    if (_this32 = _callSuper(this, yc), _this32.isSprite = !0, _this32.type = "Sprite", void 0 === oc) {
      oc = new Ts();
      var _t157 = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
        _e147 = new ic(_t157, 5);
      oc.setIndex([0, 1, 2, 0, 2, 3]), oc.setAttribute("position", new sc(_e147, 3, 0, !1)), oc.setAttribute("uv", new sc(_e147, 2, 3, !1));
    }
    _this32.geometry = oc, _this32.material = t, _this32.center = new Qn(.5, .5);
    return _assertThisInitialized(_this32);
  }
  _inherits(yc, _Ur6);
  return _createClass(yc, [{
    key: "raycast",
    value: function raycast(t, e) {
      null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), cc.setFromMatrixScale(this.matrixWorld), pc.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), hc.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && cc.multiplyScalar(-hc.z);
      var n = this.material.rotation;
      var i, r;
      0 !== n && (r = Math.cos(n), i = Math.sin(n));
      var s = this.center;
      Mc(mc.set(-.5, -.5, 0), hc, s, cc, i, r), Mc(fc.set(.5, -.5, 0), hc, s, cc, i, r), Mc(gc.set(.5, .5, 0), hc, s, cc, i, r), _c.set(0, 0), vc.set(1, 0), xc.set(1, 1);
      var a = t.ray.intersectTriangle(mc, fc, gc, !1, lc);
      if (null === a && (Mc(fc.set(-.5, .5, 0), hc, s, cc, i, r), vc.set(0, 1), a = t.ray.intersectTriangle(mc, gc, fc, !1, lc), null === a)) return;
      var o = t.ray.origin.distanceTo(lc);
      o < t.near || o > t.far || e.push({
        distance: o,
        point: lc.clone(),
        uv: Wr.getInterpolation(lc, mc, fc, gc, _c, vc, xc, new Qn()),
        face: null,
        object: this
      });
    }
  }, {
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(yc.prototype), "copy", this).call(this, t, e), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this;
    }
  }]);
}(Ur);
function Mc(t, e, n, i, r, s) {
  uc.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (dc.x = s * uc.x - r * uc.y, dc.y = r * uc.x + s * uc.y) : dc.copy(uc), t.copy(e), t.x += dc.x, t.y += dc.y, t.applyMatrix4(pc);
}
var Sc = new Ii(),
  bc = new Ii();
var Ec = exports.LOD = /*#__PURE__*/function (_Ur7) {
  function Ec() {
    var _this33;
    _classCallCheck(this, Ec);
    _this33 = _callSuper(this, Ec), _this33._currentLevel = 0, _this33.type = "LOD", Object.defineProperties(_assertThisInitialized(_this33), {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), _this33.autoUpdate = !0;
    return _this33;
  }
  _inherits(Ec, _Ur7);
  return _createClass(Ec, [{
    key: "copy",
    value: function copy(t) {
      _get(_getPrototypeOf(Ec.prototype), "copy", this).call(this, t, !1);
      var e = t.levels;
      for (var _t158 = 0, _n126 = e.length; _t158 < _n126; _t158++) {
        var _n127 = e[_t158];
        this.addLevel(_n127.object.clone(), _n127.distance, _n127.hysteresis);
      }
      return this.autoUpdate = t.autoUpdate, this;
    }
  }, {
    key: "addLevel",
    value: function addLevel(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      e = Math.abs(e);
      var i = this.levels;
      var r;
      for (r = 0; r < i.length && !(e < i[r].distance); r++);
      return i.splice(r, 0, {
        distance: e,
        hysteresis: n,
        object: t
      }), this.add(t), this;
    }
  }, {
    key: "getCurrentLevel",
    value: function getCurrentLevel() {
      return this._currentLevel;
    }
  }, {
    key: "getObjectForDistance",
    value: function getObjectForDistance(t) {
      var e = this.levels;
      if (e.length > 0) {
        var _n128, _i119;
        for (_n128 = 1, _i119 = e.length; _n128 < _i119; _n128++) {
          var _i120 = e[_n128].distance;
          if (e[_n128].object.visible && (_i120 -= _i120 * e[_n128].hysteresis), t < _i120) break;
        }
        return e[_n128 - 1].object;
      }
      return null;
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      if (this.levels.length > 0) {
        Sc.setFromMatrixPosition(this.matrixWorld);
        var _n129 = t.ray.origin.distanceTo(Sc);
        this.getObjectForDistance(_n129).raycast(t, e);
      }
    }
  }, {
    key: "update",
    value: function update(t) {
      var e = this.levels;
      if (e.length > 1) {
        Sc.setFromMatrixPosition(t.matrixWorld), bc.setFromMatrixPosition(this.matrixWorld);
        var _n130 = Sc.distanceTo(bc) / t.zoom;
        var _i121, _r91;
        for (e[0].object.visible = !0, _i121 = 1, _r91 = e.length; _i121 < _r91; _i121++) {
          var _t159 = e[_i121].distance;
          if (e[_i121].object.visible && (_t159 -= _t159 * e[_i121].hysteresis), !(_n130 >= _t159)) break;
          e[_i121 - 1].object.visible = !1, e[_i121].object.visible = !0;
        }
        for (this._currentLevel = _i121 - 1; _i121 < _r91; _i121++) e[_i121].object.visible = !1;
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(Ec.prototype), "toJSON", this).call(this, t);
      !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
      var n = this.levels;
      for (var _t160 = 0, _i122 = n.length; _t160 < _i122; _t160++) {
        var _i123 = n[_t160];
        e.object.levels.push({
          object: _i123.object.uuid,
          distance: _i123.distance,
          hysteresis: _i123.hysteresis
        });
      }
      return e;
    }
  }]);
}(Ur);
var Tc = new Ii(),
  wc = new bi(),
  Ac = new bi(),
  Rc = new Ii(),
  Cc = new lr(),
  Pc = new Ii(),
  Lc = new Qi(),
  Ic = new lr(),
  Uc = new or();
var Nc = exports.SkinnedMesh = /*#__PURE__*/function (_Gs) {
  function Nc(t, e) {
    var _this34;
    _classCallCheck(this, Nc);
    _this34 = _callSuper(this, Nc, [t, e]), _this34.isSkinnedMesh = !0, _this34.type = "SkinnedMesh", _this34.bindMode = rt, _this34.bindMatrix = new lr(), _this34.bindMatrixInverse = new lr(), _this34.boundingBox = null, _this34.boundingSphere = null;
    return _this34;
  }
  _inherits(Nc, _Gs);
  return _createClass(Nc, [{
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      var t = this.geometry;
      null === this.boundingBox && (this.boundingBox = new Di()), this.boundingBox.makeEmpty();
      var e = t.getAttribute("position");
      for (var _t161 = 0; _t161 < e.count; _t161++) this.getVertexPosition(_t161, Pc), this.boundingBox.expandByPoint(Pc);
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      var t = this.geometry;
      null === this.boundingSphere && (this.boundingSphere = new Qi()), this.boundingSphere.makeEmpty();
      var e = t.getAttribute("position");
      for (var _t162 = 0; _t162 < e.count; _t162++) this.getVertexPosition(_t162, Pc), this.boundingSphere.expandByPoint(Pc);
    }
  }, {
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Nc.prototype), "copy", this).call(this, t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this;
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this.material,
        i = this.matrixWorld;
      void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), Lc.copy(this.boundingSphere), Lc.applyMatrix4(i), !1 !== t.ray.intersectsSphere(Lc) && (Ic.copy(i).invert(), Uc.copy(t.ray).applyMatrix4(Ic), null !== this.boundingBox && !1 === Uc.intersectsBox(this.boundingBox) || this._computeIntersections(t, e, Uc)));
    }
  }, {
    key: "getVertexPosition",
    value: function getVertexPosition(t, e) {
      return _get(_getPrototypeOf(Nc.prototype), "getVertexPosition", this).call(this, t, e), this.applyBoneTransform(t, e), e;
    }
  }, {
    key: "bind",
    value: function bind(t, e) {
      this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
    }
  }, {
    key: "pose",
    value: function pose() {
      this.skeleton.pose();
    }
  }, {
    key: "normalizeSkinWeights",
    value: function normalizeSkinWeights() {
      var t = new bi(),
        e = this.geometry.attributes.skinWeight;
      for (var _n131 = 0, _i124 = e.count; _n131 < _i124; _n131++) {
        t.fromBufferAttribute(e, _n131);
        var _i125 = 1 / t.manhattanLength();
        _i125 !== 1 / 0 ? t.multiplyScalar(_i125) : t.set(1, 0, 0, 0), e.setXYZW(_n131, t.x, t.y, t.z, t.w);
      }
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      _get(_getPrototypeOf(Nc.prototype), "updateMatrixWorld", this).call(this, t), this.bindMode === rt ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === st ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }, {
    key: "applyBoneTransform",
    value: function applyBoneTransform(t, e) {
      var n = this.skeleton,
        i = this.geometry;
      wc.fromBufferAttribute(i.attributes.skinIndex, t), Ac.fromBufferAttribute(i.attributes.skinWeight, t), Tc.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
      for (var _t163 = 0; _t163 < 4; _t163++) {
        var _i126 = Ac.getComponent(_t163);
        if (0 !== _i126) {
          var _r92 = wc.getComponent(_t163);
          Cc.multiplyMatrices(n.bones[_r92].matrixWorld, n.boneInverses[_r92]), e.addScaledVector(Rc.copy(Tc).applyMatrix4(Cc), _i126);
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse);
    }
  }]);
}(Gs);
var Dc = exports.Bone = /*#__PURE__*/function (_Ur8) {
  function Dc() {
    var _this35;
    _classCallCheck(this, Dc);
    _this35 = _callSuper(this, Dc), _this35.isBone = !0, _this35.type = "Bone";
    return _this35;
  }
  _inherits(Dc, _Ur8);
  return _createClass(Dc);
}(Ur);
var Oc = exports.DataTexture = /*#__PURE__*/function (_Si5) {
  function Oc() {
    var _this36;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    var s = arguments.length > 5 ? arguments[5] : undefined;
    var a = arguments.length > 6 ? arguments[6] : undefined;
    var o = arguments.length > 7 ? arguments[7] : undefined;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1003;
    var c = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 1003;
    var h = arguments.length > 10 ? arguments[10] : undefined;
    var u = arguments.length > 11 ? arguments[11] : undefined;
    _classCallCheck(this, Oc);
    _this36 = _callSuper(this, Oc, [null, s, a, o, l, c, i, r, h, u]), _this36.isDataTexture = !0, _this36.image = {
      data: t,
      width: e,
      height: n
    }, _this36.generateMipmaps = !1, _this36.flipY = !1, _this36.unpackAlignment = 1;
    return _this36;
  }
  _inherits(Oc, _Si5);
  return _createClass(Oc);
}(Si);
var Fc = new lr(),
  Bc = new lr();
var zc = exports.Skeleton = /*#__PURE__*/function () {
  function zc() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    _classCallCheck(this, zc);
    this.uuid = Wn(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  return _createClass(zc, [{
    key: "init",
    value: function init() {
      var t = this.bones,
        e = this.boneInverses;
      if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();else if (t.length !== e.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (var _t164 = 0, _e148 = this.bones.length; _t164 < _e148; _t164++) this.boneInverses.push(new lr());
      }
    }
  }, {
    key: "calculateInverses",
    value: function calculateInverses() {
      this.boneInverses.length = 0;
      for (var _t165 = 0, _e149 = this.bones.length; _t165 < _e149; _t165++) {
        var _e150 = new lr();
        this.bones[_t165] && _e150.copy(this.bones[_t165].matrixWorld).invert(), this.boneInverses.push(_e150);
      }
    }
  }, {
    key: "pose",
    value: function pose() {
      for (var _t166 = 0, _e151 = this.bones.length; _t166 < _e151; _t166++) {
        var _e152 = this.bones[_t166];
        _e152 && _e152.matrixWorld.copy(this.boneInverses[_t166]).invert();
      }
      for (var _t167 = 0, _e153 = this.bones.length; _t167 < _e153; _t167++) {
        var _e154 = this.bones[_t167];
        _e154 && (_e154.parent && _e154.parent.isBone ? (_e154.matrix.copy(_e154.parent.matrixWorld).invert(), _e154.matrix.multiply(_e154.matrixWorld)) : _e154.matrix.copy(_e154.matrixWorld), _e154.matrix.decompose(_e154.position, _e154.quaternion, _e154.scale));
      }
    }
  }, {
    key: "update",
    value: function update() {
      var t = this.bones,
        e = this.boneInverses,
        n = this.boneMatrices,
        i = this.boneTexture;
      for (var _i127 = 0, _r93 = t.length; _i127 < _r93; _i127++) {
        var _r94 = t[_i127] ? t[_i127].matrixWorld : Bc;
        Fc.multiplyMatrices(_r94, e[_i127]), Fc.toArray(n, 16 * _i127);
      }
      null !== i && (i.needsUpdate = !0);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new zc(this.bones, this.boneInverses);
    }
  }, {
    key: "computeBoneTexture",
    value: function computeBoneTexture() {
      var t = Math.sqrt(4 * this.bones.length);
      t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
      var e = new Float32Array(t * t * 4);
      e.set(this.boneMatrices);
      var n = new Oc(e, t, t, Ft, Lt);
      return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this;
    }
  }, {
    key: "getBoneByName",
    value: function getBoneByName(t) {
      for (var _e155 = 0, _n132 = this.bones.length; _e155 < _n132; _e155++) {
        var _n133 = this.bones[_e155];
        if (_n133.name === t) return _n133;
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t, e) {
      this.uuid = t.uuid;
      for (var _n134 = 0, _i128 = t.bones.length; _n134 < _i128; _n134++) {
        var _i129 = t.bones[_n134];
        var _r95 = e[_i129];
        void 0 === _r95 && (console.warn("THREE.Skeleton: No bone found with UUID:", _i129), _r95 = new Dc()), this.bones.push(_r95), this.boneInverses.push(new lr().fromArray(t.boneInverses[_n134]));
      }
      return this.init(), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {
        metadata: {
          version: 4.6,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      t.uuid = this.uuid;
      var e = this.bones,
        n = this.boneInverses;
      for (var _i130 = 0, _r96 = e.length; _i130 < _r96; _i130++) {
        var _r97 = e[_i130];
        t.bones.push(_r97.uuid);
        var _s50 = n[_i130];
        t.boneInverses.push(_s50.toArray());
      }
      return t;
    }
  }]);
}();
var Hc = exports.InstancedBufferAttribute = /*#__PURE__*/function (_os11) {
  function Hc(t, e, n) {
    var _this37;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Hc);
    _this37 = _callSuper(this, Hc, [t, e, n]), _this37.isInstancedBufferAttribute = !0, _this37.meshPerAttribute = i;
    return _this37;
  }
  _inherits(Hc, _os11);
  return _createClass(Hc, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Hc.prototype), "copy", this).call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Hc.prototype), "toJSON", this).call(this);
      return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
    }
  }]);
}(os);
var Vc = new lr(),
  kc = new lr(),
  Gc = [],
  Wc = new Di(),
  Xc = new lr(),
  jc = new Gs(),
  qc = new Qi();
var Yc = exports.InstancedMesh = /*#__PURE__*/function (_Gs2) {
  function Yc(t, e, n) {
    var _this38;
    _classCallCheck(this, Yc);
    _this38 = _callSuper(this, Yc, [t, e]), _this38.isInstancedMesh = !0, _this38.instanceMatrix = new Hc(new Float32Array(16 * n), 16), _this38.instanceColor = null, _this38.count = n, _this38.boundingBox = null, _this38.boundingSphere = null;
    for (var _t168 = 0; _t168 < n; _t168++) _this38.setMatrixAt(_t168, Xc);
    return _this38;
  }
  _inherits(Yc, _Gs2);
  return _createClass(Yc, [{
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      var t = this.geometry,
        e = this.count;
      null === this.boundingBox && (this.boundingBox = new Di()), null === t.boundingBox && t.computeBoundingBox(), this.boundingBox.makeEmpty();
      for (var _n135 = 0; _n135 < e; _n135++) this.getMatrixAt(_n135, Vc), Wc.copy(t.boundingBox).applyMatrix4(Vc), this.boundingBox.union(Wc);
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      var t = this.geometry,
        e = this.count;
      null === this.boundingSphere && (this.boundingSphere = new Qi()), null === t.boundingSphere && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
      for (var _n136 = 0; _n136 < e; _n136++) this.getMatrixAt(_n136, Vc), qc.copy(t.boundingSphere).applyMatrix4(Vc), this.boundingSphere.union(qc);
    }
  }, {
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Yc.prototype), "copy", this).call(this, t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this;
    }
  }, {
    key: "getColorAt",
    value: function getColorAt(t, e) {
      e.fromArray(this.instanceColor.array, 3 * t);
    }
  }, {
    key: "getMatrixAt",
    value: function getMatrixAt(t, e) {
      e.fromArray(this.instanceMatrix.array, 16 * t);
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this.matrixWorld,
        i = this.count;
      if (jc.geometry = this.geometry, jc.material = this.material, void 0 !== jc.material && (null === this.boundingSphere && this.computeBoundingSphere(), qc.copy(this.boundingSphere), qc.applyMatrix4(n), !1 !== t.ray.intersectsSphere(qc))) for (var _r98 = 0; _r98 < i; _r98++) {
        this.getMatrixAt(_r98, Vc), kc.multiplyMatrices(n, Vc), jc.matrixWorld = kc, jc.raycast(t, Gc);
        for (var _t169 = 0, _n137 = Gc.length; _t169 < _n137; _t169++) {
          var _n138 = Gc[_t169];
          _n138.instanceId = _r98, _n138.object = this, e.push(_n138);
        }
        Gc.length = 0;
      }
    }
  }, {
    key: "setColorAt",
    value: function setColorAt(t, e) {
      null === this.instanceColor && (this.instanceColor = new Hc(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t);
    }
  }, {
    key: "setMatrixAt",
    value: function setMatrixAt(t, e) {
      e.toArray(this.instanceMatrix.array, 16 * t);
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {}
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }]);
}(Gs);
function Zc(t, e) {
  return t.z - e.z;
}
function Jc(t, e) {
  return e.z - t.z;
}
var Kc = /*#__PURE__*/function () {
  function Kc() {
    _classCallCheck(this, Kc);
    this.index = 0, this.pool = [], this.list = [];
  }
  return _createClass(Kc, [{
    key: "push",
    value: function push(t, e) {
      var n = this.pool,
        i = this.list;
      this.index >= n.length && n.push({
        start: -1,
        count: -1,
        z: -1
      });
      var r = n[this.index];
      i.push(r), this.index++, r.start = t.start, r.count = t.count, r.z = e;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.list.length = 0, this.index = 0;
    }
  }]);
}();
var $c = "batchId",
  Qc = new lr(),
  th = new lr(),
  eh = new lr(),
  nh = new lr(),
  ih = new da(),
  rh = new Di(),
  sh = new Qi(),
  ah = new Ii(),
  oh = new Kc(),
  lh = new Gs(),
  ch = [];
function hh(t, e) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var i = e.itemSize;
  if (t.isInterleavedBufferAttribute || t.array.constructor !== e.array.constructor) {
    var _r99 = t.count;
    for (var _s51 = 0; _s51 < _r99; _s51++) for (var _r100 = 0; _r100 < i; _r100++) e.setComponent(_s51 + n, _r100, t.getComponent(_s51, _r100));
  } else e.array.set(t.array, n * i);
  e.needsUpdate = !0;
}
var uh = exports.BatchedMesh = /*#__PURE__*/function (_Gs3) {
  function uh(t, e) {
    var _this39;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2 * e;
    var i = arguments.length > 3 ? arguments[3] : undefined;
    _classCallCheck(this, uh);
    _this39 = _callSuper(this, uh, [new Ts(), i]), _this39.isBatchedMesh = !0, _this39.perObjectFrustumCulled = !0, _this39.sortObjects = !0, _this39.boundingBox = null, _this39.boundingSphere = null, _this39.customSort = null, _this39._drawRanges = [], _this39._reservedRanges = [], _this39._visibility = [], _this39._active = [], _this39._bounds = [], _this39._maxGeometryCount = t, _this39._maxVertexCount = e, _this39._maxIndexCount = n, _this39._geometryInitialized = !1, _this39._geometryCount = 0, _this39._multiDrawCounts = new Int32Array(t), _this39._multiDrawStarts = new Int32Array(t), _this39._multiDrawCount = 0, _this39._visibilityChanged = !0, _this39._matricesTexture = null, _this39._initMatricesTexture();
    return _this39;
  }
  _inherits(uh, _Gs3);
  return _createClass(uh, [{
    key: "maxGeometryCount",
    get: function get() {
      return this._maxGeometryCount;
    }
  }, {
    key: "_initMatricesTexture",
    value: function _initMatricesTexture() {
      var t = Math.sqrt(4 * this._maxGeometryCount);
      t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
      var e = new Float32Array(t * t * 4),
        n = new Oc(e, t, t, Ft, Lt);
      this._matricesTexture = n;
    }
  }, {
    key: "_initializeGeometry",
    value: function _initializeGeometry(t) {
      var e = this.geometry,
        n = this._maxVertexCount,
        i = this._maxGeometryCount,
        r = this._maxIndexCount;
      if (!1 === this._geometryInitialized) {
        for (var _i131 in t.attributes) {
          var _r101 = t.getAttribute(_i131),
            _s52 = _r101.array,
            _a43 = _r101.itemSize,
            _o31 = _r101.normalized,
            _l17 = new _s52.constructor(n * _a43),
            _c18 = new _r101.constructor(_l17, _a43, _o31);
          _c18.setUsage(_r101.usage), e.setAttribute(_i131, _c18);
        }
        if (null !== t.getIndex()) {
          var _t170 = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
          e.setIndex(new os(_t170, 1));
        }
        var _s53 = i > 65536 ? new Uint32Array(n) : new Uint16Array(n);
        e.setAttribute($c, new os(_s53, 1)), this._geometryInitialized = !0;
      }
    }
  }, {
    key: "_validateGeometry",
    value: function _validateGeometry(t) {
      if (t.getAttribute($c)) throw new Error("BatchedMesh: Geometry cannot use attribute \"".concat($c, "\""));
      var e = this.geometry;
      if (Boolean(t.getIndex()) !== Boolean(e.getIndex())) throw new Error('BatchedMesh: All geometries must consistently have "index".');
      for (var _n139 in e.attributes) {
        if (_n139 === $c) continue;
        if (!t.hasAttribute(_n139)) throw new Error("BatchedMesh: Added geometry missing \"".concat(_n139, "\". All geometries must have consistent attributes."));
        var _i132 = t.getAttribute(_n139),
          _r102 = e.getAttribute(_n139);
        if (_i132.itemSize !== _r102.itemSize || _i132.normalized !== _r102.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
      }
    }
  }, {
    key: "setCustomSort",
    value: function setCustomSort(t) {
      return this.customSort = t, this;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new Di());
      var t = this._geometryCount,
        e = this.boundingBox,
        n = this._active;
      e.makeEmpty();
      for (var _i133 = 0; _i133 < t; _i133++) !1 !== n[_i133] && (this.getMatrixAt(_i133, Qc), this.getBoundingBoxAt(_i133, rh).applyMatrix4(Qc), e.union(rh));
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new Qi());
      var t = this._geometryCount,
        e = this.boundingSphere,
        n = this._active;
      e.makeEmpty();
      for (var _i134 = 0; _i134 < t; _i134++) !1 !== n[_i134] && (this.getMatrixAt(_i134, Qc), this.getBoundingSphereAt(_i134, sh).applyMatrix4(Qc), e.union(sh));
    }
  }, {
    key: "addGeometry",
    value: function addGeometry(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      if (this._initializeGeometry(t), this._validateGeometry(t), this._geometryCount >= this._maxGeometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
      var i = {
        vertexStart: -1,
        vertexCount: -1,
        indexStart: -1,
        indexCount: -1
      };
      var r = null;
      var s = this._reservedRanges,
        a = this._drawRanges,
        o = this._bounds;
      0 !== this._geometryCount && (r = s[s.length - 1]), i.vertexCount = -1 === e ? t.getAttribute("position").count : e, i.vertexStart = null === r ? 0 : r.vertexStart + r.vertexCount;
      var l = t.getIndex(),
        c = null !== l;
      if (c && (i.indexCount = -1 === n ? l.count : n, i.indexStart = null === r ? 0 : r.indexStart + r.indexCount), -1 !== i.indexStart && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
      var h = this._visibility,
        u = this._active,
        d = this._matricesTexture,
        p = this._matricesTexture.image.data;
      h.push(!0), u.push(!0);
      var m = this._geometryCount;
      this._geometryCount++, eh.toArray(p, 16 * m), d.needsUpdate = !0, s.push(i), a.push({
        start: c ? i.indexStart : i.vertexStart,
        count: -1
      }), o.push({
        boxInitialized: !1,
        box: new Di(),
        sphereInitialized: !1,
        sphere: new Qi()
      });
      var f = this.geometry.getAttribute($c);
      for (var _t171 = 0; _t171 < i.vertexCount; _t171++) f.setX(i.vertexStart + _t171, m);
      return f.needsUpdate = !0, this.setGeometryAt(m, t), m;
    }
  }, {
    key: "setGeometryAt",
    value: function setGeometryAt(t, e) {
      if (t >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
      this._validateGeometry(e);
      var n = this.geometry,
        i = null !== n.getIndex(),
        r = n.getIndex(),
        s = e.getIndex(),
        a = this._reservedRanges[t];
      if (i && s.count > a.indexCount || e.attributes.position.count > a.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
      var o = a.vertexStart,
        l = a.vertexCount;
      for (var _t172 in n.attributes) {
        if (_t172 === $c) continue;
        var _i135 = e.getAttribute(_t172),
          _r103 = n.getAttribute(_t172);
        hh(_i135, _r103, o);
        var _s54 = _i135.itemSize;
        for (var _t173 = _i135.count, _e156 = l; _t173 < _e156; _t173++) {
          var _e157 = o + _t173;
          for (var _t174 = 0; _t174 < _s54; _t174++) _r103.setComponent(_e157, _t174, 0);
        }
        _r103.needsUpdate = !0;
      }
      if (i) {
        var _t175 = a.indexStart;
        for (var _e158 = 0; _e158 < s.count; _e158++) r.setX(_t175 + _e158, o + s.getX(_e158));
        for (var _e159 = s.count, _n140 = a.indexCount; _e159 < _n140; _e159++) r.setX(_t175 + _e159, o);
        r.needsUpdate = !0;
      }
      var c = this._bounds[t];
      null !== e.boundingBox ? (c.box.copy(e.boundingBox), c.boxInitialized = !0) : c.boxInitialized = !1, null !== e.boundingSphere ? (c.sphere.copy(e.boundingSphere), c.sphereInitialized = !0) : c.sphereInitialized = !1;
      var h = this._drawRanges[t],
        u = e.getAttribute("position");
      return h.count = i ? s.count : u.count, this._visibilityChanged = !0, t;
    }
  }, {
    key: "deleteGeometry",
    value: function deleteGeometry(t) {
      var e = this._active;
      return t >= e.length || !1 === e[t] || (e[t] = !1, this._visibilityChanged = !0), this;
    }
  }, {
    key: "getBoundingBoxAt",
    value: function getBoundingBoxAt(t, e) {
      if (!1 === this._active[t]) return null;
      var n = this._bounds[t],
        i = n.box,
        r = this.geometry;
      if (!1 === n.boxInitialized) {
        i.makeEmpty();
        var _e160 = r.index,
          _s55 = r.attributes.position,
          _a44 = this._drawRanges[t];
        for (var _t176 = _a44.start, _n141 = _a44.start + _a44.count; _t176 < _n141; _t176++) {
          var _n142 = _t176;
          _e160 && (_n142 = _e160.getX(_n142)), i.expandByPoint(ah.fromBufferAttribute(_s55, _n142));
        }
        n.boxInitialized = !0;
      }
      return e.copy(i), e;
    }
  }, {
    key: "getBoundingSphereAt",
    value: function getBoundingSphereAt(t, e) {
      if (!1 === this._active[t]) return null;
      var n = this._bounds[t],
        i = n.sphere,
        r = this.geometry;
      if (!1 === n.sphereInitialized) {
        i.makeEmpty(), this.getBoundingBoxAt(t, rh), rh.getCenter(i.center);
        var _e161 = r.index,
          _s56 = r.attributes.position,
          _a45 = this._drawRanges[t];
        var _o32 = 0;
        for (var _t177 = _a45.start, _n143 = _a45.start + _a45.count; _t177 < _n143; _t177++) {
          var _n144 = _t177;
          _e161 && (_n144 = _e161.getX(_n144)), ah.fromBufferAttribute(_s56, _n144), _o32 = Math.max(_o32, i.center.distanceToSquared(ah));
        }
        i.radius = Math.sqrt(_o32), n.sphereInitialized = !0;
      }
      return e.copy(i), e;
    }
  }, {
    key: "setMatrixAt",
    value: function setMatrixAt(t, e) {
      var n = this._active,
        i = this._matricesTexture,
        r = this._matricesTexture.image.data;
      return t >= this._geometryCount || !1 === n[t] || (e.toArray(r, 16 * t), i.needsUpdate = !0), this;
    }
  }, {
    key: "getMatrixAt",
    value: function getMatrixAt(t, e) {
      var n = this._active,
        i = this._matricesTexture.image.data;
      return t >= this._geometryCount || !1 === n[t] ? null : e.fromArray(i, 16 * t);
    }
  }, {
    key: "setVisibleAt",
    value: function setVisibleAt(t, e) {
      var n = this._visibility,
        i = this._active;
      return t >= this._geometryCount || !1 === i[t] || n[t] === e || (n[t] = e, this._visibilityChanged = !0), this;
    }
  }, {
    key: "getVisibleAt",
    value: function getVisibleAt(t) {
      var e = this._visibility,
        n = this._active;
      return !(t >= this._geometryCount || !1 === n[t]) && e[t];
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this._visibility,
        i = this._active,
        r = this._drawRanges,
        s = this._geometryCount,
        a = this.matrixWorld,
        o = this.geometry;
      lh.material = this.material, lh.geometry.index = o.index, lh.geometry.attributes = o.attributes, null === lh.geometry.boundingBox && (lh.geometry.boundingBox = new Di()), null === lh.geometry.boundingSphere && (lh.geometry.boundingSphere = new Qi());
      for (var _o33 = 0; _o33 < s; _o33++) {
        if (!n[_o33] || !i[_o33]) continue;
        var _s57 = r[_o33];
        lh.geometry.setDrawRange(_s57.start, _s57.count), this.getMatrixAt(_o33, lh.matrixWorld).premultiply(a), this.getBoundingBoxAt(_o33, lh.geometry.boundingBox), this.getBoundingSphereAt(_o33, lh.geometry.boundingSphere), lh.raycast(t, ch);
        for (var _t178 = 0, _n145 = ch.length; _t178 < _n145; _t178++) {
          var _n146 = ch[_t178];
          _n146.object = this, _n146.batchId = _o33, e.push(_n146);
        }
        ch.length = 0;
      }
      lh.material = null, lh.geometry.index = null, lh.geometry.attributes = {}, lh.geometry.setDrawRange(0, 1 / 0);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(uh.prototype), "copy", this).call(this, t), this.geometry = t.geometry.clone(), this.perObjectFrustumCulled = t.perObjectFrustumCulled, this.sortObjects = t.sortObjects, this.boundingBox = null !== t.boundingBox ? t.boundingBox.clone() : null, this.boundingSphere = null !== t.boundingSphere ? t.boundingSphere.clone() : null, this._drawRanges = t._drawRanges.map(function (t) {
        return _objectSpread({}, t);
      }), this._reservedRanges = t._reservedRanges.map(function (t) {
        return _objectSpread({}, t);
      }), this._visibility = t._visibility.slice(), this._active = t._active.slice(), this._bounds = t._bounds.map(function (t) {
        return {
          boxInitialized: t.boxInitialized,
          box: t.box.clone(),
          sphereInitialized: t.sphereInitialized,
          sphere: t.sphere.clone()
        };
      }), this._maxGeometryCount = t._maxGeometryCount, this._maxVertexCount = t._maxVertexCount, this._maxIndexCount = t._maxIndexCount, this._geometryInitialized = t._geometryInitialized, this._geometryCount = t._geometryCount, this._multiDrawCounts = t._multiDrawCounts.slice(), this._multiDrawStarts = t._multiDrawStarts.slice(), this._matricesTexture = t._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
    }
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender(t, e, n, i, r) {
      if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
      var s = i.getIndex(),
        a = null === s ? 1 : s.array.BYTES_PER_ELEMENT,
        o = this._active,
        l = this._visibility,
        c = this._multiDrawStarts,
        h = this._multiDrawCounts,
        u = this._drawRanges,
        d = this.perObjectFrustumCulled;
      d && (nh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), ih.setFromProjectionMatrix(nh, t.coordinateSystem));
      var p = 0;
      if (this.sortObjects) {
        th.copy(this.matrixWorld).invert(), ah.setFromMatrixPosition(n.matrixWorld).applyMatrix4(th);
        for (var _t179 = 0, _e162 = l.length; _t179 < _e162; _t179++) if (l[_t179] && o[_t179]) {
          this.getMatrixAt(_t179, Qc), this.getBoundingSphereAt(_t179, sh).applyMatrix4(Qc);
          var _e163 = !1;
          if (d && (_e163 = !ih.intersectsSphere(sh)), !_e163) {
            var _e164 = ah.distanceTo(sh.center);
            oh.push(u[_t179], _e164);
          }
        }
        var _t180 = oh.list,
          _e165 = this.customSort;
        null === _e165 ? _t180.sort(r.transparent ? Jc : Zc) : _e165.call(this, _t180, n);
        for (var _e166 = 0, _n147 = _t180.length; _e166 < _n147; _e166++) {
          var _n148 = _t180[_e166];
          c[p] = _n148.start * a, h[p] = _n148.count, p++;
        }
        oh.reset();
      } else for (var _t181 = 0, _e167 = l.length; _t181 < _e167; _t181++) if (l[_t181] && o[_t181]) {
        var _e168 = !1;
        if (d && (this.getMatrixAt(_t181, Qc), this.getBoundingSphereAt(_t181, sh).applyMatrix4(Qc), _e168 = !ih.intersectsSphere(sh)), !_e168) {
          var _e169 = u[_t181];
          c[p] = _e169.start * a, h[p] = _e169.count, p++;
        }
      }
      this._multiDrawCount = p, this._visibilityChanged = !1;
    }
  }, {
    key: "onBeforeShadow",
    value: function onBeforeShadow(t, e, n, i, r, s) {
      this.onBeforeRender(t, null, i, r, s);
    }
  }]);
}(Gs);
var dh = exports.LineBasicMaterial = /*#__PURE__*/function (_$r6) {
  function dh(t) {
    var _this40;
    _classCallCheck(this, dh);
    _this40 = _callSuper(this, dh), _this40.isLineBasicMaterial = !0, _this40.type = "LineBasicMaterial", _this40.color = new Zr(16777215), _this40.map = null, _this40.linewidth = 1, _this40.linecap = "round", _this40.linejoin = "round", _this40.fog = !0, _this40.setValues(t);
    return _this40;
  }
  _inherits(dh, _$r6);
  return _createClass(dh, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(dh.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
    }
  }]);
}($r);
var ph = new Ii(),
  mh = new Ii(),
  fh = new lr(),
  gh = new or(),
  _h = new Qi();
var vh = exports.Line = /*#__PURE__*/function (_Ur9) {
  function vh() {
    var _this41;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ts();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new dh();
    _classCallCheck(this, vh);
    _this41 = _callSuper(this, vh), _this41.isLine = !0, _this41.type = "Line", _this41.geometry = t, _this41.material = e, _this41.updateMorphTargets();
    return _this41;
  }
  _inherits(vh, _Ur9);
  return _createClass(vh, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(vh.prototype), "copy", this).call(this, t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
    }
  }, {
    key: "computeLineDistances",
    value: function computeLineDistances() {
      var t = this.geometry;
      if (null === t.index) {
        var _e170 = t.attributes.position,
          _n149 = [0];
        for (var _t182 = 1, _i136 = _e170.count; _t182 < _i136; _t182++) ph.fromBufferAttribute(_e170, _t182 - 1), mh.fromBufferAttribute(_e170, _t182), _n149[_t182] = _n149[_t182 - 1], _n149[_t182] += ph.distanceTo(mh);
        t.setAttribute("lineDistance", new gs(_n149, 1));
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Line.threshold,
        s = n.drawRange;
      if (null === n.boundingSphere && n.computeBoundingSphere(), _h.copy(n.boundingSphere), _h.applyMatrix4(i), _h.radius += r, !1 === t.ray.intersectsSphere(_h)) return;
      fh.copy(i).invert(), gh.copy(t.ray).applyMatrix4(fh);
      var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = a * a,
        l = new Ii(),
        c = new Ii(),
        h = new Ii(),
        u = new Ii(),
        d = this.isLineSegments ? 2 : 1,
        p = n.index,
        m = n.attributes.position;
      if (null !== p) {
        for (var _n150 = Math.max(0, s.start), _i137 = Math.min(p.count, s.start + s.count) - 1; _n150 < _i137; _n150 += d) {
          var _i138 = p.getX(_n150),
            _r104 = p.getX(_n150 + 1);
          l.fromBufferAttribute(m, _i138), c.fromBufferAttribute(m, _r104);
          if (gh.distanceSqToSegment(l, c, u, h) > o) continue;
          u.applyMatrix4(this.matrixWorld);
          var _s58 = t.ray.origin.distanceTo(u);
          _s58 < t.near || _s58 > t.far || e.push({
            distance: _s58,
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: _n150,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (var _n151 = Math.max(0, s.start), _i139 = Math.min(m.count, s.start + s.count) - 1; _n151 < _i139; _n151 += d) {
          l.fromBufferAttribute(m, _n151), c.fromBufferAttribute(m, _n151 + 1);
          if (gh.distanceSqToSegment(l, c, u, h) > o) continue;
          u.applyMatrix4(this.matrixWorld);
          var _i140 = t.ray.origin.distanceTo(u);
          _i140 < t.near || _i140 > t.far || e.push({
            distance: _i140,
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: _n151,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        var _n152 = t[e[0]];
        if (void 0 !== _n152) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (var _t183 = 0, _e171 = _n152.length; _t183 < _e171; _t183++) {
            var _e172 = _n152[_t183].name || String(_t183);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[_e172] = _t183;
          }
        }
      }
    }
  }]);
}(Ur);
var xh = new Ii(),
  yh = new Ii();
var Mh = exports.LineSegments = /*#__PURE__*/function (_vh) {
  function Mh(t, e) {
    var _this42;
    _classCallCheck(this, Mh);
    _this42 = _callSuper(this, Mh, [t, e]), _this42.isLineSegments = !0, _this42.type = "LineSegments";
    return _this42;
  }
  _inherits(Mh, _vh);
  return _createClass(Mh, [{
    key: "computeLineDistances",
    value: function computeLineDistances() {
      var t = this.geometry;
      if (null === t.index) {
        var _e173 = t.attributes.position,
          _n153 = [];
        for (var _t184 = 0, _i141 = _e173.count; _t184 < _i141; _t184 += 2) xh.fromBufferAttribute(_e173, _t184), yh.fromBufferAttribute(_e173, _t184 + 1), _n153[_t184] = 0 === _t184 ? 0 : _n153[_t184 - 1], _n153[_t184 + 1] = _n153[_t184] + xh.distanceTo(yh);
        t.setAttribute("lineDistance", new gs(_n153, 1));
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }]);
}(vh);
var Sh = exports.LineLoop = /*#__PURE__*/function (_vh2) {
  function Sh(t, e) {
    var _this43;
    _classCallCheck(this, Sh);
    _this43 = _callSuper(this, Sh, [t, e]), _this43.isLineLoop = !0, _this43.type = "LineLoop";
    return _this43;
  }
  _inherits(Sh, _vh2);
  return _createClass(Sh);
}(vh);
var bh = exports.PointsMaterial = /*#__PURE__*/function (_$r7) {
  function bh(t) {
    var _this44;
    _classCallCheck(this, bh);
    _this44 = _callSuper(this, bh), _this44.isPointsMaterial = !0, _this44.type = "PointsMaterial", _this44.color = new Zr(16777215), _this44.map = null, _this44.alphaMap = null, _this44.size = 1, _this44.sizeAttenuation = !0, _this44.fog = !0, _this44.setValues(t);
    return _this44;
  }
  _inherits(bh, _$r7);
  return _createClass(bh, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(bh.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
    }
  }]);
}($r);
var Eh = new lr(),
  Th = new or(),
  wh = new Qi(),
  Ah = new Ii();
var Rh = exports.Points = /*#__PURE__*/function (_Ur10) {
  function Rh() {
    var _this45;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ts();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new bh();
    _classCallCheck(this, Rh);
    _this45 = _callSuper(this, Rh), _this45.isPoints = !0, _this45.type = "Points", _this45.geometry = t, _this45.material = e, _this45.updateMorphTargets();
    return _this45;
  }
  _inherits(Rh, _Ur10);
  return _createClass(Rh, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Rh.prototype), "copy", this).call(this, t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
    }
  }, {
    key: "raycast",
    value: function raycast(t, e) {
      var n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Points.threshold,
        s = n.drawRange;
      if (null === n.boundingSphere && n.computeBoundingSphere(), wh.copy(n.boundingSphere), wh.applyMatrix4(i), wh.radius += r, !1 === t.ray.intersectsSphere(wh)) return;
      Eh.copy(i).invert(), Th.copy(t.ray).applyMatrix4(Eh);
      var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = a * a,
        l = n.index,
        c = n.attributes.position;
      if (null !== l) {
        for (var _n154 = Math.max(0, s.start), _r105 = Math.min(l.count, s.start + s.count); _n154 < _r105; _n154++) {
          var _r106 = l.getX(_n154);
          Ah.fromBufferAttribute(c, _r106), Ch(Ah, _r106, o, i, t, e, this);
        }
      } else {
        for (var _n155 = Math.max(0, s.start), _r107 = Math.min(c.count, s.start + s.count); _n155 < _r107; _n155++) Ah.fromBufferAttribute(c, _n155), Ch(Ah, _n155, o, i, t, e, this);
      }
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        var _n156 = t[e[0]];
        if (void 0 !== _n156) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (var _t185 = 0, _e174 = _n156.length; _t185 < _e174; _t185++) {
            var _e175 = _n156[_t185].name || String(_t185);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[_e175] = _t185;
          }
        }
      }
    }
  }]);
}(Ur);
function Ch(t, e, n, i, r, s, a) {
  var o = Th.distanceSqToPoint(t);
  if (o < n) {
    var _n157 = new Ii();
    Th.closestPointToPoint(t, _n157), _n157.applyMatrix4(i);
    var _l18 = r.ray.origin.distanceTo(_n157);
    if (_l18 < r.near || _l18 > r.far) return;
    s.push({
      distance: _l18,
      distanceToRay: Math.sqrt(o),
      point: _n157,
      index: e,
      face: null,
      object: a
    });
  }
}
var Ph = exports.VideoTexture = /*#__PURE__*/function (_Si6) {
  function Ph(t, e, n, i, r, s, a, o, l) {
    var _this46;
    _classCallCheck(this, Ph);
    _this46 = _callSuper(this, Ph, [t, e, n, i, r, s, a, o, l]), _this46.isVideoTexture = !0, _this46.minFilter = void 0 !== s ? s : yt, _this46.magFilter = void 0 !== r ? r : yt, _this46.generateMipmaps = !1;
    var c = _this46;
    "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() {
      c.needsUpdate = !0, t.requestVideoFrameCallback(e);
    });
    return _this46;
  }
  _inherits(Ph, _Si6);
  return _createClass(Ph, [{
    key: "clone",
    value: function clone() {
      return new this.constructor(this.image).copy(this);
    }
  }, {
    key: "update",
    value: function update() {
      var t = this.image;
      !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
  }]);
}(Si);
var Lh = exports.FramebufferTexture = /*#__PURE__*/function (_Si7) {
  function Lh(t, e) {
    var _this47;
    _classCallCheck(this, Lh);
    _this47 = _callSuper(this, Lh, [{
      width: t,
      height: e
    }]), _this47.isFramebufferTexture = !0, _this47.magFilter = ft, _this47.minFilter = ft, _this47.generateMipmaps = !1, _this47.needsUpdate = !0;
    return _this47;
  }
  _inherits(Lh, _Si7);
  return _createClass(Lh);
}(Si);
var Ih = exports.CompressedTexture = /*#__PURE__*/function (_Si8) {
  function Ih(t, e, n, i, r, s, a, o, l, c, h, u) {
    var _this48;
    _classCallCheck(this, Ih);
    _this48 = _callSuper(this, Ih, [null, s, a, o, l, c, i, r, h, u]), _this48.isCompressedTexture = !0, _this48.image = {
      width: e,
      height: n
    }, _this48.mipmaps = t, _this48.flipY = !1, _this48.generateMipmaps = !1;
    return _this48;
  }
  _inherits(Ih, _Si8);
  return _createClass(Ih);
}(Si);
var Uh = exports.CompressedArrayTexture = /*#__PURE__*/function (_Ih) {
  function Uh(t, e, n, i, r, s) {
    var _this49;
    _classCallCheck(this, Uh);
    _this49 = _callSuper(this, Uh, [t, e, n, r, s]), _this49.isCompressedArrayTexture = !0, _this49.image.depth = i, _this49.wrapR = pt;
    return _this49;
  }
  _inherits(Uh, _Ih);
  return _createClass(Uh);
}(Ih);
var Nh = exports.CompressedCubeTexture = /*#__PURE__*/function (_Ih2) {
  function Nh(t, e, n) {
    var _this50;
    _classCallCheck(this, Nh);
    _this50 = _callSuper(this, Nh, [void 0, t[0].width, t[0].height, e, n, ot]), _this50.isCompressedCubeTexture = !0, _this50.isCubeTexture = !0, _this50.image = t;
    return _this50;
  }
  _inherits(Nh, _Ih2);
  return _createClass(Nh);
}(Ih);
var Dh = exports.CanvasTexture = /*#__PURE__*/function (_Si9) {
  function Dh(t, e, n, i, r, s, a, o, l) {
    var _this51;
    _classCallCheck(this, Dh);
    _this51 = _callSuper(this, Dh, [t, e, n, i, r, s, a, o, l]), _this51.isCanvasTexture = !0, _this51.needsUpdate = !0;
    return _this51;
  }
  _inherits(Dh, _Si9);
  return _createClass(Dh);
}(Si);
var Oh = exports.Curve = /*#__PURE__*/function () {
  function Oh() {
    _classCallCheck(this, Oh);
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  return _createClass(Oh, [{
    key: "getPoint",
    value: function getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
  }, {
    key: "getPointAt",
    value: function getPointAt(t, e) {
      var n = this.getUtoTmapping(t);
      return this.getPoint(n, e);
    }
  }, {
    key: "getPoints",
    value: function getPoints() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
      var e = [];
      for (var _n158 = 0; _n158 <= t; _n158++) e.push(this.getPoint(_n158 / t));
      return e;
    }
  }, {
    key: "getSpacedPoints",
    value: function getSpacedPoints() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
      var e = [];
      for (var _n159 = 0; _n159 <= t; _n159++) e.push(this.getPointAt(_n159 / t));
      return e;
    }
  }, {
    key: "getLength",
    value: function getLength() {
      var t = this.getLengths();
      return t[t.length - 1];
    }
  }, {
    key: "getLengths",
    value: function getLengths() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.arcLengthDivisions;
      if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
      this.needsUpdate = !1;
      var e = [];
      var n,
        i = this.getPoint(0),
        r = 0;
      e.push(0);
      for (var _s59 = 1; _s59 <= t; _s59++) n = this.getPoint(_s59 / t), r += n.distanceTo(i), e.push(r), i = n;
      return this.cacheArcLengths = e, e;
    }
  }, {
    key: "updateArcLengths",
    value: function updateArcLengths() {
      this.needsUpdate = !0, this.getLengths();
    }
  }, {
    key: "getUtoTmapping",
    value: function getUtoTmapping(t, e) {
      var n = this.getLengths();
      var i = 0;
      var r = n.length;
      var s;
      s = e || t * n[r - 1];
      var a,
        o = 0,
        l = r - 1;
      for (; o <= l;) if (i = Math.floor(o + (l - o) / 2), a = n[i] - s, a < 0) o = i + 1;else {
        if (!(a > 0)) {
          l = i;
          break;
        }
        l = i - 1;
      }
      if (i = l, n[i] === s) return i / (r - 1);
      var c = n[i];
      return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
    }
  }, {
    key: "getTangent",
    value: function getTangent(t, e) {
      var n = 1e-4;
      var i = t - n,
        r = t + n;
      i < 0 && (i = 0), r > 1 && (r = 1);
      var s = this.getPoint(i),
        a = this.getPoint(r),
        o = e || (s.isVector2 ? new Qn() : new Ii());
      return o.copy(a).sub(s).normalize(), o;
    }
  }, {
    key: "getTangentAt",
    value: function getTangentAt(t, e) {
      var n = this.getUtoTmapping(t);
      return this.getTangent(n, e);
    }
  }, {
    key: "computeFrenetFrames",
    value: function computeFrenetFrames(t, e) {
      var n = new Ii(),
        i = [],
        r = [],
        s = [],
        a = new Ii(),
        o = new lr();
      for (var _e176 = 0; _e176 <= t; _e176++) {
        var _n160 = _e176 / t;
        i[_e176] = this.getTangentAt(_n160, new Ii());
      }
      r[0] = new Ii(), s[0] = new Ii();
      var l = Number.MAX_VALUE;
      var c = Math.abs(i[0].x),
        h = Math.abs(i[0].y),
        u = Math.abs(i[0].z);
      c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]);
      for (var _e177 = 1; _e177 <= t; _e177++) {
        if (r[_e177] = r[_e177 - 1].clone(), s[_e177] = s[_e177 - 1].clone(), a.crossVectors(i[_e177 - 1], i[_e177]), a.length() > Number.EPSILON) {
          a.normalize();
          var _t186 = Math.acos(Xn(i[_e177 - 1].dot(i[_e177]), -1, 1));
          r[_e177].applyMatrix4(o.makeRotationAxis(a, _t186));
        }
        s[_e177].crossVectors(i[_e177], r[_e177]);
      }
      if (!0 === e) {
        var _e178 = Math.acos(Xn(r[0].dot(r[t]), -1, 1));
        _e178 /= t, i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (_e178 = -_e178);
        for (var _n161 = 1; _n161 <= t; _n161++) r[_n161].applyMatrix4(o.makeRotationAxis(i[_n161], _e178 * _n161)), s[_n161].crossVectors(i[_n161], r[_n161]);
      }
      return {
        tangents: i,
        normals: r,
        binormals: s
      };
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {
        metadata: {
          version: 4.6,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
  }]);
}();
var Fh = exports.EllipseCurve = /*#__PURE__*/function (_Oh) {
  function Fh() {
    var _this52;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2 * Math.PI;
    var a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    _classCallCheck(this, Fh);
    _this52 = _callSuper(this, Fh), _this52.isEllipseCurve = !0, _this52.type = "EllipseCurve", _this52.aX = t, _this52.aY = e, _this52.xRadius = n, _this52.yRadius = i, _this52.aStartAngle = r, _this52.aEndAngle = s, _this52.aClockwise = a, _this52.aRotation = o;
    return _this52;
  }
  _inherits(Fh, _Oh);
  return _createClass(Fh, [{
    key: "getPoint",
    value: function getPoint(t, e) {
      var n = e || new Qn(),
        i = 2 * Math.PI;
      var r = this.aEndAngle - this.aStartAngle;
      var s = Math.abs(r) < Number.EPSILON;
      for (; r < 0;) r += i;
      for (; r > i;) r -= i;
      r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
      var a = this.aStartAngle + t * r;
      var o = this.aX + this.xRadius * Math.cos(a),
        l = this.aY + this.yRadius * Math.sin(a);
      if (0 !== this.aRotation) {
        var _t187 = Math.cos(this.aRotation),
          _e179 = Math.sin(this.aRotation),
          _n162 = o - this.aX,
          _i142 = l - this.aY;
        o = _n162 * _t187 - _i142 * _e179 + this.aX, l = _n162 * _e179 + _i142 * _t187 + this.aY;
      }
      return n.set(o, l);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Fh.prototype), "copy", this).call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Fh.prototype), "toJSON", this).call(this);
      return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return _get(_getPrototypeOf(Fh.prototype), "fromJSON", this).call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
    }
  }]);
}(Oh);
var Bh = exports.ArcCurve = /*#__PURE__*/function (_Fh) {
  function Bh(t, e, n, i, r, s) {
    var _this53;
    _classCallCheck(this, Bh);
    _this53 = _callSuper(this, Bh, [t, e, n, n, i, r, s]), _this53.isArcCurve = !0, _this53.type = "ArcCurve";
    return _this53;
  }
  _inherits(Bh, _Fh);
  return _createClass(Bh);
}(Fh);
function zh() {
  var t = 0,
    e = 0,
    n = 0,
    i = 0;
  function r(r, s, a, o) {
    t = r, e = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o;
  }
  return {
    initCatmullRom: function initCatmullRom(t, e, n, i, s) {
      r(e, n, s * (n - t), s * (i - e));
    },
    initNonuniformCatmullRom: function initNonuniformCatmullRom(t, e, n, i, s, a, o) {
      var l = (e - t) / s - (n - t) / (s + a) + (n - e) / a,
        c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;
      l *= a, c *= a, r(e, n, l, c);
    },
    calc: function calc(r) {
      var s = r * r;
      return t + e * r + n * s + i * (s * r);
    }
  };
}
var Hh = new Ii(),
  Vh = new zh(),
  kh = new zh(),
  Gh = new zh();
var Wh = exports.CatmullRomCurve3 = /*#__PURE__*/function (_Oh2) {
  function Wh() {
    var _this54;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "centripetal";
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    _classCallCheck(this, Wh);
    _this54 = _callSuper(this, Wh), _this54.isCatmullRomCurve3 = !0, _this54.type = "CatmullRomCurve3", _this54.points = t, _this54.closed = e, _this54.curveType = n, _this54.tension = i;
    return _this54;
  }
  _inherits(Wh, _Oh2);
  return _createClass(Wh, [{
    key: "getPoint",
    value: function getPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
      var n = e,
        i = this.points,
        r = i.length,
        s = (r - (this.closed ? 0 : 1)) * t;
      var a,
        o,
        l = Math.floor(s),
        c = s - l;
      this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (Hh.subVectors(i[0], i[1]).add(i[0]), a = Hh);
      var h = i[l % r],
        u = i[(l + 1) % r];
      if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (Hh.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = Hh), "centripetal" === this.curveType || "chordal" === this.curveType) {
        var _t188 = "chordal" === this.curveType ? .5 : .25;
        var _e180 = Math.pow(a.distanceToSquared(h), _t188),
          _n163 = Math.pow(h.distanceToSquared(u), _t188),
          _i143 = Math.pow(u.distanceToSquared(o), _t188);
        _n163 < 1e-4 && (_n163 = 1), _e180 < 1e-4 && (_e180 = _n163), _i143 < 1e-4 && (_i143 = _n163), Vh.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, _e180, _n163, _i143), kh.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, _e180, _n163, _i143), Gh.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, _e180, _n163, _i143);
      } else "catmullrom" === this.curveType && (Vh.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), kh.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), Gh.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
      return n.set(Vh.calc(c), kh.calc(c), Gh.calc(c)), n;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      _get(_getPrototypeOf(Wh.prototype), "copy", this).call(this, t), this.points = [];
      for (var _e181 = 0, _n164 = t.points.length; _e181 < _n164; _e181++) {
        var _n165 = t.points[_e181];
        this.points.push(_n165.clone());
      }
      return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Wh.prototype), "toJSON", this).call(this);
      t.points = [];
      for (var _e182 = 0, _n166 = this.points.length; _e182 < _n166; _e182++) {
        var _n167 = this.points[_e182];
        t.points.push(_n167.toArray());
      }
      return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      _get(_getPrototypeOf(Wh.prototype), "fromJSON", this).call(this, t), this.points = [];
      for (var _e183 = 0, _n168 = t.points.length; _e183 < _n168; _e183++) {
        var _n169 = t.points[_e183];
        this.points.push(new Ii().fromArray(_n169));
      }
      return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
    }
  }]);
}(Oh);
function Xh(t, e, n, i, r) {
  var s = .5 * (i - e),
    a = .5 * (r - n),
    o = t * t;
  return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n;
}
function jh(t, e, n, i) {
  return function (t, e) {
    var n = 1 - t;
    return n * n * e;
  }(t, e) + function (t, e) {
    return 2 * (1 - t) * t * e;
  }(t, n) + function (t, e) {
    return t * t * e;
  }(t, i);
}
function qh(t, e, n, i, r) {
  return function (t, e) {
    var n = 1 - t;
    return n * n * n * e;
  }(t, e) + function (t, e) {
    var n = 1 - t;
    return 3 * n * n * t * e;
  }(t, n) + function (t, e) {
    return 3 * (1 - t) * t * t * e;
  }(t, i) + function (t, e) {
    return t * t * t * e;
  }(t, r);
}
var Yh = exports.CubicBezierCurve = /*#__PURE__*/function (_Oh3) {
  function Yh() {
    var _this55;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Qn();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn();
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Qn();
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Qn();
    _classCallCheck(this, Yh);
    _this55 = _callSuper(this, Yh), _this55.isCubicBezierCurve = !0, _this55.type = "CubicBezierCurve", _this55.v0 = t, _this55.v1 = e, _this55.v2 = n, _this55.v3 = i;
    return _this55;
  }
  _inherits(Yh, _Oh3);
  return _createClass(Yh, [{
    key: "getPoint",
    value: function getPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn();
      var n = e,
        i = this.v0,
        r = this.v1,
        s = this.v2,
        a = this.v3;
      return n.set(qh(t, i.x, r.x, s.x, a.x), qh(t, i.y, r.y, s.y, a.y)), n;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Yh.prototype), "copy", this).call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Yh.prototype), "toJSON", this).call(this);
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return _get(_getPrototypeOf(Yh.prototype), "fromJSON", this).call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
    }
  }]);
}(Oh);
var Zh = exports.CubicBezierCurve3 = /*#__PURE__*/function (_Oh4) {
  function Zh() {
    var _this56;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Ii();
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Ii();
    _classCallCheck(this, Zh);
    _this56 = _callSuper(this, Zh), _this56.isCubicBezierCurve3 = !0, _this56.type = "CubicBezierCurve3", _this56.v0 = t, _this56.v1 = e, _this56.v2 = n, _this56.v3 = i;
    return _this56;
  }
  _inherits(Zh, _Oh4);
  return _createClass(Zh, [{
    key: "getPoint",
    value: function getPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
      var n = e,
        i = this.v0,
        r = this.v1,
        s = this.v2,
        a = this.v3;
      return n.set(qh(t, i.x, r.x, s.x, a.x), qh(t, i.y, r.y, s.y, a.y), qh(t, i.z, r.z, s.z, a.z)), n;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Zh.prototype), "copy", this).call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Zh.prototype), "toJSON", this).call(this);
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return _get(_getPrototypeOf(Zh.prototype), "fromJSON", this).call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
    }
  }]);
}(Oh);
var Jh = exports.LineCurve = /*#__PURE__*/function (_Oh5) {
  function Jh() {
    var _this57;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Qn();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn();
    _classCallCheck(this, Jh);
    _this57 = _callSuper(this, Jh), _this57.isLineCurve = !0, _this57.type = "LineCurve", _this57.v1 = t, _this57.v2 = e;
    return _this57;
  }
  _inherits(Jh, _Oh5);
  return _createClass(Jh, [{
    key: "getPoint",
    value: function getPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn();
      var n = e;
      return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
    }
  }, {
    key: "getPointAt",
    value: function getPointAt(t, e) {
      return this.getPoint(t, e);
    }
  }, {
    key: "getTangent",
    value: function getTangent(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn();
      return e.subVectors(this.v2, this.v1).normalize();
    }
  }, {
    key: "getTangentAt",
    value: function getTangentAt(t, e) {
      return this.getTangent(t, e);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Jh.prototype), "copy", this).call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Jh.prototype), "toJSON", this).call(this);
      return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return _get(_getPrototypeOf(Jh.prototype), "fromJSON", this).call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
  }]);
}(Oh);
var Kh = exports.LineCurve3 = /*#__PURE__*/function (_Oh6) {
  function Kh() {
    var _this58;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
    _classCallCheck(this, Kh);
    _this58 = _callSuper(this, Kh), _this58.isLineCurve3 = !0, _this58.type = "LineCurve3", _this58.v1 = t, _this58.v2 = e;
    return _this58;
  }
  _inherits(Kh, _Oh6);
  return _createClass(Kh, [{
    key: "getPoint",
    value: function getPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
      var n = e;
      return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
    }
  }, {
    key: "getPointAt",
    value: function getPointAt(t, e) {
      return this.getPoint(t, e);
    }
  }, {
    key: "getTangent",
    value: function getTangent(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
      return e.subVectors(this.v2, this.v1).normalize();
    }
  }, {
    key: "getTangentAt",
    value: function getTangentAt(t, e) {
      return this.getTangent(t, e);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Kh.prototype), "copy", this).call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Kh.prototype), "toJSON", this).call(this);
      return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return _get(_getPrototypeOf(Kh.prototype), "fromJSON", this).call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
  }]);
}(Oh);
var $h = exports.QuadraticBezierCurve = /*#__PURE__*/function (_Oh7) {
  function $h() {
    var _this59;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Qn();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn();
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Qn();
    _classCallCheck(this, $h);
    _this59 = _callSuper(this, $h), _this59.isQuadraticBezierCurve = !0, _this59.type = "QuadraticBezierCurve", _this59.v0 = t, _this59.v1 = e, _this59.v2 = n;
    return _this59;
  }
  _inherits($h, _Oh7);
  return _createClass($h, [{
    key: "getPoint",
    value: function getPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn();
      var n = e,
        i = this.v0,
        r = this.v1,
        s = this.v2;
      return n.set(jh(t, i.x, r.x, s.x), jh(t, i.y, r.y, s.y)), n;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf($h.prototype), "copy", this).call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf($h.prototype), "toJSON", this).call(this);
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return _get(_getPrototypeOf($h.prototype), "fromJSON", this).call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
  }]);
}(Oh);
var Qh = exports.QuadraticBezierCurve3 = /*#__PURE__*/function (_Oh8) {
  function Qh() {
    var _this60;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Ii();
    _classCallCheck(this, Qh);
    _this60 = _callSuper(this, Qh), _this60.isQuadraticBezierCurve3 = !0, _this60.type = "QuadraticBezierCurve3", _this60.v0 = t, _this60.v1 = e, _this60.v2 = n;
    return _this60;
  }
  _inherits(Qh, _Oh8);
  return _createClass(Qh, [{
    key: "getPoint",
    value: function getPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
      var n = e,
        i = this.v0,
        r = this.v1,
        s = this.v2;
      return n.set(jh(t, i.x, r.x, s.x), jh(t, i.y, r.y, s.y), jh(t, i.z, r.z, s.z)), n;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Qh.prototype), "copy", this).call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Qh.prototype), "toJSON", this).call(this);
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return _get(_getPrototypeOf(Qh.prototype), "fromJSON", this).call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
  }]);
}(Oh);
var tu = exports.SplineCurve = /*#__PURE__*/function (_Oh9) {
  function tu() {
    var _this61;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    _classCallCheck(this, tu);
    _this61 = _callSuper(this, tu), _this61.isSplineCurve = !0, _this61.type = "SplineCurve", _this61.points = t;
    return _this61;
  }
  _inherits(tu, _Oh9);
  return _createClass(tu, [{
    key: "getPoint",
    value: function getPoint(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn();
      var n = e,
        i = this.points,
        r = (i.length - 1) * t,
        s = Math.floor(r),
        a = r - s,
        o = i[0 === s ? s : s - 1],
        l = i[s],
        c = i[s > i.length - 2 ? i.length - 1 : s + 1],
        h = i[s > i.length - 3 ? i.length - 1 : s + 2];
      return n.set(Xh(a, o.x, l.x, c.x, h.x), Xh(a, o.y, l.y, c.y, h.y)), n;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      _get(_getPrototypeOf(tu.prototype), "copy", this).call(this, t), this.points = [];
      for (var _e184 = 0, _n170 = t.points.length; _e184 < _n170; _e184++) {
        var _n171 = t.points[_e184];
        this.points.push(_n171.clone());
      }
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(tu.prototype), "toJSON", this).call(this);
      t.points = [];
      for (var _e185 = 0, _n172 = this.points.length; _e185 < _n172; _e185++) {
        var _n173 = this.points[_e185];
        t.points.push(_n173.toArray());
      }
      return t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      _get(_getPrototypeOf(tu.prototype), "fromJSON", this).call(this, t), this.points = [];
      for (var _e186 = 0, _n174 = t.points.length; _e186 < _n174; _e186++) {
        var _n175 = t.points[_e186];
        this.points.push(new Qn().fromArray(_n175));
      }
      return this;
    }
  }]);
}(Oh);
var eu = Object.freeze({
  __proto__: null,
  ArcCurve: Bh,
  CatmullRomCurve3: Wh,
  CubicBezierCurve: Yh,
  CubicBezierCurve3: Zh,
  EllipseCurve: Fh,
  LineCurve: Jh,
  LineCurve3: Kh,
  QuadraticBezierCurve: $h,
  QuadraticBezierCurve3: Qh,
  SplineCurve: tu
});
var nu = exports.CurvePath = /*#__PURE__*/function (_Oh10) {
  function nu() {
    var _this62;
    _classCallCheck(this, nu);
    _this62 = _callSuper(this, nu), _this62.type = "CurvePath", _this62.curves = [], _this62.autoClose = !1;
    return _this62;
  }
  _inherits(nu, _Oh10);
  return _createClass(nu, [{
    key: "add",
    value: function add(t) {
      this.curves.push(t);
    }
  }, {
    key: "closePath",
    value: function closePath() {
      var t = this.curves[0].getPoint(0),
        e = this.curves[this.curves.length - 1].getPoint(1);
      if (!t.equals(e)) {
        var _n176 = !0 === t.isVector2 ? "LineCurve" : "LineCurve3";
        this.curves.push(new eu[_n176](e, t));
      }
      return this;
    }
  }, {
    key: "getPoint",
    value: function getPoint(t, e) {
      var n = t * this.getLength(),
        i = this.getCurveLengths();
      var r = 0;
      for (; r < i.length;) {
        if (i[r] >= n) {
          var _t189 = i[r] - n,
            _s60 = this.curves[r],
            _a46 = _s60.getLength(),
            _o34 = 0 === _a46 ? 0 : 1 - _t189 / _a46;
          return _s60.getPointAt(_o34, e);
        }
        r++;
      }
      return null;
    }
  }, {
    key: "getLength",
    value: function getLength() {
      var t = this.getCurveLengths();
      return t[t.length - 1];
    }
  }, {
    key: "updateArcLengths",
    value: function updateArcLengths() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    }
  }, {
    key: "getCurveLengths",
    value: function getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
      var t = [];
      var e = 0;
      for (var _n177 = 0, _i144 = this.curves.length; _n177 < _i144; _n177++) e += this.curves[_n177].getLength(), t.push(e);
      return this.cacheLengths = t, t;
    }
  }, {
    key: "getSpacedPoints",
    value: function getSpacedPoints() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;
      var e = [];
      for (var _n178 = 0; _n178 <= t; _n178++) e.push(this.getPoint(_n178 / t));
      return this.autoClose && e.push(e[0]), e;
    }
  }, {
    key: "getPoints",
    value: function getPoints() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;
      var e = [];
      var n;
      for (var _i145 = 0, _r108 = this.curves; _i145 < _r108.length; _i145++) {
        var _s61 = _r108[_i145],
          _a47 = _s61.isEllipseCurve ? 2 * t : _s61.isLineCurve || _s61.isLineCurve3 ? 1 : _s61.isSplineCurve ? t * _s61.points.length : t,
          _o35 = _s61.getPoints(_a47);
        for (var _t190 = 0; _t190 < _o35.length; _t190++) {
          var _i146 = _o35[_t190];
          n && n.equals(_i146) || (e.push(_i146), n = _i146);
        }
      }
      return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      _get(_getPrototypeOf(nu.prototype), "copy", this).call(this, t), this.curves = [];
      for (var _e187 = 0, _n179 = t.curves.length; _e187 < _n179; _e187++) {
        var _n180 = t.curves[_e187];
        this.curves.push(_n180.clone());
      }
      return this.autoClose = t.autoClose, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(nu.prototype), "toJSON", this).call(this);
      t.autoClose = this.autoClose, t.curves = [];
      for (var _e188 = 0, _n181 = this.curves.length; _e188 < _n181; _e188++) {
        var _n182 = this.curves[_e188];
        t.curves.push(_n182.toJSON());
      }
      return t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      _get(_getPrototypeOf(nu.prototype), "fromJSON", this).call(this, t), this.autoClose = t.autoClose, this.curves = [];
      for (var _e189 = 0, _n183 = t.curves.length; _e189 < _n183; _e189++) {
        var _n184 = t.curves[_e189];
        this.curves.push(new eu[_n184.type]().fromJSON(_n184));
      }
      return this;
    }
  }]);
}(Oh);
var iu = exports.Path = /*#__PURE__*/function (_nu) {
  function iu(t) {
    var _this63;
    _classCallCheck(this, iu);
    _this63 = _callSuper(this, iu), _this63.type = "Path", _this63.currentPoint = new Qn(), t && _this63.setFromPoints(t);
    return _this63;
  }
  _inherits(iu, _nu);
  return _createClass(iu, [{
    key: "setFromPoints",
    value: function setFromPoints(t) {
      this.moveTo(t[0].x, t[0].y);
      for (var _e190 = 1, _n185 = t.length; _e190 < _n185; _e190++) this.lineTo(t[_e190].x, t[_e190].y);
      return this;
    }
  }, {
    key: "moveTo",
    value: function moveTo(t, e) {
      return this.currentPoint.set(t, e), this;
    }
  }, {
    key: "lineTo",
    value: function lineTo(t, e) {
      var n = new Jh(this.currentPoint.clone(), new Qn(t, e));
      return this.curves.push(n), this.currentPoint.set(t, e), this;
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(t, e, n, i) {
      var r = new $h(this.currentPoint.clone(), new Qn(t, e), new Qn(n, i));
      return this.curves.push(r), this.currentPoint.set(n, i), this;
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(t, e, n, i, r, s) {
      var a = new Yh(this.currentPoint.clone(), new Qn(t, e), new Qn(n, i), new Qn(r, s));
      return this.curves.push(a), this.currentPoint.set(r, s), this;
    }
  }, {
    key: "splineThru",
    value: function splineThru(t) {
      var e = [this.currentPoint.clone()].concat(t),
        n = new tu(e);
      return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
    }
  }, {
    key: "arc",
    value: function arc(t, e, n, i, r, s) {
      var a = this.currentPoint.x,
        o = this.currentPoint.y;
      return this.absarc(t + a, e + o, n, i, r, s), this;
    }
  }, {
    key: "absarc",
    value: function absarc(t, e, n, i, r, s) {
      return this.absellipse(t, e, n, n, i, r, s), this;
    }
  }, {
    key: "ellipse",
    value: function ellipse(t, e, n, i, r, s, a, o) {
      var l = this.currentPoint.x,
        c = this.currentPoint.y;
      return this.absellipse(t + l, e + c, n, i, r, s, a, o), this;
    }
  }, {
    key: "absellipse",
    value: function absellipse(t, e, n, i, r, s, a, o) {
      var l = new Fh(t, e, n, i, r, s, a, o);
      if (this.curves.length > 0) {
        var _t191 = l.getPoint(0);
        _t191.equals(this.currentPoint) || this.lineTo(_t191.x, _t191.y);
      }
      this.curves.push(l);
      var c = l.getPoint(1);
      return this.currentPoint.copy(c), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(iu.prototype), "copy", this).call(this, t), this.currentPoint.copy(t.currentPoint), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(iu.prototype), "toJSON", this).call(this);
      return t.currentPoint = this.currentPoint.toArray(), t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return _get(_getPrototypeOf(iu.prototype), "fromJSON", this).call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
    }
  }]);
}(nu);
var ru = exports.LatheGeometry = /*#__PURE__*/function (_Ts3) {
  function ru() {
    var _this64;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [new Qn(0, -.5), new Qn(.5, 0), new Qn(0, .5)];
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2 * Math.PI;
    _classCallCheck(this, ru);
    _this64 = _callSuper(this, ru), _this64.type = "LatheGeometry", _this64.parameters = {
      points: t,
      segments: e,
      phiStart: n,
      phiLength: i
    }, e = Math.floor(e), i = Xn(i, 0, 2 * Math.PI);
    var r = [],
      s = [],
      a = [],
      o = [],
      l = [],
      c = 1 / e,
      h = new Ii(),
      u = new Qn(),
      d = new Ii(),
      p = new Ii(),
      m = new Ii();
    var f = 0,
      g = 0;
    for (var _e191 = 0; _e191 <= t.length - 1; _e191++) switch (_e191) {
      case 0:
        f = t[_e191 + 1].x - t[_e191].x, g = t[_e191 + 1].y - t[_e191].y, d.x = 1 * g, d.y = -f, d.z = 0 * g, m.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
        break;
      case t.length - 1:
        o.push(m.x, m.y, m.z);
        break;
      default:
        f = t[_e191 + 1].x - t[_e191].x, g = t[_e191 + 1].y - t[_e191].y, d.x = 1 * g, d.y = -f, d.z = 0 * g, p.copy(d), d.x += m.x, d.y += m.y, d.z += m.z, d.normalize(), o.push(d.x, d.y, d.z), m.copy(p);
    }
    for (var _r109 = 0; _r109 <= e; _r109++) {
      var _d11 = n + _r109 * c * i,
        _p11 = Math.sin(_d11),
        _m7 = Math.cos(_d11);
      for (var _n186 = 0; _n186 <= t.length - 1; _n186++) {
        h.x = t[_n186].x * _p11, h.y = t[_n186].y, h.z = t[_n186].x * _m7, s.push(h.x, h.y, h.z), u.x = _r109 / e, u.y = _n186 / (t.length - 1), a.push(u.x, u.y);
        var _i147 = o[3 * _n186 + 0] * _p11,
          _c19 = o[3 * _n186 + 1],
          _d12 = o[3 * _n186 + 0] * _m7;
        l.push(_i147, _c19, _d12);
      }
    }
    for (var _n187 = 0; _n187 < e; _n187++) for (var _e192 = 0; _e192 < t.length - 1; _e192++) {
      var _i148 = _e192 + _n187 * t.length,
        _s62 = _i148,
        _a48 = _i148 + t.length,
        _o36 = _i148 + t.length + 1,
        _l19 = _i148 + 1;
      r.push(_s62, _a48, _l19), r.push(_o36, _l19, _a48);
    }
    _this64.setIndex(r), _this64.setAttribute("position", new gs(s, 3)), _this64.setAttribute("uv", new gs(a, 2)), _this64.setAttribute("normal", new gs(l, 3));
    return _this64;
  }
  _inherits(ru, _Ts3);
  return _createClass(ru, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(ru.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new ru(t.points, t.segments, t.phiStart, t.phiLength);
    }
  }]);
}(Ts);
var su = exports.CapsuleGeometry = /*#__PURE__*/function (_ru) {
  function su() {
    var _this65;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
    _classCallCheck(this, su);
    var r = new iu();
    r.absarc(0, -e / 2, t, 1.5 * Math.PI, 0), r.absarc(0, e / 2, t, 0, .5 * Math.PI), _this65 = _callSuper(this, su, [r.getPoints(n), i]), _this65.type = "CapsuleGeometry", _this65.parameters = {
      radius: t,
      length: e,
      capSegments: n,
      radialSegments: i
    };
    return _this65;
  }
  _inherits(su, _ru);
  return _createClass(su, null, [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new su(t.radius, t.length, t.capSegments, t.radialSegments);
    }
  }]);
}(ru);
var au = exports.CircleGeometry = /*#__PURE__*/function (_Ts4) {
  function au() {
    var _this66;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2 * Math.PI;
    _classCallCheck(this, au);
    _this66 = _callSuper(this, au), _this66.type = "CircleGeometry", _this66.parameters = {
      radius: t,
      segments: e,
      thetaStart: n,
      thetaLength: i
    }, e = Math.max(3, e);
    var r = [],
      s = [],
      a = [],
      o = [],
      l = new Ii(),
      c = new Qn();
    s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5);
    for (var _r110 = 0, _h11 = 3; _r110 <= e; _r110++, _h11 += 3) {
      var _u10 = n + _r110 / e * i;
      l.x = t * Math.cos(_u10), l.y = t * Math.sin(_u10), s.push(l.x, l.y, l.z), a.push(0, 0, 1), c.x = (s[_h11] / t + 1) / 2, c.y = (s[_h11 + 1] / t + 1) / 2, o.push(c.x, c.y);
    }
    for (var _t192 = 1; _t192 <= e; _t192++) r.push(_t192, _t192 + 1, 0);
    _this66.setIndex(r), _this66.setAttribute("position", new gs(s, 3)), _this66.setAttribute("normal", new gs(a, 3)), _this66.setAttribute("uv", new gs(o, 2));
    return _this66;
  }
  _inherits(au, _Ts4);
  return _createClass(au, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(au.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new au(t.radius, t.segments, t.thetaStart, t.thetaLength);
    }
  }]);
}(Ts);
var ou = exports.CylinderGeometry = /*#__PURE__*/function (_Ts5) {
  function ou() {
    var _this67;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
    var a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 2 * Math.PI;
    _classCallCheck(this, ou);
    _this67 = _callSuper(this, ou), _this67.type = "CylinderGeometry", _this67.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: s,
      thetaStart: a,
      thetaLength: o
    };
    var l = _this67;
    i = Math.floor(i), r = Math.floor(r);
    var c = [],
      h = [],
      u = [],
      d = [];
    var p = 0;
    var m = [],
      f = n / 2;
    var g = 0;
    function _(n) {
      var r = p,
        s = new Qn(),
        m = new Ii();
      var _ = 0;
      var v = !0 === n ? t : e,
        x = !0 === n ? 1 : -1;
      for (var _t193 = 1; _t193 <= i; _t193++) h.push(0, f * x, 0), u.push(0, x, 0), d.push(.5, .5), p++;
      var y = p;
      for (var _t194 = 0; _t194 <= i; _t194++) {
        var _e193 = _t194 / i * o + a,
          _n188 = Math.cos(_e193),
          _r111 = Math.sin(_e193);
        m.x = v * _r111, m.y = f * x, m.z = v * _n188, h.push(m.x, m.y, m.z), u.push(0, x, 0), s.x = .5 * _n188 + .5, s.y = .5 * _r111 * x + .5, d.push(s.x, s.y), p++;
      }
      for (var _t195 = 0; _t195 < i; _t195++) {
        var _e194 = r + _t195,
          _i149 = y + _t195;
        !0 === n ? c.push(_i149, _i149 + 1, _e194) : c.push(_i149 + 1, _i149, _e194), _ += 3;
      }
      l.addGroup(g, _, !0 === n ? 1 : 2), g += _;
    }
    !function () {
      var s = new Ii(),
        _ = new Ii();
      var v = 0;
      var x = (e - t) / n;
      for (var _l20 = 0; _l20 <= r; _l20++) {
        var _c20 = [],
          _g4 = _l20 / r,
          _v4 = _g4 * (e - t) + t;
        for (var _t196 = 0; _t196 <= i; _t196++) {
          var _e195 = _t196 / i,
            _r112 = _e195 * o + a,
            _l21 = Math.sin(_r112),
            _m8 = Math.cos(_r112);
          _.x = _v4 * _l21, _.y = -_g4 * n + f, _.z = _v4 * _m8, h.push(_.x, _.y, _.z), s.set(_l21, x, _m8).normalize(), u.push(s.x, s.y, s.z), d.push(_e195, 1 - _g4), _c20.push(p++);
        }
        m.push(_c20);
      }
      for (var _t197 = 0; _t197 < i; _t197++) for (var _e196 = 0; _e196 < r; _e196++) {
        var _n189 = m[_e196][_t197],
          _i150 = m[_e196 + 1][_t197],
          _r113 = m[_e196 + 1][_t197 + 1],
          _s63 = m[_e196][_t197 + 1];
        c.push(_n189, _i150, _s63), c.push(_i150, _r113, _s63), v += 6;
      }
      l.addGroup(g, v, 0), g += v;
    }(), !1 === s && (t > 0 && _(!0), e > 0 && _(!1)), _this67.setIndex(c), _this67.setAttribute("position", new gs(h, 3)), _this67.setAttribute("normal", new gs(u, 3)), _this67.setAttribute("uv", new gs(d, 2));
    return _this67;
  }
  _inherits(ou, _Ts5);
  return _createClass(ou, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(ou.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new ou(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
    }
  }]);
}(Ts);
var lu = exports.ConeGeometry = /*#__PURE__*/function (_ou) {
  function lu() {
    var _this68;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 2 * Math.PI;
    _classCallCheck(this, lu);
    _this68 = _callSuper(this, lu, [0, t, e, n, i, r, s, a]), _this68.type = "ConeGeometry", _this68.parameters = {
      radius: t,
      height: e,
      radialSegments: n,
      heightSegments: i,
      openEnded: r,
      thetaStart: s,
      thetaLength: a
    };
    return _this68;
  }
  _inherits(lu, _ou);
  return _createClass(lu, null, [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new lu(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
    }
  }]);
}(ou);
var cu = exports.PolyhedronGeometry = /*#__PURE__*/function (_Ts6) {
  function cu() {
    var _this69;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    _classCallCheck(this, cu);
    _this69 = _callSuper(this, cu), _this69.type = "PolyhedronGeometry", _this69.parameters = {
      vertices: t,
      indices: e,
      radius: n,
      detail: i
    };
    var r = [],
      s = [];
    function a(t, e, n, i) {
      var r = i + 1,
        s = [];
      for (var _i151 = 0; _i151 <= r; _i151++) {
        s[_i151] = [];
        var _a49 = t.clone().lerp(n, _i151 / r),
          _o37 = e.clone().lerp(n, _i151 / r),
          _l22 = r - _i151;
        for (var _t198 = 0; _t198 <= _l22; _t198++) s[_i151][_t198] = 0 === _t198 && _i151 === r ? _a49 : _a49.clone().lerp(_o37, _t198 / _l22);
      }
      for (var _t199 = 0; _t199 < r; _t199++) for (var _e197 = 0; _e197 < 2 * (r - _t199) - 1; _e197++) {
        var _n190 = Math.floor(_e197 / 2);
        _e197 % 2 == 0 ? (o(s[_t199][_n190 + 1]), o(s[_t199 + 1][_n190]), o(s[_t199][_n190])) : (o(s[_t199][_n190 + 1]), o(s[_t199 + 1][_n190 + 1]), o(s[_t199 + 1][_n190]));
      }
    }
    function o(t) {
      r.push(t.x, t.y, t.z);
    }
    function l(e, n) {
      var i = 3 * e;
      n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2];
    }
    function c(t, e, n, i) {
      i < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + .5);
    }
    function h(t) {
      return Math.atan2(t.z, -t.x);
    }
    !function (t) {
      var n = new Ii(),
        i = new Ii(),
        r = new Ii();
      for (var _s64 = 0; _s64 < e.length; _s64 += 3) l(e[_s64 + 0], n), l(e[_s64 + 1], i), l(e[_s64 + 2], r), a(n, i, r, t);
    }(i), function (t) {
      var e = new Ii();
      for (var _n191 = 0; _n191 < r.length; _n191 += 3) e.x = r[_n191 + 0], e.y = r[_n191 + 1], e.z = r[_n191 + 2], e.normalize().multiplyScalar(t), r[_n191 + 0] = e.x, r[_n191 + 1] = e.y, r[_n191 + 2] = e.z;
    }(n), function () {
      var t = new Ii();
      for (var _n192 = 0; _n192 < r.length; _n192 += 3) {
        t.x = r[_n192 + 0], t.y = r[_n192 + 1], t.z = r[_n192 + 2];
        var _i152 = h(t) / 2 / Math.PI + .5,
          _a50 = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
        s.push(_i152, 1 - _a50);
      }
      var e;
      (function () {
        var t = new Ii(),
          e = new Ii(),
          n = new Ii(),
          i = new Ii(),
          a = new Qn(),
          o = new Qn(),
          l = new Qn();
        for (var _u11 = 0, _d13 = 0; _u11 < r.length; _u11 += 9, _d13 += 6) {
          t.set(r[_u11 + 0], r[_u11 + 1], r[_u11 + 2]), e.set(r[_u11 + 3], r[_u11 + 4], r[_u11 + 5]), n.set(r[_u11 + 6], r[_u11 + 7], r[_u11 + 8]), a.set(s[_d13 + 0], s[_d13 + 1]), o.set(s[_d13 + 2], s[_d13 + 3]), l.set(s[_d13 + 4], s[_d13 + 5]), i.copy(t).add(e).add(n).divideScalar(3);
          var _p12 = h(i);
          c(a, _d13 + 0, t, _p12), c(o, _d13 + 2, e, _p12), c(l, _d13 + 4, n, _p12);
        }
      })(), function () {
        for (var _t200 = 0; _t200 < s.length; _t200 += 6) {
          var _e198 = s[_t200 + 0],
            _n193 = s[_t200 + 2],
            _i153 = s[_t200 + 4],
            _r114 = Math.max(_e198, _n193, _i153),
            _a51 = Math.min(_e198, _n193, _i153);
          _r114 > .9 && _a51 < .1 && (_e198 < .2 && (s[_t200 + 0] += 1), _n193 < .2 && (s[_t200 + 2] += 1), _i153 < .2 && (s[_t200 + 4] += 1));
        }
      }();
    }(), _this69.setAttribute("position", new gs(r, 3)), _this69.setAttribute("normal", new gs(r.slice(), 3)), _this69.setAttribute("uv", new gs(s, 2)), 0 === i ? _this69.computeVertexNormals() : _this69.normalizeNormals();
    return _this69;
  }
  _inherits(cu, _Ts6);
  return _createClass(cu, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(cu.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new cu(t.vertices, t.indices, t.radius, t.details);
    }
  }]);
}(Ts);
var hu = exports.DodecahedronGeometry = /*#__PURE__*/function (_cu) {
  function hu() {
    var _this70;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, hu);
    var n = (1 + Math.sqrt(5)) / 2,
      i = 1 / n;
    _this70 = _callSuper(this, hu, [[-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e]), _this70.type = "DodecahedronGeometry", _this70.parameters = {
      radius: t,
      detail: e
    };
    return _this70;
  }
  _inherits(hu, _cu);
  return _createClass(hu, null, [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new hu(t.radius, t.detail);
    }
  }]);
}(cu);
var uu = new Ii(),
  du = new Ii(),
  pu = new Ii(),
  mu = new Wr();
var fu = exports.EdgesGeometry = /*#__PURE__*/function (_Ts7) {
  function fu() {
    var _this71;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    _classCallCheck(this, fu);
    if (_this71 = _callSuper(this, fu), _this71.type = "EdgesGeometry", _this71.parameters = {
      geometry: t,
      thresholdAngle: e
    }, null !== t) {
      var _n194 = 4,
        _i154 = Math.pow(10, _n194),
        _r115 = Math.cos(kn * e),
        _s65 = t.getIndex(),
        _a52 = t.getAttribute("position"),
        _o38 = _s65 ? _s65.count : _a52.count,
        _l23 = [0, 0, 0],
        _c21 = ["a", "b", "c"],
        _h12 = new Array(3),
        _u12 = {},
        _d14 = [];
      for (var _t201 = 0; _t201 < _o38; _t201 += 3) {
        _s65 ? (_l23[0] = _s65.getX(_t201), _l23[1] = _s65.getX(_t201 + 1), _l23[2] = _s65.getX(_t201 + 2)) : (_l23[0] = _t201, _l23[1] = _t201 + 1, _l23[2] = _t201 + 2);
        var _e199 = mu.a,
          _n195 = mu.b,
          _o39 = mu.c;
        if (_e199.fromBufferAttribute(_a52, _l23[0]), _n195.fromBufferAttribute(_a52, _l23[1]), _o39.fromBufferAttribute(_a52, _l23[2]), mu.getNormal(pu), _h12[0] = "".concat(Math.round(_e199.x * _i154), ",").concat(Math.round(_e199.y * _i154), ",").concat(Math.round(_e199.z * _i154)), _h12[1] = "".concat(Math.round(_n195.x * _i154), ",").concat(Math.round(_n195.y * _i154), ",").concat(Math.round(_n195.z * _i154)), _h12[2] = "".concat(Math.round(_o39.x * _i154), ",").concat(Math.round(_o39.y * _i154), ",").concat(Math.round(_o39.z * _i154)), _h12[0] !== _h12[1] && _h12[1] !== _h12[2] && _h12[2] !== _h12[0]) for (var _t202 = 0; _t202 < 3; _t202++) {
          var _e200 = (_t202 + 1) % 3,
            _n196 = _h12[_t202],
            _i155 = _h12[_e200],
            _s66 = mu[_c21[_t202]],
            _a53 = mu[_c21[_e200]],
            _o40 = "".concat(_n196, "_").concat(_i155),
            _p13 = "".concat(_i155, "_").concat(_n196);
          _p13 in _u12 && _u12[_p13] ? (pu.dot(_u12[_p13].normal) <= _r115 && (_d14.push(_s66.x, _s66.y, _s66.z), _d14.push(_a53.x, _a53.y, _a53.z)), _u12[_p13] = null) : _o40 in _u12 || (_u12[_o40] = {
            index0: _l23[_t202],
            index1: _l23[_e200],
            normal: pu.clone()
          });
        }
      }
      for (var _t203 in _u12) if (_u12[_t203]) {
        var _u12$_t = _u12[_t203],
          _e201 = _u12$_t.index0,
          _n197 = _u12$_t.index1;
        uu.fromBufferAttribute(_a52, _e201), du.fromBufferAttribute(_a52, _n197), _d14.push(uu.x, uu.y, uu.z), _d14.push(du.x, du.y, du.z);
      }
      _this71.setAttribute("position", new gs(_d14, 3));
    }
    return _assertThisInitialized(_this71);
  }
  _inherits(fu, _Ts7);
  return _createClass(fu, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(fu.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }]);
}(Ts);
var gu = exports.Shape = /*#__PURE__*/function (_iu) {
  function gu(t) {
    var _this72;
    _classCallCheck(this, gu);
    _this72 = _callSuper(this, gu, [t]), _this72.uuid = Wn(), _this72.type = "Shape", _this72.holes = [];
    return _this72;
  }
  _inherits(gu, _iu);
  return _createClass(gu, [{
    key: "getPointsHoles",
    value: function getPointsHoles(t) {
      var e = [];
      for (var _n198 = 0, _i156 = this.holes.length; _n198 < _i156; _n198++) e[_n198] = this.holes[_n198].getPoints(t);
      return e;
    }
  }, {
    key: "extractPoints",
    value: function extractPoints(t) {
      return {
        shape: this.getPoints(t),
        holes: this.getPointsHoles(t)
      };
    }
  }, {
    key: "copy",
    value: function copy(t) {
      _get(_getPrototypeOf(gu.prototype), "copy", this).call(this, t), this.holes = [];
      for (var _e202 = 0, _n199 = t.holes.length; _e202 < _n199; _e202++) {
        var _n200 = t.holes[_e202];
        this.holes.push(_n200.clone());
      }
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(gu.prototype), "toJSON", this).call(this);
      t.uuid = this.uuid, t.holes = [];
      for (var _e203 = 0, _n201 = this.holes.length; _e203 < _n201; _e203++) {
        var _n202 = this.holes[_e203];
        t.holes.push(_n202.toJSON());
      }
      return t;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      _get(_getPrototypeOf(gu.prototype), "fromJSON", this).call(this, t), this.uuid = t.uuid, this.holes = [];
      for (var _e204 = 0, _n203 = t.holes.length; _e204 < _n203; _e204++) {
        var _n204 = t.holes[_e204];
        this.holes.push(new iu().fromJSON(_n204));
      }
      return this;
    }
  }]);
}(iu);
var _u = function _u(t, e) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var i = e && e.length,
    r = i ? e[0] * n : t.length;
  var s = vu(t, 0, r, n, !0);
  var a = [];
  if (!s || s.next === s.prev) return a;
  var o, l, c, h, u, d, p;
  if (i && (s = function (t, e, n, i) {
    var r = [];
    var s, a, o, l, c;
    for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : t.length, c = vu(t, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(Cu(c));
    for (r.sort(Tu), s = 0; s < r.length; s++) n = wu(r[s], n);
    return n;
  }(t, e, s, n)), t.length > 80 * n) {
    o = c = t[0], l = h = t[1];
    for (var _e205 = n; _e205 < r; _e205 += n) u = t[_e205], d = t[_e205 + 1], u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
    p = Math.max(c - o, h - l), p = 0 !== p ? 32767 / p : 0;
  }
  return yu(s, a, n, o, l, p, 0), a;
};
function vu(t, e, n, i, r) {
  var s, a;
  if (r === function (t, e, n, i) {
    var r = 0;
    for (var _s67 = e, _a54 = n - i; _s67 < n; _s67 += i) r += (t[_a54] - t[_s67]) * (t[_s67 + 1] + t[_a54 + 1]), _a54 = _s67;
    return r;
  }(t, e, n, i) > 0) for (s = e; s < n; s += i) a = zu(s, t[s], t[s + 1], a);else for (s = n - i; s >= e; s -= i) a = zu(s, t[s], t[s + 1], a);
  return a && Uu(a, a.next) && (Hu(a), a = a.next), a;
}
function xu(t, e) {
  if (!t) return t;
  e || (e = t);
  var n,
    i = t;
  do {
    if (n = !1, i.steiner || !Uu(i, i.next) && 0 !== Iu(i.prev, i, i.next)) i = i.next;else {
      if (Hu(i), i = e = i.prev, i === i.next) break;
      n = !0;
    }
  } while (n || i !== e);
  return e;
}
function yu(t, e, n, i, r, s, a) {
  if (!t) return;
  !a && s && function (t, e, n, i) {
    var r = t;
    do {
      0 === r.z && (r.z = Ru(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
    } while (r !== t);
    r.prevZ.nextZ = null, r.prevZ = null, function (t) {
      var e,
        n,
        i,
        r,
        s,
        a,
        o,
        l,
        c = 1;
      do {
        for (n = t, t = null, s = null, a = 0; n;) {
          for (a++, i = n, o = 0, e = 0; e < c && (o++, i = i.nextZ, i); e++);
          for (l = c; o > 0 || l > 0 && i;) 0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, o--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
          n = i;
        }
        s.nextZ = null, c *= 2;
      } while (a > 1);
    }(r);
  }(t, i, r, s);
  var o,
    l,
    c = t;
  for (; t.prev !== t.next;) if (o = t.prev, l = t.next, s ? Su(t, i, r, s) : Mu(t)) e.push(o.i / n | 0), e.push(t.i / n | 0), e.push(l.i / n | 0), Hu(t), t = l.next, c = l.next;else if ((t = l) === c) {
    a ? 1 === a ? yu(t = bu(xu(t), e, n), e, n, i, r, s, 2) : 2 === a && Eu(t, e, n, i, r, s) : yu(xu(t), e, n, i, r, s, 1);
    break;
  }
}
function Mu(t) {
  var e = t.prev,
    n = t,
    i = t.next;
  if (Iu(e, n, i) >= 0) return !1;
  var r = e.x,
    s = n.x,
    a = i.x,
    o = e.y,
    l = n.y,
    c = i.y,
    h = r < s ? r < a ? r : a : s < a ? s : a,
    u = o < l ? o < c ? o : c : l < c ? l : c,
    d = r > s ? r > a ? r : a : s > a ? s : a,
    p = o > l ? o > c ? o : c : l > c ? l : c;
  var m = i.next;
  for (; m !== e;) {
    if (m.x >= h && m.x <= d && m.y >= u && m.y <= p && Pu(r, o, s, l, a, c, m.x, m.y) && Iu(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function Su(t, e, n, i) {
  var r = t.prev,
    s = t,
    a = t.next;
  if (Iu(r, s, a) >= 0) return !1;
  var o = r.x,
    l = s.x,
    c = a.x,
    h = r.y,
    u = s.y,
    d = a.y,
    p = o < l ? o < c ? o : c : l < c ? l : c,
    m = h < u ? h < d ? h : d : u < d ? u : d,
    f = o > l ? o > c ? o : c : l > c ? l : c,
    g = h > u ? h > d ? h : d : u > d ? u : d,
    _ = Ru(p, m, e, n, i),
    v = Ru(f, g, e, n, i);
  var x = t.prevZ,
    y = t.nextZ;
  for (; x && x.z >= _ && y && y.z <= v;) {
    if (x.x >= p && x.x <= f && x.y >= m && x.y <= g && x !== r && x !== a && Pu(o, h, l, u, c, d, x.x, x.y) && Iu(x.prev, x, x.next) >= 0) return !1;
    if (x = x.prevZ, y.x >= p && y.x <= f && y.y >= m && y.y <= g && y !== r && y !== a && Pu(o, h, l, u, c, d, y.x, y.y) && Iu(y.prev, y, y.next) >= 0) return !1;
    y = y.nextZ;
  }
  for (; x && x.z >= _;) {
    if (x.x >= p && x.x <= f && x.y >= m && x.y <= g && x !== r && x !== a && Pu(o, h, l, u, c, d, x.x, x.y) && Iu(x.prev, x, x.next) >= 0) return !1;
    x = x.prevZ;
  }
  for (; y && y.z <= v;) {
    if (y.x >= p && y.x <= f && y.y >= m && y.y <= g && y !== r && y !== a && Pu(o, h, l, u, c, d, y.x, y.y) && Iu(y.prev, y, y.next) >= 0) return !1;
    y = y.nextZ;
  }
  return !0;
}
function bu(t, e, n) {
  var i = t;
  do {
    var _r116 = i.prev,
      _s68 = i.next.next;
    !Uu(_r116, _s68) && Nu(_r116, i, i.next, _s68) && Fu(_r116, _s68) && Fu(_s68, _r116) && (e.push(_r116.i / n | 0), e.push(i.i / n | 0), e.push(_s68.i / n | 0), Hu(i), Hu(i.next), i = t = _s68), i = i.next;
  } while (i !== t);
  return xu(i);
}
function Eu(t, e, n, i, r, s) {
  var a = t;
  do {
    var _t204 = a.next.next;
    for (; _t204 !== a.prev;) {
      if (a.i !== _t204.i && Lu(a, _t204)) {
        var _o41 = Bu(a, _t204);
        return a = xu(a, a.next), _o41 = xu(_o41, _o41.next), yu(a, e, n, i, r, s, 0), void yu(_o41, e, n, i, r, s, 0);
      }
      _t204 = _t204.next;
    }
    a = a.next;
  } while (a !== t);
}
function Tu(t, e) {
  return t.x - e.x;
}
function wu(t, e) {
  var n = function (t, e) {
    var n,
      i = e,
      r = -1 / 0;
    var s = t.x,
      a = t.y;
    do {
      if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
        var _t205 = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
        if (_t205 <= s && _t205 > r && (r = _t205, n = i.x < i.next.x ? i : i.next, _t205 === s)) return n;
      }
      i = i.next;
    } while (i !== e);
    if (!n) return null;
    var o = n,
      l = n.x,
      c = n.y;
    var h,
      u = 1 / 0;
    i = n;
    do {
      s >= i.x && i.x >= l && s !== i.x && Pu(a < c ? s : r, a, l, c, a < c ? r : s, a, i.x, i.y) && (h = Math.abs(a - i.y) / (s - i.x), Fu(i, t) && (h < u || h === u && (i.x > n.x || i.x === n.x && Au(n, i))) && (n = i, u = h)), i = i.next;
    } while (i !== o);
    return n;
  }(t, e);
  if (!n) return e;
  var i = Bu(n, t);
  return xu(i, i.next), xu(n, n.next);
}
function Au(t, e) {
  return Iu(t.prev, t, e.prev) < 0 && Iu(e.next, t, t.next) < 0;
}
function Ru(t, e, n, i, r) {
  return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - i) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
}
function Cu(t) {
  var e = t,
    n = t;
  do {
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  } while (e !== t);
  return n;
}
function Pu(t, e, n, i, r, s, a, o) {
  return (r - a) * (e - o) >= (t - a) * (s - o) && (t - a) * (i - o) >= (n - a) * (e - o) && (n - a) * (s - o) >= (r - a) * (i - o);
}
function Lu(t, e) {
  return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
    var n = t;
    do {
      if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Nu(n, n.next, t, e)) return !0;
      n = n.next;
    } while (n !== t);
    return !1;
  }(t, e) && (Fu(t, e) && Fu(e, t) && function (t, e) {
    var n = t,
      i = !1;
    var r = (t.x + e.x) / 2,
      s = (t.y + e.y) / 2;
    do {
      n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
    } while (n !== t);
    return i;
  }(t, e) && (Iu(t.prev, t, e.prev) || Iu(t, e.prev, e)) || Uu(t, e) && Iu(t.prev, t, t.next) > 0 && Iu(e.prev, e, e.next) > 0);
}
function Iu(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function Uu(t, e) {
  return t.x === e.x && t.y === e.y;
}
function Nu(t, e, n, i) {
  var r = Ou(Iu(t, e, n)),
    s = Ou(Iu(t, e, i)),
    a = Ou(Iu(n, i, t)),
    o = Ou(Iu(n, i, e));
  return r !== s && a !== o || !(0 !== r || !Du(t, n, e)) || !(0 !== s || !Du(t, i, e)) || !(0 !== a || !Du(n, t, i)) || !(0 !== o || !Du(n, e, i));
}
function Du(t, e, n) {
  return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
}
function Ou(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function Fu(t, e) {
  return Iu(t.prev, t, t.next) < 0 ? Iu(t, e, t.next) >= 0 && Iu(t, t.prev, e) >= 0 : Iu(t, e, t.prev) < 0 || Iu(t, t.next, e) < 0;
}
function Bu(t, e) {
  var n = new Vu(t.i, t.x, t.y),
    i = new Vu(e.i, e.x, e.y),
    r = t.next,
    s = e.prev;
  return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i;
}
function zu(t, e, n, i) {
  var r = new Vu(t, e, n);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function Hu(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Vu(t, e, n) {
  this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
var ku = exports.ShapeUtils = /*#__PURE__*/function () {
  function ku() {
    _classCallCheck(this, ku);
  }
  return _createClass(ku, null, [{
    key: "area",
    value: function area(t) {
      var e = t.length;
      var n = 0;
      for (var _i157 = e - 1, _r117 = 0; _r117 < e; _i157 = _r117++) n += t[_i157].x * t[_r117].y - t[_r117].x * t[_i157].y;
      return .5 * n;
    }
  }, {
    key: "isClockWise",
    value: function isClockWise(t) {
      return ku.area(t) < 0;
    }
  }, {
    key: "triangulateShape",
    value: function triangulateShape(t, e) {
      var n = [],
        i = [],
        r = [];
      Gu(t), Wu(n, t);
      var s = t.length;
      e.forEach(Gu);
      for (var _t206 = 0; _t206 < e.length; _t206++) i.push(s), s += e[_t206].length, Wu(n, e[_t206]);
      var a = _u(n, i);
      for (var _t207 = 0; _t207 < a.length; _t207 += 3) r.push(a.slice(_t207, _t207 + 3));
      return r;
    }
  }]);
}();
function Gu(t) {
  var e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function Wu(t, e) {
  for (var _n205 = 0; _n205 < e.length; _n205++) t.push(e[_n205].x), t.push(e[_n205].y);
}
var Xu = exports.ExtrudeGeometry = /*#__PURE__*/function (_Ts8) {
  function Xu() {
    var _this73;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new gu([new Qn(.5, .5), new Qn(-.5, .5), new Qn(-.5, -.5), new Qn(.5, -.5)]);
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Xu);
    _this73 = _callSuper(this, Xu), _this73.type = "ExtrudeGeometry", _this73.parameters = {
      shapes: t,
      options: e
    }, t = Array.isArray(t) ? t : [t];
    var n = _this73,
      i = [],
      r = [];
    for (var _e206 = 0, _n206 = t.length; _e206 < _n206; _e206++) {
      s(t[_e206]);
    }
    function s(t) {
      var s = [],
        a = void 0 !== e.curveSegments ? e.curveSegments : 12,
        o = void 0 !== e.steps ? e.steps : 1,
        l = void 0 !== e.depth ? e.depth : 1;
      var c = void 0 === e.bevelEnabled || e.bevelEnabled,
        h = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
        u = void 0 !== e.bevelSize ? e.bevelSize : h - .1,
        d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
        p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
      var m = e.extrudePath,
        f = void 0 !== e.UVGenerator ? e.UVGenerator : ju;
      var g,
        _,
        v,
        x,
        y,
        M = !1;
      m && (g = m.getSpacedPoints(o), M = !0, c = !1, _ = m.computeFrenetFrames(o, !1), v = new Ii(), x = new Ii(), y = new Ii()), c || (p = 0, h = 0, u = 0, d = 0);
      var S = t.extractPoints(a);
      var b = S.shape;
      var E = S.holes;
      if (!ku.isClockWise(b)) {
        b = b.reverse();
        for (var _t208 = 0, _e207 = E.length; _t208 < _e207; _t208++) {
          var _e208 = E[_t208];
          ku.isClockWise(_e208) && (E[_t208] = _e208.reverse());
        }
      }
      var T = ku.triangulateShape(b, E),
        w = b;
      for (var _t209 = 0, _e209 = E.length; _t209 < _e209; _t209++) {
        var _e210 = E[_t209];
        b = b.concat(_e210);
      }
      function A(t, e, n) {
        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().addScaledVector(e, n);
      }
      var R = b.length,
        C = T.length;
      function P(t, e, n) {
        var i, r, s;
        var a = t.x - e.x,
          o = t.y - e.y,
          l = n.x - t.x,
          c = n.y - t.y,
          h = a * a + o * o,
          u = a * c - o * l;
        if (Math.abs(u) > Number.EPSILON) {
          var _u13 = Math.sqrt(h),
            _d15 = Math.sqrt(l * l + c * c),
            _p14 = e.x - o / _u13,
            _m9 = e.y + a / _u13,
            _f4 = ((n.x - c / _d15 - _p14) * c - (n.y + l / _d15 - _m9) * l) / (a * c - o * l);
          i = _p14 + a * _f4 - t.x, r = _m9 + o * _f4 - t.y;
          var _g5 = i * i + r * r;
          if (_g5 <= 2) return new Qn(i, r);
          s = Math.sqrt(_g5 / 2);
        } else {
          var _t210 = !1;
          a > Number.EPSILON ? l > Number.EPSILON && (_t210 = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (_t210 = !0) : Math.sign(o) === Math.sign(c) && (_t210 = !0), _t210 ? (i = -o, r = a, s = Math.sqrt(h)) : (i = a, r = o, s = Math.sqrt(h / 2));
        }
        return new Qn(i / s, r / s);
      }
      var L = [];
      for (var _t211 = 0, _e211 = w.length, _n207 = _e211 - 1, _i158 = _t211 + 1; _t211 < _e211; _t211++, _n207++, _i158++) _n207 === _e211 && (_n207 = 0), _i158 === _e211 && (_i158 = 0), L[_t211] = P(w[_t211], w[_n207], w[_i158]);
      var I = [];
      var U,
        N = L.concat();
      for (var _t212 = 0, _e212 = E.length; _t212 < _e212; _t212++) {
        var _e213 = E[_t212];
        U = [];
        for (var _t213 = 0, _n208 = _e213.length, _i159 = _n208 - 1, _r118 = _t213 + 1; _t213 < _n208; _t213++, _i159++, _r118++) _i159 === _n208 && (_i159 = 0), _r118 === _n208 && (_r118 = 0), U[_t213] = P(_e213[_t213], _e213[_i159], _e213[_r118]);
        I.push(U), N = N.concat(U);
      }
      for (var _t214 = 0; _t214 < p; _t214++) {
        var _e214 = _t214 / p,
          _n209 = h * Math.cos(_e214 * Math.PI / 2),
          _i160 = u * Math.sin(_e214 * Math.PI / 2) + d;
        for (var _t215 = 0, _e215 = w.length; _t215 < _e215; _t215++) {
          var _e216 = A(w[_t215], L[_t215], _i160);
          F(_e216.x, _e216.y, -_n209);
        }
        for (var _t216 = 0, _e217 = E.length; _t216 < _e217; _t216++) {
          var _e218 = E[_t216];
          U = I[_t216];
          for (var _t217 = 0, _r119 = _e218.length; _t217 < _r119; _t217++) {
            var _r120 = A(_e218[_t217], U[_t217], _i160);
            F(_r120.x, _r120.y, -_n209);
          }
        }
      }
      var D = u + d;
      for (var _t218 = 0; _t218 < R; _t218++) {
        var _e219 = c ? A(b[_t218], N[_t218], D) : b[_t218];
        M ? (x.copy(_.normals[0]).multiplyScalar(_e219.x), v.copy(_.binormals[0]).multiplyScalar(_e219.y), y.copy(g[0]).add(x).add(v), F(y.x, y.y, y.z)) : F(_e219.x, _e219.y, 0);
      }
      for (var _t219 = 1; _t219 <= o; _t219++) for (var _e220 = 0; _e220 < R; _e220++) {
        var _n210 = c ? A(b[_e220], N[_e220], D) : b[_e220];
        M ? (x.copy(_.normals[_t219]).multiplyScalar(_n210.x), v.copy(_.binormals[_t219]).multiplyScalar(_n210.y), y.copy(g[_t219]).add(x).add(v), F(y.x, y.y, y.z)) : F(_n210.x, _n210.y, l / o * _t219);
      }
      for (var _t220 = p - 1; _t220 >= 0; _t220--) {
        var _e221 = _t220 / p,
          _n211 = h * Math.cos(_e221 * Math.PI / 2),
          _i161 = u * Math.sin(_e221 * Math.PI / 2) + d;
        for (var _t221 = 0, _e222 = w.length; _t221 < _e222; _t221++) {
          var _e223 = A(w[_t221], L[_t221], _i161);
          F(_e223.x, _e223.y, l + _n211);
        }
        for (var _t222 = 0, _e224 = E.length; _t222 < _e224; _t222++) {
          var _e225 = E[_t222];
          U = I[_t222];
          for (var _t223 = 0, _r121 = _e225.length; _t223 < _r121; _t223++) {
            var _r122 = A(_e225[_t223], U[_t223], _i161);
            M ? F(_r122.x, _r122.y + g[o - 1].y, g[o - 1].x + _n211) : F(_r122.x, _r122.y, l + _n211);
          }
        }
      }
      function O(t, e) {
        var n = t.length;
        for (; --n >= 0;) {
          var _i162 = n;
          var _r123 = n - 1;
          _r123 < 0 && (_r123 = t.length - 1);
          for (var _t224 = 0, _n212 = o + 2 * p; _t224 < _n212; _t224++) {
            var _n213 = R * _t224,
              _s69 = R * (_t224 + 1);
            z(e + _i162 + _n213, e + _r123 + _n213, e + _r123 + _s69, e + _i162 + _s69);
          }
        }
      }
      function F(t, e, n) {
        s.push(t), s.push(e), s.push(n);
      }
      function B(t, e, r) {
        H(t), H(e), H(r);
        var s = i.length / 3,
          a = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
        V(a[0]), V(a[1]), V(a[2]);
      }
      function z(t, e, r, s) {
        H(t), H(e), H(s), H(e), H(r), H(s);
        var a = i.length / 3,
          o = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
        V(o[0]), V(o[1]), V(o[3]), V(o[1]), V(o[2]), V(o[3]);
      }
      function H(t) {
        i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]);
      }
      function V(t) {
        r.push(t.x), r.push(t.y);
      }
      !function () {
        var t = i.length / 3;
        if (c) {
          var _t225 = 0,
            _e226 = R * _t225;
          for (var _t226 = 0; _t226 < C; _t226++) {
            var _n214 = T[_t226];
            B(_n214[2] + _e226, _n214[1] + _e226, _n214[0] + _e226);
          }
          _t225 = o + 2 * p, _e226 = R * _t225;
          for (var _t227 = 0; _t227 < C; _t227++) {
            var _n215 = T[_t227];
            B(_n215[0] + _e226, _n215[1] + _e226, _n215[2] + _e226);
          }
        } else {
          for (var _t228 = 0; _t228 < C; _t228++) {
            var _e227 = T[_t228];
            B(_e227[2], _e227[1], _e227[0]);
          }
          for (var _t229 = 0; _t229 < C; _t229++) {
            var _e228 = T[_t229];
            B(_e228[0] + R * o, _e228[1] + R * o, _e228[2] + R * o);
          }
        }
        n.addGroup(t, i.length / 3 - t, 0);
      }(), function () {
        var t = i.length / 3;
        var e = 0;
        O(w, e), e += w.length;
        for (var _t230 = 0, _n216 = E.length; _t230 < _n216; _t230++) {
          var _n217 = E[_t230];
          O(_n217, e), e += _n217.length;
        }
        n.addGroup(t, i.length / 3 - t, 1);
      }();
    }
    _this73.setAttribute("position", new gs(i, 3)), _this73.setAttribute("uv", new gs(r, 2)), _this73.computeVertexNormals();
    return _this73;
  }
  _inherits(Xu, _Ts8);
  return _createClass(Xu, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Xu.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Xu.prototype), "toJSON", this).call(this);
      return function (t, e, n) {
        if (n.shapes = [], Array.isArray(t)) for (var _e229 = 0, _i163 = t.length; _e229 < _i163; _e229++) {
          var _i164 = t[_e229];
          n.shapes.push(_i164.uuid);
        } else n.shapes.push(t.uuid);
        n.options = Object.assign({}, e), void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
        return n;
      }(this.parameters.shapes, this.parameters.options, t);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t, e) {
      var n = [];
      for (var _i165 = 0, _r124 = t.shapes.length; _i165 < _r124; _i165++) {
        var _r125 = e[t.shapes[_i165]];
        n.push(_r125);
      }
      var i = t.options.extrudePath;
      return void 0 !== i && (t.options.extrudePath = new eu[i.type]().fromJSON(i)), new Xu(n, t.options);
    }
  }]);
}(Ts);
var ju = {
  generateTopUV: function generateTopUV(t, e, n, i, r) {
    var s = e[3 * n],
      a = e[3 * n + 1],
      o = e[3 * i],
      l = e[3 * i + 1],
      c = e[3 * r],
      h = e[3 * r + 1];
    return [new Qn(s, a), new Qn(o, l), new Qn(c, h)];
  },
  generateSideWallUV: function generateSideWallUV(t, e, n, i, r, s) {
    var a = e[3 * n],
      o = e[3 * n + 1],
      l = e[3 * n + 2],
      c = e[3 * i],
      h = e[3 * i + 1],
      u = e[3 * i + 2],
      d = e[3 * r],
      p = e[3 * r + 1],
      m = e[3 * r + 2],
      f = e[3 * s],
      g = e[3 * s + 1],
      _ = e[3 * s + 2];
    return Math.abs(o - h) < Math.abs(a - c) ? [new Qn(a, 1 - l), new Qn(c, 1 - u), new Qn(d, 1 - m), new Qn(f, 1 - _)] : [new Qn(o, 1 - l), new Qn(h, 1 - u), new Qn(p, 1 - m), new Qn(g, 1 - _)];
  }
};
var qu = exports.IcosahedronGeometry = /*#__PURE__*/function (_cu2) {
  function qu() {
    var _this74;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, qu);
    var n = (1 + Math.sqrt(5)) / 2;
    _this74 = _callSuper(this, qu, [[-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e]), _this74.type = "IcosahedronGeometry", _this74.parameters = {
      radius: t,
      detail: e
    };
    return _this74;
  }
  _inherits(qu, _cu2);
  return _createClass(qu, null, [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new qu(t.radius, t.detail);
    }
  }]);
}(cu);
var Yu = exports.OctahedronGeometry = /*#__PURE__*/function (_cu3) {
  function Yu() {
    var _this75;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, Yu);
    _this75 = _callSuper(this, Yu, [[1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e]), _this75.type = "OctahedronGeometry", _this75.parameters = {
      radius: t,
      detail: e
    };
    return _this75;
  }
  _inherits(Yu, _cu3);
  return _createClass(Yu, null, [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new Yu(t.radius, t.detail);
    }
  }]);
}(cu);
var Zu = exports.RingGeometry = /*#__PURE__*/function (_Ts9) {
  function Zu() {
    var _this76;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2 * Math.PI;
    _classCallCheck(this, Zu);
    _this76 = _callSuper(this, Zu), _this76.type = "RingGeometry", _this76.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: r,
      thetaLength: s
    }, n = Math.max(3, n);
    var a = [],
      o = [],
      l = [],
      c = [];
    var h = t;
    var u = (e - t) / (i = Math.max(1, i)),
      d = new Ii(),
      p = new Qn();
    for (var _t231 = 0; _t231 <= i; _t231++) {
      for (var _t232 = 0; _t232 <= n; _t232++) {
        var _i166 = r + _t232 / n * s;
        d.x = h * Math.cos(_i166), d.y = h * Math.sin(_i166), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, c.push(p.x, p.y);
      }
      h += u;
    }
    for (var _t233 = 0; _t233 < i; _t233++) {
      var _e230 = _t233 * (n + 1);
      for (var _t234 = 0; _t234 < n; _t234++) {
        var _i167 = _t234 + _e230,
          _r126 = _i167,
          _s70 = _i167 + n + 1,
          _o42 = _i167 + n + 2,
          _l24 = _i167 + 1;
        a.push(_r126, _s70, _l24), a.push(_s70, _o42, _l24);
      }
    }
    _this76.setIndex(a), _this76.setAttribute("position", new gs(o, 3)), _this76.setAttribute("normal", new gs(l, 3)), _this76.setAttribute("uv", new gs(c, 2));
    return _this76;
  }
  _inherits(Zu, _Ts9);
  return _createClass(Zu, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Zu.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new Zu(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength);
    }
  }]);
}(Ts);
var Ju = exports.ShapeGeometry = /*#__PURE__*/function (_Ts10) {
  function Ju() {
    var _this77;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new gu([new Qn(0, .5), new Qn(-.5, -.5), new Qn(.5, -.5)]);
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
    _classCallCheck(this, Ju);
    _this77 = _callSuper(this, Ju), _this77.type = "ShapeGeometry", _this77.parameters = {
      shapes: t,
      curveSegments: e
    };
    var n = [],
      i = [],
      r = [],
      s = [];
    var a = 0,
      o = 0;
    if (!1 === Array.isArray(t)) l(t);else for (var _e231 = 0; _e231 < t.length; _e231++) l(t[_e231]), _this77.addGroup(a, o, _e231), a += o, o = 0;
    function l(t) {
      var a = i.length / 3,
        l = t.extractPoints(e);
      var c = l.shape;
      var h = l.holes;
      !1 === ku.isClockWise(c) && (c = c.reverse());
      for (var _t235 = 0, _e232 = h.length; _t235 < _e232; _t235++) {
        var _e233 = h[_t235];
        !0 === ku.isClockWise(_e233) && (h[_t235] = _e233.reverse());
      }
      var u = ku.triangulateShape(c, h);
      for (var _t236 = 0, _e234 = h.length; _t236 < _e234; _t236++) {
        var _e235 = h[_t236];
        c = c.concat(_e235);
      }
      for (var _t237 = 0, _e236 = c.length; _t237 < _e236; _t237++) {
        var _e237 = c[_t237];
        i.push(_e237.x, _e237.y, 0), r.push(0, 0, 1), s.push(_e237.x, _e237.y);
      }
      for (var _t238 = 0, _e238 = u.length; _t238 < _e238; _t238++) {
        var _e239 = u[_t238],
          _i168 = _e239[0] + a,
          _r127 = _e239[1] + a,
          _s71 = _e239[2] + a;
        n.push(_i168, _r127, _s71), o += 3;
      }
    }
    _this77.setIndex(n), _this77.setAttribute("position", new gs(i, 3)), _this77.setAttribute("normal", new gs(r, 3)), _this77.setAttribute("uv", new gs(s, 2));
    return _this77;
  }
  _inherits(Ju, _Ts10);
  return _createClass(Ju, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Ju.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(Ju.prototype), "toJSON", this).call(this);
      return function (t, e) {
        if (e.shapes = [], Array.isArray(t)) for (var _n218 = 0, _i169 = t.length; _n218 < _i169; _n218++) {
          var _i170 = t[_n218];
          e.shapes.push(_i170.uuid);
        } else e.shapes.push(t.uuid);
        return e;
      }(this.parameters.shapes, t);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t, e) {
      var n = [];
      for (var _i171 = 0, _r128 = t.shapes.length; _i171 < _r128; _i171++) {
        var _r129 = e[t.shapes[_i171]];
        n.push(_r129);
      }
      return new Ju(n, t.curveSegments);
    }
  }]);
}(Ts);
var Ku = exports.SphereGeometry = /*#__PURE__*/function (_Ts11) {
  function Ku() {
    var _this78;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2 * Math.PI;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI;
    _classCallCheck(this, Ku);
    _this78 = _callSuper(this, Ku), _this78.type = "SphereGeometry", _this78.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: n,
      phiStart: i,
      phiLength: r,
      thetaStart: s,
      thetaLength: a
    }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
    var o = Math.min(s + a, Math.PI);
    var l = 0;
    var c = [],
      h = new Ii(),
      u = new Ii(),
      d = [],
      p = [],
      m = [],
      f = [];
    for (var _d16 = 0; _d16 <= n; _d16++) {
      var _g6 = [],
        _6 = _d16 / n;
      var _v5 = 0;
      0 === _d16 && 0 === s ? _v5 = .5 / e : _d16 === n && o === Math.PI && (_v5 = -.5 / e);
      for (var _n219 = 0; _n219 <= e; _n219++) {
        var _o43 = _n219 / e;
        h.x = -t * Math.cos(i + _o43 * r) * Math.sin(s + _6 * a), h.y = t * Math.cos(s + _6 * a), h.z = t * Math.sin(i + _o43 * r) * Math.sin(s + _6 * a), p.push(h.x, h.y, h.z), u.copy(h).normalize(), m.push(u.x, u.y, u.z), f.push(_o43 + _v5, 1 - _6), _g6.push(l++);
      }
      c.push(_g6);
    }
    for (var _t239 = 0; _t239 < n; _t239++) for (var _i172 = 0; _i172 < e; _i172++) {
      var _e240 = c[_t239][_i172 + 1],
        _r130 = c[_t239][_i172],
        _a55 = c[_t239 + 1][_i172],
        _l25 = c[_t239 + 1][_i172 + 1];
      (0 !== _t239 || s > 0) && d.push(_e240, _r130, _l25), (_t239 !== n - 1 || o < Math.PI) && d.push(_r130, _a55, _l25);
    }
    _this78.setIndex(d), _this78.setAttribute("position", new gs(p, 3)), _this78.setAttribute("normal", new gs(m, 3)), _this78.setAttribute("uv", new gs(f, 2));
    return _this78;
  }
  _inherits(Ku, _Ts11);
  return _createClass(Ku, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Ku.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new Ku(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
    }
  }]);
}(Ts);
var $u = exports.TetrahedronGeometry = /*#__PURE__*/function (_cu4) {
  function $u() {
    var _this79;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, $u);
    _this79 = _callSuper(this, $u, [[1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e]), _this79.type = "TetrahedronGeometry", _this79.parameters = {
      radius: t,
      detail: e
    };
    return _this79;
  }
  _inherits($u, _cu4);
  return _createClass($u, null, [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new $u(t.radius, t.detail);
    }
  }]);
}(cu);
var Qu = exports.TorusGeometry = /*#__PURE__*/function (_Ts12) {
  function Qu() {
    var _this80;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .4;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 48;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2 * Math.PI;
    _classCallCheck(this, Qu);
    _this80 = _callSuper(this, Qu), _this80.type = "TorusGeometry", _this80.parameters = {
      radius: t,
      tube: e,
      radialSegments: n,
      tubularSegments: i,
      arc: r
    }, n = Math.floor(n), i = Math.floor(i);
    var s = [],
      a = [],
      o = [],
      l = [],
      c = new Ii(),
      h = new Ii(),
      u = new Ii();
    for (var _s72 = 0; _s72 <= n; _s72++) for (var _d17 = 0; _d17 <= i; _d17++) {
      var _p15 = _d17 / i * r,
        _m10 = _s72 / n * Math.PI * 2;
      h.x = (t + e * Math.cos(_m10)) * Math.cos(_p15), h.y = (t + e * Math.cos(_m10)) * Math.sin(_p15), h.z = e * Math.sin(_m10), a.push(h.x, h.y, h.z), c.x = t * Math.cos(_p15), c.y = t * Math.sin(_p15), u.subVectors(h, c).normalize(), o.push(u.x, u.y, u.z), l.push(_d17 / i), l.push(_s72 / n);
    }
    for (var _t240 = 1; _t240 <= n; _t240++) for (var _e241 = 1; _e241 <= i; _e241++) {
      var _n220 = (i + 1) * _t240 + _e241 - 1,
        _r131 = (i + 1) * (_t240 - 1) + _e241 - 1,
        _a56 = (i + 1) * (_t240 - 1) + _e241,
        _o44 = (i + 1) * _t240 + _e241;
      s.push(_n220, _r131, _o44), s.push(_r131, _a56, _o44);
    }
    _this80.setIndex(s), _this80.setAttribute("position", new gs(a, 3)), _this80.setAttribute("normal", new gs(o, 3)), _this80.setAttribute("uv", new gs(l, 2));
    return _this80;
  }
  _inherits(Qu, _Ts12);
  return _createClass(Qu, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Qu.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new Qu(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc);
    }
  }]);
}(Ts);
var td = exports.TorusKnotGeometry = /*#__PURE__*/function (_Ts13) {
  function td() {
    var _this81;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .4;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 64;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;
    _classCallCheck(this, td);
    _this81 = _callSuper(this, td), _this81.type = "TorusKnotGeometry", _this81.parameters = {
      radius: t,
      tube: e,
      tubularSegments: n,
      radialSegments: i,
      p: r,
      q: s
    }, n = Math.floor(n), i = Math.floor(i);
    var a = [],
      o = [],
      l = [],
      c = [],
      h = new Ii(),
      u = new Ii(),
      d = new Ii(),
      p = new Ii(),
      m = new Ii(),
      f = new Ii(),
      g = new Ii();
    for (var _a57 = 0; _a57 <= n; ++_a57) {
      var _v6 = _a57 / n * r * Math.PI * 2;
      _(_v6, r, s, t, d), _(_v6 + .01, r, s, t, p), f.subVectors(p, d), g.addVectors(p, d), m.crossVectors(f, g), g.crossVectors(m, f), m.normalize(), g.normalize();
      for (var _t241 = 0; _t241 <= i; ++_t241) {
        var _r132 = _t241 / i * Math.PI * 2,
          _s73 = -e * Math.cos(_r132),
          _p16 = e * Math.sin(_r132);
        h.x = d.x + (_s73 * g.x + _p16 * m.x), h.y = d.y + (_s73 * g.y + _p16 * m.y), h.z = d.z + (_s73 * g.z + _p16 * m.z), o.push(h.x, h.y, h.z), u.subVectors(h, d).normalize(), l.push(u.x, u.y, u.z), c.push(_a57 / n), c.push(_t241 / i);
      }
    }
    for (var _t242 = 1; _t242 <= n; _t242++) for (var _e242 = 1; _e242 <= i; _e242++) {
      var _n221 = (i + 1) * (_t242 - 1) + (_e242 - 1),
        _r133 = (i + 1) * _t242 + (_e242 - 1),
        _s74 = (i + 1) * _t242 + _e242,
        _o45 = (i + 1) * (_t242 - 1) + _e242;
      a.push(_n221, _r133, _o45), a.push(_r133, _s74, _o45);
    }
    function _(t, e, n, i, r) {
      var s = Math.cos(t),
        a = Math.sin(t),
        o = n / e * t,
        l = Math.cos(o);
      r.x = i * (2 + l) * .5 * s, r.y = i * (2 + l) * a * .5, r.z = i * Math.sin(o) * .5;
    }
    _this81.setIndex(a), _this81.setAttribute("position", new gs(o, 3)), _this81.setAttribute("normal", new gs(l, 3)), _this81.setAttribute("uv", new gs(c, 2));
    return _this81;
  }
  _inherits(td, _Ts13);
  return _createClass(td, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(td.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new td(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q);
    }
  }]);
}(Ts);
var ed = exports.TubeGeometry = /*#__PURE__*/function (_Ts14) {
  function ed() {
    var _this82;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Qh(new Ii(-1, -1, 0), new Ii(-1, 1, 0), new Ii(1, 1, 0));
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    _classCallCheck(this, ed);
    _this82 = _callSuper(this, ed), _this82.type = "TubeGeometry", _this82.parameters = {
      path: t,
      tubularSegments: e,
      radius: n,
      radialSegments: i,
      closed: r
    };
    var s = t.computeFrenetFrames(e, r);
    _this82.tangents = s.tangents, _this82.normals = s.normals, _this82.binormals = s.binormals;
    var a = new Ii(),
      o = new Ii(),
      l = new Qn();
    var c = new Ii();
    var h = [],
      u = [],
      d = [],
      p = [];
    function m(r) {
      c = t.getPointAt(r / e, c);
      var l = s.normals[r],
        d = s.binormals[r];
      for (var _t243 = 0; _t243 <= i; _t243++) {
        var _e243 = _t243 / i * Math.PI * 2,
          _r134 = Math.sin(_e243),
          _s75 = -Math.cos(_e243);
        o.x = _s75 * l.x + _r134 * d.x, o.y = _s75 * l.y + _r134 * d.y, o.z = _s75 * l.z + _r134 * d.z, o.normalize(), u.push(o.x, o.y, o.z), a.x = c.x + n * o.x, a.y = c.y + n * o.y, a.z = c.z + n * o.z, h.push(a.x, a.y, a.z);
      }
    }
    !function () {
      for (var _t244 = 0; _t244 < e; _t244++) m(_t244);
      m(!1 === r ? e : 0), function () {
        for (var _t245 = 0; _t245 <= e; _t245++) for (var _n222 = 0; _n222 <= i; _n222++) l.x = _t245 / e, l.y = _n222 / i, d.push(l.x, l.y);
      }(), function () {
        for (var _t246 = 1; _t246 <= e; _t246++) for (var _e244 = 1; _e244 <= i; _e244++) {
          var _n223 = (i + 1) * (_t246 - 1) + (_e244 - 1),
            _r135 = (i + 1) * _t246 + (_e244 - 1),
            _s76 = (i + 1) * _t246 + _e244,
            _a58 = (i + 1) * (_t246 - 1) + _e244;
          p.push(_n223, _r135, _a58), p.push(_r135, _s76, _a58);
        }
      }();
    }(), _this82.setIndex(p), _this82.setAttribute("position", new gs(h, 3)), _this82.setAttribute("normal", new gs(u, 3)), _this82.setAttribute("uv", new gs(d, 2));
    return _this82;
  }
  _inherits(ed, _Ts14);
  return _createClass(ed, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(ed.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(ed.prototype), "toJSON", this).call(this);
      return t.path = this.parameters.path.toJSON(), t;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(t) {
      return new ed(new eu[t.path.type]().fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed);
    }
  }]);
}(Ts);
var nd = exports.WireframeGeometry = /*#__PURE__*/function (_Ts15) {
  function nd() {
    var _this83;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, nd);
    if (_this83 = _callSuper(this, nd), _this83.type = "WireframeGeometry", _this83.parameters = {
      geometry: t
    }, null !== t) {
      var _e245 = [],
        _n224 = new Set(),
        _i173 = new Ii(),
        _r136 = new Ii();
      if (null !== t.index) {
        var _s77 = t.attributes.position,
          _a59 = t.index;
        var _o46 = t.groups;
        0 === _o46.length && (_o46 = [{
          start: 0,
          count: _a59.count,
          materialIndex: 0
        }]);
        for (var _t247 = 0, _l26 = _o46.length; _t247 < _l26; ++_t247) {
          var _l27 = _o46[_t247],
            _c22 = _l27.start;
          for (var _t248 = _c22, _o47 = _c22 + _l27.count; _t248 < _o47; _t248 += 3) for (var _o48 = 0; _o48 < 3; _o48++) {
            var _l28 = _a59.getX(_t248 + _o48),
              _c23 = _a59.getX(_t248 + (_o48 + 1) % 3);
            _i173.fromBufferAttribute(_s77, _l28), _r136.fromBufferAttribute(_s77, _c23), !0 === id(_i173, _r136, _n224) && (_e245.push(_i173.x, _i173.y, _i173.z), _e245.push(_r136.x, _r136.y, _r136.z));
          }
        }
      } else {
        var _s78 = t.attributes.position;
        for (var _t249 = 0, _a60 = _s78.count / 3; _t249 < _a60; _t249++) for (var _a61 = 0; _a61 < 3; _a61++) {
          var _o49 = 3 * _t249 + _a61,
            _l29 = 3 * _t249 + (_a61 + 1) % 3;
          _i173.fromBufferAttribute(_s78, _o49), _r136.fromBufferAttribute(_s78, _l29), !0 === id(_i173, _r136, _n224) && (_e245.push(_i173.x, _i173.y, _i173.z), _e245.push(_r136.x, _r136.y, _r136.z));
        }
      }
      _this83.setAttribute("position", new gs(_e245, 3));
    }
    return _assertThisInitialized(_this83);
  }
  _inherits(nd, _Ts15);
  return _createClass(nd, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(nd.prototype), "copy", this).call(this, t), this.parameters = Object.assign({}, t.parameters), this;
    }
  }]);
}(Ts);
function id(t, e, n) {
  var i = "".concat(t.x, ",").concat(t.y, ",").concat(t.z, "-").concat(e.x, ",").concat(e.y, ",").concat(e.z),
    r = "".concat(e.x, ",").concat(e.y, ",").concat(e.z, "-").concat(t.x, ",").concat(t.y, ",").concat(t.z);
  return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i), n.add(r), !0);
}
var rd = Object.freeze({
  __proto__: null,
  BoxGeometry: Xs,
  CapsuleGeometry: su,
  CircleGeometry: au,
  ConeGeometry: lu,
  CylinderGeometry: ou,
  DodecahedronGeometry: hu,
  EdgesGeometry: fu,
  ExtrudeGeometry: Xu,
  IcosahedronGeometry: qu,
  LatheGeometry: ru,
  OctahedronGeometry: Yu,
  PlaneGeometry: fa,
  PolyhedronGeometry: cu,
  RingGeometry: Zu,
  ShapeGeometry: Ju,
  SphereGeometry: Ku,
  TetrahedronGeometry: $u,
  TorusGeometry: Qu,
  TorusKnotGeometry: td,
  TubeGeometry: ed,
  WireframeGeometry: nd
});
var sd = exports.ShadowMaterial = /*#__PURE__*/function (_$r8) {
  function sd(t) {
    var _this84;
    _classCallCheck(this, sd);
    _this84 = _callSuper(this, sd), _this84.isShadowMaterial = !0, _this84.type = "ShadowMaterial", _this84.color = new Zr(0), _this84.transparent = !0, _this84.fog = !0, _this84.setValues(t);
    return _this84;
  }
  _inherits(sd, _$r8);
  return _createClass(sd, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(sd.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.fog = t.fog, this;
    }
  }]);
}($r);
var ad = exports.RawShaderMaterial = /*#__PURE__*/function (_Js) {
  function ad(t) {
    var _this85;
    _classCallCheck(this, ad);
    _this85 = _callSuper(this, ad, [t]), _this85.isRawShaderMaterial = !0, _this85.type = "RawShaderMaterial";
    return _this85;
  }
  _inherits(ad, _Js);
  return _createClass(ad);
}(Js);
var od = exports.MeshStandardMaterial = /*#__PURE__*/function (_$r9) {
  function od(t) {
    var _this86;
    _classCallCheck(this, od);
    _this86 = _callSuper(this, od), _this86.isMeshStandardMaterial = !0, _this86.defines = {
      STANDARD: ""
    }, _this86.type = "MeshStandardMaterial", _this86.color = new Zr(16777215), _this86.roughness = 1, _this86.metalness = 0, _this86.map = null, _this86.lightMap = null, _this86.lightMapIntensity = 1, _this86.aoMap = null, _this86.aoMapIntensity = 1, _this86.emissive = new Zr(0), _this86.emissiveIntensity = 1, _this86.emissiveMap = null, _this86.bumpMap = null, _this86.bumpScale = 1, _this86.normalMap = null, _this86.normalMapType = 0, _this86.normalScale = new Qn(1, 1), _this86.displacementMap = null, _this86.displacementScale = 1, _this86.displacementBias = 0, _this86.roughnessMap = null, _this86.metalnessMap = null, _this86.alphaMap = null, _this86.envMap = null, _this86.envMapIntensity = 1, _this86.wireframe = !1, _this86.wireframeLinewidth = 1, _this86.wireframeLinecap = "round", _this86.wireframeLinejoin = "round", _this86.flatShading = !1, _this86.fog = !0, _this86.setValues(t);
    return _this86;
  }
  _inherits(od, _$r9);
  return _createClass(od, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(od.prototype), "copy", this).call(this, t), this.defines = {
        STANDARD: ""
      }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
    }
  }]);
}($r);
var ld = exports.MeshPhysicalMaterial = /*#__PURE__*/function (_od) {
  function ld(t) {
    var _this87;
    _classCallCheck(this, ld);
    _this87 = _callSuper(this, ld), _this87.isMeshPhysicalMaterial = !0, _this87.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, _this87.type = "MeshPhysicalMaterial", _this87.anisotropyRotation = 0, _this87.anisotropyMap = null, _this87.clearcoatMap = null, _this87.clearcoatRoughness = 0, _this87.clearcoatRoughnessMap = null, _this87.clearcoatNormalScale = new Qn(1, 1), _this87.clearcoatNormalMap = null, _this87.ior = 1.5, Object.defineProperty(_assertThisInitialized(_this87), "reflectivity", {
      get: function get() {
        return Xn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function set(t) {
        this.ior = (1 + .4 * t) / (1 - .4 * t);
      }
    }), _this87.iridescenceMap = null, _this87.iridescenceIOR = 1.3, _this87.iridescenceThicknessRange = [100, 400], _this87.iridescenceThicknessMap = null, _this87.sheenColor = new Zr(0), _this87.sheenColorMap = null, _this87.sheenRoughness = 1, _this87.sheenRoughnessMap = null, _this87.transmissionMap = null, _this87.thickness = 0, _this87.thicknessMap = null, _this87.attenuationDistance = 1 / 0, _this87.attenuationColor = new Zr(1, 1, 1), _this87.specularIntensity = 1, _this87.specularIntensityMap = null, _this87.specularColor = new Zr(1, 1, 1), _this87.specularColorMap = null, _this87._anisotropy = 0, _this87._clearcoat = 0, _this87._iridescence = 0, _this87._sheen = 0, _this87._transmission = 0, _this87.setValues(t);
    return _this87;
  }
  _inherits(ld, _od);
  return _createClass(ld, [{
    key: "anisotropy",
    get: function get() {
      return this._anisotropy;
    },
    set: function set(t) {
      this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t;
    }
  }, {
    key: "clearcoat",
    get: function get() {
      return this._clearcoat;
    },
    set: function set(t) {
      this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
    }
  }, {
    key: "iridescence",
    get: function get() {
      return this._iridescence;
    },
    set: function set(t) {
      this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t;
    }
  }, {
    key: "sheen",
    get: function get() {
      return this._sheen;
    },
    set: function set(t) {
      this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
    }
  }, {
    key: "transmission",
    get: function get() {
      return this._transmission;
    },
    set: function set(t) {
      this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(ld.prototype), "copy", this).call(this, t), this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = _toConsumableArray(t.iridescenceThicknessRange), this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
    }
  }]);
}(od);
var cd = exports.MeshPhongMaterial = /*#__PURE__*/function (_$r10) {
  function cd(t) {
    var _this88;
    _classCallCheck(this, cd);
    _this88 = _callSuper(this, cd), _this88.isMeshPhongMaterial = !0, _this88.type = "MeshPhongMaterial", _this88.color = new Zr(16777215), _this88.specular = new Zr(1118481), _this88.shininess = 30, _this88.map = null, _this88.lightMap = null, _this88.lightMapIntensity = 1, _this88.aoMap = null, _this88.aoMapIntensity = 1, _this88.emissive = new Zr(0), _this88.emissiveIntensity = 1, _this88.emissiveMap = null, _this88.bumpMap = null, _this88.bumpScale = 1, _this88.normalMap = null, _this88.normalMapType = 0, _this88.normalScale = new Qn(1, 1), _this88.displacementMap = null, _this88.displacementScale = 1, _this88.displacementBias = 0, _this88.specularMap = null, _this88.alphaMap = null, _this88.envMap = null, _this88.combine = Y, _this88.reflectivity = 1, _this88.refractionRatio = .98, _this88.wireframe = !1, _this88.wireframeLinewidth = 1, _this88.wireframeLinecap = "round", _this88.wireframeLinejoin = "round", _this88.flatShading = !1, _this88.fog = !0, _this88.setValues(t);
    return _this88;
  }
  _inherits(cd, _$r10);
  return _createClass(cd, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(cd.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
    }
  }]);
}($r);
var hd = exports.MeshToonMaterial = /*#__PURE__*/function (_$r11) {
  function hd(t) {
    var _this89;
    _classCallCheck(this, hd);
    _this89 = _callSuper(this, hd), _this89.isMeshToonMaterial = !0, _this89.defines = {
      TOON: ""
    }, _this89.type = "MeshToonMaterial", _this89.color = new Zr(16777215), _this89.map = null, _this89.gradientMap = null, _this89.lightMap = null, _this89.lightMapIntensity = 1, _this89.aoMap = null, _this89.aoMapIntensity = 1, _this89.emissive = new Zr(0), _this89.emissiveIntensity = 1, _this89.emissiveMap = null, _this89.bumpMap = null, _this89.bumpScale = 1, _this89.normalMap = null, _this89.normalMapType = 0, _this89.normalScale = new Qn(1, 1), _this89.displacementMap = null, _this89.displacementScale = 1, _this89.displacementBias = 0, _this89.alphaMap = null, _this89.wireframe = !1, _this89.wireframeLinewidth = 1, _this89.wireframeLinecap = "round", _this89.wireframeLinejoin = "round", _this89.fog = !0, _this89.setValues(t);
    return _this89;
  }
  _inherits(hd, _$r11);
  return _createClass(hd, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(hd.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
    }
  }]);
}($r);
var ud = exports.MeshNormalMaterial = /*#__PURE__*/function (_$r12) {
  function ud(t) {
    var _this90;
    _classCallCheck(this, ud);
    _this90 = _callSuper(this, ud), _this90.isMeshNormalMaterial = !0, _this90.type = "MeshNormalMaterial", _this90.bumpMap = null, _this90.bumpScale = 1, _this90.normalMap = null, _this90.normalMapType = 0, _this90.normalScale = new Qn(1, 1), _this90.displacementMap = null, _this90.displacementScale = 1, _this90.displacementBias = 0, _this90.wireframe = !1, _this90.wireframeLinewidth = 1, _this90.flatShading = !1, _this90.setValues(t);
    return _this90;
  }
  _inherits(ud, _$r12);
  return _createClass(ud, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(ud.prototype), "copy", this).call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this;
    }
  }]);
}($r);
var dd = exports.MeshLambertMaterial = /*#__PURE__*/function (_$r13) {
  function dd(t) {
    var _this91;
    _classCallCheck(this, dd);
    _this91 = _callSuper(this, dd), _this91.isMeshLambertMaterial = !0, _this91.type = "MeshLambertMaterial", _this91.color = new Zr(16777215), _this91.map = null, _this91.lightMap = null, _this91.lightMapIntensity = 1, _this91.aoMap = null, _this91.aoMapIntensity = 1, _this91.emissive = new Zr(0), _this91.emissiveIntensity = 1, _this91.emissiveMap = null, _this91.bumpMap = null, _this91.bumpScale = 1, _this91.normalMap = null, _this91.normalMapType = 0, _this91.normalScale = new Qn(1, 1), _this91.displacementMap = null, _this91.displacementScale = 1, _this91.displacementBias = 0, _this91.specularMap = null, _this91.alphaMap = null, _this91.envMap = null, _this91.combine = Y, _this91.reflectivity = 1, _this91.refractionRatio = .98, _this91.wireframe = !1, _this91.wireframeLinewidth = 1, _this91.wireframeLinecap = "round", _this91.wireframeLinejoin = "round", _this91.flatShading = !1, _this91.fog = !0, _this91.setValues(t);
    return _this91;
  }
  _inherits(dd, _$r13);
  return _createClass(dd, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(dd.prototype), "copy", this).call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
    }
  }]);
}($r);
var pd = exports.MeshMatcapMaterial = /*#__PURE__*/function (_$r14) {
  function pd(t) {
    var _this92;
    _classCallCheck(this, pd);
    _this92 = _callSuper(this, pd), _this92.isMeshMatcapMaterial = !0, _this92.defines = {
      MATCAP: ""
    }, _this92.type = "MeshMatcapMaterial", _this92.color = new Zr(16777215), _this92.matcap = null, _this92.map = null, _this92.bumpMap = null, _this92.bumpScale = 1, _this92.normalMap = null, _this92.normalMapType = 0, _this92.normalScale = new Qn(1, 1), _this92.displacementMap = null, _this92.displacementScale = 1, _this92.displacementBias = 0, _this92.alphaMap = null, _this92.flatShading = !1, _this92.fog = !0, _this92.setValues(t);
    return _this92;
  }
  _inherits(pd, _$r14);
  return _createClass(pd, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(pd.prototype), "copy", this).call(this, t), this.defines = {
        MATCAP: ""
      }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this.fog = t.fog, this;
    }
  }]);
}($r);
var md = exports.LineDashedMaterial = /*#__PURE__*/function (_dh) {
  function md(t) {
    var _this93;
    _classCallCheck(this, md);
    _this93 = _callSuper(this, md), _this93.isLineDashedMaterial = !0, _this93.type = "LineDashedMaterial", _this93.scale = 1, _this93.dashSize = 3, _this93.gapSize = 1, _this93.setValues(t);
    return _this93;
  }
  _inherits(md, _dh);
  return _createClass(md, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(md.prototype), "copy", this).call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
    }
  }]);
}(dh);
function fd(t, e, n) {
  return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t);
}
function gd(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function _d(t) {
  var e = t.length,
    n = new Array(e);
  for (var _t250 = 0; _t250 !== e; ++_t250) n[_t250] = _t250;
  return n.sort(function (e, n) {
    return t[e] - t[n];
  }), n;
}
function vd(t, e, n) {
  var i = t.length,
    r = new t.constructor(i);
  for (var _s79 = 0, _a62 = 0; _a62 !== i; ++_s79) {
    var _i174 = n[_s79] * e;
    for (var _n225 = 0; _n225 !== e; ++_n225) r[_a62++] = t[_i174 + _n225];
  }
  return r;
}
function xd(t, e, n, i) {
  var r = 1,
    s = t[0];
  for (; void 0 !== s && void 0 === s[i];) s = t[r++];
  if (void 0 === s) return;
  var a = s[i];
  if (void 0 !== a) if (Array.isArray(a)) do {
    a = s[i], void 0 !== a && (e.push(s.time), n.push.apply(n, a)), s = t[r++];
  } while (void 0 !== s);else if (void 0 !== a.toArray) do {
    a = s[i], void 0 !== a && (e.push(s.time), a.toArray(n, n.length)), s = t[r++];
  } while (void 0 !== s);else do {
    a = s[i], void 0 !== a && (e.push(s.time), n.push(a)), s = t[r++];
  } while (void 0 !== s);
}
var yd = exports.AnimationUtils = {
  convertArray: fd,
  isTypedArray: gd,
  getKeyframeOrder: _d,
  sortedArray: vd,
  flattenJSON: xd,
  subclip: function subclip(t, e, n, i) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 30;
    var s = t.clone();
    s.name = e;
    var a = [];
    for (var _t251 = 0; _t251 < s.tracks.length; ++_t251) {
      var _e246 = s.tracks[_t251],
        _o50 = _e246.getValueSize(),
        _l30 = [],
        _c24 = [];
      for (var _t252 = 0; _t252 < _e246.times.length; ++_t252) {
        var _s80 = _e246.times[_t252] * r;
        if (!(_s80 < n || _s80 >= i)) {
          _l30.push(_e246.times[_t252]);
          for (var _n226 = 0; _n226 < _o50; ++_n226) _c24.push(_e246.values[_t252 * _o50 + _n226]);
        }
      }
      0 !== _l30.length && (_e246.times = fd(_l30, _e246.times.constructor), _e246.values = fd(_c24, _e246.values.constructor), a.push(_e246));
    }
    s.tracks = a;
    var o = 1 / 0;
    for (var _t253 = 0; _t253 < s.tracks.length; ++_t253) o > s.tracks[_t253].times[0] && (o = s.tracks[_t253].times[0]);
    for (var _t254 = 0; _t254 < s.tracks.length; ++_t254) s.tracks[_t254].shift(-1 * o);
    return s.resetDuration(), s;
  },
  makeClipAdditive: function makeClipAdditive(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
    i <= 0 && (i = 30);
    var r = n.tracks.length,
      s = e / i;
    var _loop = function _loop() {
        var i = n.tracks[_e247],
          r = i.ValueTypeName;
        if ("bool" === r || "string" === r) return 0; // continue
        var a = t.tracks.find(function (t) {
          return t.name === i.name && t.ValueTypeName === r;
        });
        if (void 0 === a) return 0; // continue
        var o = 0;
        var l = i.getValueSize();
        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
        var c = 0;
        var h = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
        var u = i.times.length - 1;
        var d;
        if (s <= i.times[0]) {
          var _t255 = o,
            _e248 = l - o;
          d = i.values.slice(_t255, _e248);
        } else if (s >= i.times[u]) {
          var _t256 = u * l + o,
            _e249 = _t256 + l - o;
          d = i.values.slice(_t256, _e249);
        } else {
          var _t257 = i.createInterpolant(),
            _e250 = o,
            _n227 = l - o;
          _t257.evaluate(s), d = _t257.resultBuffer.slice(_e250, _n227);
        }
        if ("quaternion" === r) {
          new Li().fromArray(d).normalize().conjugate().toArray(d);
        }
        var p = a.times.length;
        for (var _t258 = 0; _t258 < p; ++_t258) {
          var _e251 = _t258 * h + c;
          if ("quaternion" === r) Li.multiplyQuaternionsFlat(a.values, _e251, d, 0, a.values, _e251);else {
            var _t259 = h - 2 * c;
            for (var _n228 = 0; _n228 < _t259; ++_n228) a.values[_e251 + _n228] -= d[_n228];
          }
        }
      },
      _ret;
    for (var _e247 = 0; _e247 < r; ++_e247) {
      _ret = _loop();
      if (_ret === 0) continue;
    }
    return t.blendMode = De, t;
  }
};
var Md = exports.Interpolant = /*#__PURE__*/function () {
  function Md(t, e, n, i) {
    _classCallCheck(this, Md);
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  return _createClass(Md, [{
    key: "evaluate",
    value: function evaluate(t) {
      var e = this.parameterPositions;
      var n = this._cachedIndex,
        i = e[n],
        r = e[n - 1];
      t: {
        e: {
          var _s81;
          n: {
            i: if (!(t < i)) {
              for (var _s82 = n + 2;;) {
                if (void 0 === i) {
                  if (t < r) break i;
                  return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === _s82) break;
                if (r = i, i = e[++n], t < i) break e;
              }
              _s81 = e.length;
              break n;
            }
            if (t >= r) break t;
            {
              var _a63 = e[1];
              t < _a63 && (n = 2, r = _a63);
              for (var _s83 = n - 2;;) {
                if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (n === _s83) break;
                if (i = r, r = e[--n - 1], t >= r) break e;
              }
              _s81 = n, n = 0;
            }
          }
          for (; n < _s81;) {
            var _i175 = n + _s81 >>> 1;
            t < e[_i175] ? _s81 = _i175 : n = _i175 + 1;
          }
          if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
          if (void 0 === i) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
        }
        this._cachedIndex = n, this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, t, i);
    }
  }, {
    key: "getSettings_",
    value: function getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
  }, {
    key: "copySampleValue_",
    value: function copySampleValue_(t) {
      var e = this.resultBuffer,
        n = this.sampleValues,
        i = this.valueSize,
        r = t * i;
      for (var _t260 = 0; _t260 !== i; ++_t260) e[_t260] = n[r + _t260];
      return e;
    }
  }, {
    key: "interpolate_",
    value: function interpolate_() {
      throw new Error("call to abstract method");
    }
  }, {
    key: "intervalChanged_",
    value: function intervalChanged_() {}
  }]);
}();
var Sd = exports.CubicInterpolant = /*#__PURE__*/function (_Md) {
  function Sd(t, e, n, i) {
    var _this94;
    _classCallCheck(this, Sd);
    _this94 = _callSuper(this, Sd, [t, e, n, i]), _this94._weightPrev = -0, _this94._offsetPrev = -0, _this94._weightNext = -0, _this94._offsetNext = -0, _this94.DefaultSettings_ = {
      endingStart: Le,
      endingEnd: Le
    };
    return _this94;
  }
  _inherits(Sd, _Md);
  return _createClass(Sd, [{
    key: "intervalChanged_",
    value: function intervalChanged_(t, e, n) {
      var i = this.parameterPositions;
      var r = t - 2,
        s = t + 1,
        a = i[r],
        o = i[s];
      if (void 0 === a) switch (this.getSettings_().endingStart) {
        case Ie:
          r = t, a = 2 * e - n;
          break;
        case Ue:
          r = i.length - 2, a = e + i[r] - i[r + 1];
          break;
        default:
          r = t, a = n;
      }
      if (void 0 === o) switch (this.getSettings_().endingEnd) {
        case Ie:
          s = t, o = 2 * n - e;
          break;
        case Ue:
          s = 1, o = n + i[1] - i[0];
          break;
        default:
          s = t - 1, o = e;
      }
      var l = .5 * (n - e),
        c = this.valueSize;
      this._weightPrev = l / (e - a), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = s * c;
    }
  }, {
    key: "interpolate_",
    value: function interpolate_(t, e, n, i) {
      var r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        c = this._offsetPrev,
        h = this._offsetNext,
        u = this._weightPrev,
        d = this._weightNext,
        p = (n - e) / (i - e),
        m = p * p,
        f = m * p,
        g = -u * f + 2 * u * m - u * p,
        _ = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
        v = (-1 - d) * f + (1.5 + d) * m + .5 * p,
        x = d * f - d * m;
      for (var _t261 = 0; _t261 !== a; ++_t261) r[_t261] = g * s[c + _t261] + _ * s[l + _t261] + v * s[o + _t261] + x * s[h + _t261];
      return r;
    }
  }]);
}(Md);
var bd = exports.LinearInterpolant = /*#__PURE__*/function (_Md2) {
  function bd(t, e, n, i) {
    _classCallCheck(this, bd);
    return _callSuper(this, bd, [t, e, n, i]);
  }
  _inherits(bd, _Md2);
  return _createClass(bd, [{
    key: "interpolate_",
    value: function interpolate_(t, e, n, i) {
      var r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        c = (n - e) / (i - e),
        h = 1 - c;
      for (var _t262 = 0; _t262 !== a; ++_t262) r[_t262] = s[l + _t262] * h + s[o + _t262] * c;
      return r;
    }
  }]);
}(Md);
var Ed = exports.DiscreteInterpolant = /*#__PURE__*/function (_Md3) {
  function Ed(t, e, n, i) {
    _classCallCheck(this, Ed);
    return _callSuper(this, Ed, [t, e, n, i]);
  }
  _inherits(Ed, _Md3);
  return _createClass(Ed, [{
    key: "interpolate_",
    value: function interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  }]);
}(Md);
var Td = exports.KeyframeTrack = /*#__PURE__*/function () {
  function Td(t, e, n, i) {
    _classCallCheck(this, Td);
    if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = fd(e, this.TimeBufferType), this.values = fd(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  return _createClass(Td, [{
    key: "InterpolantFactoryMethodDiscrete",
    value: function InterpolantFactoryMethodDiscrete(t) {
      return new Ed(this.times, this.values, this.getValueSize(), t);
    }
  }, {
    key: "InterpolantFactoryMethodLinear",
    value: function InterpolantFactoryMethodLinear(t) {
      return new bd(this.times, this.values, this.getValueSize(), t);
    }
  }, {
    key: "InterpolantFactoryMethodSmooth",
    value: function InterpolantFactoryMethodSmooth(t) {
      return new Sd(this.times, this.values, this.getValueSize(), t);
    }
  }, {
    key: "setInterpolation",
    value: function setInterpolation(t) {
      var e;
      switch (t) {
        case Re:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case Ce:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case Pe:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === e) {
        var _e252 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(_e252);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", _e252), this;
      }
      return this.createInterpolant = e, this;
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return Re;
        case this.InterpolantFactoryMethodLinear:
          return Ce;
        case this.InterpolantFactoryMethodSmooth:
          return Pe;
      }
    }
  }, {
    key: "getValueSize",
    value: function getValueSize() {
      return this.values.length / this.times.length;
    }
  }, {
    key: "shift",
    value: function shift(t) {
      if (0 !== t) {
        var _e253 = this.times;
        for (var _n229 = 0, _i176 = _e253.length; _n229 !== _i176; ++_n229) _e253[_n229] += t;
      }
      return this;
    }
  }, {
    key: "scale",
    value: function scale(t) {
      if (1 !== t) {
        var _e254 = this.times;
        for (var _n230 = 0, _i177 = _e254.length; _n230 !== _i177; ++_n230) _e254[_n230] *= t;
      }
      return this;
    }
  }, {
    key: "trim",
    value: function trim(t, e) {
      var n = this.times,
        i = n.length;
      var r = 0,
        s = i - 1;
      for (; r !== i && n[r] < t;) ++r;
      for (; -1 !== s && n[s] > e;) --s;
      if (++s, 0 !== r || s !== i) {
        r >= s && (s = Math.max(s, 1), r = s - 1);
        var _t263 = this.getValueSize();
        this.times = n.slice(r, s), this.values = this.values.slice(r * _t263, s * _t263);
      }
      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var t = !0;
      var e = this.getValueSize();
      e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
      var n = this.times,
        i = this.values,
        r = n.length;
      0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
      var s = null;
      for (var _e255 = 0; _e255 !== r; _e255++) {
        var _i178 = n[_e255];
        if ("number" == typeof _i178 && isNaN(_i178)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, _e255, _i178), t = !1;
          break;
        }
        if (null !== s && s > _i178) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, _e255, _i178, s), t = !1;
          break;
        }
        s = _i178;
      }
      if (void 0 !== i && gd(i)) for (var _e256 = 0, _n231 = i.length; _e256 !== _n231; ++_e256) {
        var _n232 = i[_e256];
        if (isNaN(_n232)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, _e256, _n232), t = !1;
          break;
        }
      }
      return t;
    }
  }, {
    key: "optimize",
    value: function optimize() {
      var t = this.times.slice(),
        e = this.values.slice(),
        n = this.getValueSize(),
        i = this.getInterpolation() === Pe,
        r = t.length - 1;
      var s = 1;
      for (var _a64 = 1; _a64 < r; ++_a64) {
        var _r137 = !1;
        var _o51 = t[_a64];
        if (_o51 !== t[_a64 + 1] && (1 !== _a64 || _o51 !== t[0])) if (i) _r137 = !0;else {
          var _t264 = _a64 * n,
            _i179 = _t264 - n,
            _s84 = _t264 + n;
          for (var _a65 = 0; _a65 !== n; ++_a65) {
            var _n233 = e[_t264 + _a65];
            if (_n233 !== e[_i179 + _a65] || _n233 !== e[_s84 + _a65]) {
              _r137 = !0;
              break;
            }
          }
        }
        if (_r137) {
          if (_a64 !== s) {
            t[s] = t[_a64];
            var _i180 = _a64 * n,
              _r138 = s * n;
            for (var _t265 = 0; _t265 !== n; ++_t265) e[_r138 + _t265] = e[_i180 + _t265];
          }
          ++s;
        }
      }
      if (r > 0) {
        t[s] = t[r];
        for (var _t266 = r * n, _i181 = s * n, _a66 = 0; _a66 !== n; ++_a66) e[_i181 + _a66] = e[_t266 + _a66];
        ++s;
      }
      return s !== t.length ? (this.times = t.slice(0, s), this.values = e.slice(0, s * n)) : (this.times = t, this.values = e), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var t = this.times.slice(),
        e = this.values.slice(),
        n = new (0, this.constructor)(this.name, t, e);
      return n.createInterpolant = this.createInterpolant, n;
    }
  }], [{
    key: "toJSON",
    value: function toJSON(t) {
      var e = t.constructor;
      var n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t);else {
        n = {
          name: t.name,
          times: fd(t.times, Array),
          values: fd(t.values, Array)
        };
        var _e257 = t.getInterpolation();
        _e257 !== t.DefaultInterpolation && (n.interpolation = _e257);
      }
      return n.type = t.ValueTypeName, n;
    }
  }]);
}();
Td.prototype.TimeBufferType = Float32Array, Td.prototype.ValueBufferType = Float32Array, Td.prototype.DefaultInterpolation = Ce;
var wd = exports.BooleanKeyframeTrack = /*#__PURE__*/function (_Td) {
  function wd() {
    _classCallCheck(this, wd);
    return _callSuper(this, wd, arguments);
  }
  _inherits(wd, _Td);
  return _createClass(wd);
}(Td);
wd.prototype.ValueTypeName = "bool", wd.prototype.ValueBufferType = Array, wd.prototype.DefaultInterpolation = Re, wd.prototype.InterpolantFactoryMethodLinear = void 0, wd.prototype.InterpolantFactoryMethodSmooth = void 0;
var Ad = exports.ColorKeyframeTrack = /*#__PURE__*/function (_Td2) {
  function Ad() {
    _classCallCheck(this, Ad);
    return _callSuper(this, Ad, arguments);
  }
  _inherits(Ad, _Td2);
  return _createClass(Ad);
}(Td);
Ad.prototype.ValueTypeName = "color";
var Rd = exports.NumberKeyframeTrack = /*#__PURE__*/function (_Td3) {
  function Rd() {
    _classCallCheck(this, Rd);
    return _callSuper(this, Rd, arguments);
  }
  _inherits(Rd, _Td3);
  return _createClass(Rd);
}(Td);
Rd.prototype.ValueTypeName = "number";
var Cd = exports.QuaternionLinearInterpolant = /*#__PURE__*/function (_Md4) {
  function Cd(t, e, n, i) {
    _classCallCheck(this, Cd);
    return _callSuper(this, Cd, [t, e, n, i]);
  }
  _inherits(Cd, _Md4);
  return _createClass(Cd, [{
    key: "interpolate_",
    value: function interpolate_(t, e, n, i) {
      var r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = (n - e) / (i - e);
      var l = t * a;
      for (var _t267 = l + a; l !== _t267; l += 4) Li.slerpFlat(r, 0, s, l - a, s, l, o);
      return r;
    }
  }]);
}(Md);
var Pd = exports.QuaternionKeyframeTrack = /*#__PURE__*/function (_Td4) {
  function Pd() {
    _classCallCheck(this, Pd);
    return _callSuper(this, Pd, arguments);
  }
  _inherits(Pd, _Td4);
  return _createClass(Pd, [{
    key: "InterpolantFactoryMethodLinear",
    value: function InterpolantFactoryMethodLinear(t) {
      return new Cd(this.times, this.values, this.getValueSize(), t);
    }
  }]);
}(Td);
Pd.prototype.ValueTypeName = "quaternion", Pd.prototype.DefaultInterpolation = Ce, Pd.prototype.InterpolantFactoryMethodSmooth = void 0;
var Ld = exports.StringKeyframeTrack = /*#__PURE__*/function (_Td5) {
  function Ld() {
    _classCallCheck(this, Ld);
    return _callSuper(this, Ld, arguments);
  }
  _inherits(Ld, _Td5);
  return _createClass(Ld);
}(Td);
Ld.prototype.ValueTypeName = "string", Ld.prototype.ValueBufferType = Array, Ld.prototype.DefaultInterpolation = Re, Ld.prototype.InterpolantFactoryMethodLinear = void 0, Ld.prototype.InterpolantFactoryMethodSmooth = void 0;
var Id = exports.VectorKeyframeTrack = /*#__PURE__*/function (_Td6) {
  function Id() {
    _classCallCheck(this, Id);
    return _callSuper(this, Id, arguments);
  }
  _inherits(Id, _Td6);
  return _createClass(Id);
}(Td);
Id.prototype.ValueTypeName = "vector";
var Ud = exports.AnimationClip = /*#__PURE__*/function () {
  function Ud(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2500;
    _classCallCheck(this, Ud);
    this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Wn(), this.duration < 0 && this.resetDuration();
  }
  return _createClass(Ud, [{
    key: "resetDuration",
    value: function resetDuration() {
      var t = 0;
      for (var _e258 = 0, _n234 = this.tracks.length; _e258 !== _n234; ++_e258) {
        var _n235 = this.tracks[_e258];
        t = Math.max(t, _n235.times[_n235.times.length - 1]);
      }
      return this.duration = t, this;
    }
  }, {
    key: "trim",
    value: function trim() {
      for (var _t268 = 0; _t268 < this.tracks.length; _t268++) this.tracks[_t268].trim(0, this.duration);
      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var t = !0;
      for (var _e259 = 0; _e259 < this.tracks.length; _e259++) t = t && this.tracks[_e259].validate();
      return t;
    }
  }, {
    key: "optimize",
    value: function optimize() {
      for (var _t269 = 0; _t269 < this.tracks.length; _t269++) this.tracks[_t269].optimize();
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var t = [];
      for (var _e260 = 0; _e260 < this.tracks.length; _e260++) t.push(this.tracks[_e260].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.constructor.toJSON(this);
    }
  }], [{
    key: "parse",
    value: function parse(t) {
      var e = [],
        n = t.tracks,
        i = 1 / (t.fps || 1);
      for (var _t270 = 0, _r139 = n.length; _t270 !== _r139; ++_t270) e.push(Nd(n[_t270]).scale(i));
      var r = new this(t.name, t.duration, e, t.blendMode);
      return r.uuid = t.uuid, r;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = [],
        n = t.tracks,
        i = {
          name: t.name,
          duration: t.duration,
          tracks: e,
          uuid: t.uuid,
          blendMode: t.blendMode
        };
      for (var _t271 = 0, _i182 = n.length; _t271 !== _i182; ++_t271) e.push(Td.toJSON(n[_t271]));
      return i;
    }
  }, {
    key: "CreateFromMorphTargetSequence",
    value: function CreateFromMorphTargetSequence(t, e, n, i) {
      var r = e.length,
        s = [];
      for (var _t272 = 0; _t272 < r; _t272++) {
        var _a67 = [],
          _o52 = [];
        _a67.push((_t272 + r - 1) % r, _t272, (_t272 + 1) % r), _o52.push(0, 1, 0);
        var _l31 = _d(_a67);
        _a67 = vd(_a67, 1, _l31), _o52 = vd(_o52, 1, _l31), i || 0 !== _a67[0] || (_a67.push(r), _o52.push(_o52[0])), s.push(new Rd(".morphTargetInfluences[" + e[_t272].name + "]", _a67, _o52).scale(1 / n));
      }
      return new this(t, -1, s);
    }
  }, {
    key: "findByName",
    value: function findByName(t, e) {
      var n = t;
      if (!Array.isArray(t)) {
        var _e261 = t;
        n = _e261.geometry && _e261.geometry.animations || _e261.animations;
      }
      for (var _t273 = 0; _t273 < n.length; _t273++) if (n[_t273].name === e) return n[_t273];
      return null;
    }
  }, {
    key: "CreateClipsFromMorphTargetSequences",
    value: function CreateClipsFromMorphTargetSequences(t, e, n) {
      var i = {},
        r = /^([\w-]*?)([\d]+)$/;
      for (var _e262 = 0, _n236 = t.length; _e262 < _n236; _e262++) {
        var _n237 = t[_e262],
          _s85 = _n237.name.match(r);
        if (_s85 && _s85.length > 1) {
          var _t274 = _s85[1];
          var _e263 = i[_t274];
          _e263 || (i[_t274] = _e263 = []), _e263.push(_n237);
        }
      }
      var s = [];
      for (var _t275 in i) s.push(this.CreateFromMorphTargetSequence(_t275, i[_t275], e, n));
      return s;
    }
  }, {
    key: "parseAnimation",
    value: function parseAnimation(t, e) {
      if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      var n = function n(t, e, _n238, i, r) {
          if (0 !== _n238.length) {
            var _s86 = [],
              _a68 = [];
            xd(_n238, _s86, _a68, i), 0 !== _s86.length && r.push(new t(e, _s86, _a68));
          }
        },
        i = [],
        r = t.name || "default",
        s = t.fps || 30,
        a = t.blendMode;
      var o = t.length || -1;
      var l = t.hierarchy || [];
      for (var _t276 = 0; _t276 < l.length; _t276++) {
        var _r140 = l[_t276].keys;
        if (_r140 && 0 !== _r140.length) if (_r140[0].morphTargets) {
          var _t277 = {};
          var _e264 = void 0;
          for (_e264 = 0; _e264 < _r140.length; _e264++) if (_r140[_e264].morphTargets) for (var _n239 = 0; _n239 < _r140[_e264].morphTargets.length; _n239++) _t277[_r140[_e264].morphTargets[_n239]] = -1;
          for (var _n240 in _t277) {
            var _t278 = [],
              _s87 = [];
            for (var _i183 = 0; _i183 !== _r140[_e264].morphTargets.length; ++_i183) {
              var _i184 = _r140[_e264];
              _t278.push(_i184.time), _s87.push(_i184.morphTarget === _n240 ? 1 : 0);
            }
            i.push(new Rd(".morphTargetInfluence[" + _n240 + "]", _t278, _s87));
          }
          o = _t277.length * s;
        } else {
          var _s88 = ".bones[" + e[_t276].name + "]";
          n(Id, _s88 + ".position", _r140, "pos", i), n(Pd, _s88 + ".quaternion", _r140, "rot", i), n(Id, _s88 + ".scale", _r140, "scl", i);
        }
      }
      if (0 === i.length) return null;
      return new this(r, o, i, a);
    }
  }]);
}();
function Nd(t) {
  if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  var e = function (t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Rd;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Id;
      case "color":
        return Ad;
      case "quaternion":
        return Pd;
      case "bool":
      case "boolean":
        return wd;
      case "string":
        return Ld;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }(t.type);
  if (void 0 === t.times) {
    var _e265 = [],
      _n241 = [];
    xd(t.keys, _e265, _n241, "value"), t.times = _e265, t.values = _n241;
  }
  return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
}
var Dd = exports.Cache = {
  enabled: !1,
  files: {},
  add: function add(t, e) {
    !1 !== this.enabled && (this.files[t] = e);
  },
  get: function get(t) {
    if (!1 !== this.enabled) return this.files[t];
  },
  remove: function remove(t) {
    delete this.files[t];
  },
  clear: function clear() {
    this.files = {};
  }
};
var Od = exports.LoadingManager = /*#__PURE__*/_createClass(function Od(t, e, n) {
  _classCallCheck(this, Od);
  var i = this;
  var r,
    s = !1,
    a = 0,
    o = 0;
  var l = [];
  this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
    o++, !1 === s && void 0 !== i.onStart && i.onStart(t, a, o), s = !0;
  }, this.itemEnd = function (t) {
    a++, void 0 !== i.onProgress && i.onProgress(t, a, o), a === o && (s = !1, void 0 !== i.onLoad && i.onLoad());
  }, this.itemError = function (t) {
    void 0 !== i.onError && i.onError(t);
  }, this.resolveURL = function (t) {
    return r ? r(t) : t;
  }, this.setURLModifier = function (t) {
    return r = t, this;
  }, this.addHandler = function (t, e) {
    return l.push(t, e), this;
  }, this.removeHandler = function (t) {
    var e = l.indexOf(t);
    return -1 !== e && l.splice(e, 2), this;
  }, this.getHandler = function (t) {
    for (var _e266 = 0, _n242 = l.length; _e266 < _n242; _e266 += 2) {
      var _n243 = l[_e266],
        _i185 = l[_e266 + 1];
      if (_n243.global && (_n243.lastIndex = 0), _n243.test(t)) return _i185;
    }
    return null;
  };
});
var Fd = exports.DefaultLoadingManager = new Od();
var Bd = exports.Loader = /*#__PURE__*/function () {
  function Bd(t) {
    _classCallCheck(this, Bd);
    this.manager = void 0 !== t ? t : Fd, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  return _createClass(Bd, [{
    key: "load",
    value: function load() {}
  }, {
    key: "loadAsync",
    value: function loadAsync(t, e) {
      var n = this;
      return new Promise(function (i, r) {
        n.load(t, i, e, r);
      });
    }
  }, {
    key: "parse",
    value: function parse() {}
  }, {
    key: "setCrossOrigin",
    value: function setCrossOrigin(t) {
      return this.crossOrigin = t, this;
    }
  }, {
    key: "setWithCredentials",
    value: function setWithCredentials(t) {
      return this.withCredentials = t, this;
    }
  }, {
    key: "setPath",
    value: function setPath(t) {
      return this.path = t, this;
    }
  }, {
    key: "setResourcePath",
    value: function setResourcePath(t) {
      return this.resourcePath = t, this;
    }
  }, {
    key: "setRequestHeader",
    value: function setRequestHeader(t) {
      return this.requestHeader = t, this;
    }
  }]);
}();
Bd.DEFAULT_MATERIAL_NAME = "__DEFAULT";
var zd = {};
var Hd = /*#__PURE__*/function (_Error) {
  function Hd(t, e) {
    var _this95;
    _classCallCheck(this, Hd);
    _this95 = _callSuper(this, Hd, [t]), _this95.response = e;
    return _this95;
  }
  _inherits(Hd, _Error);
  return _createClass(Hd);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var Vd = exports.FileLoader = /*#__PURE__*/function (_Bd) {
  function Vd(t) {
    _classCallCheck(this, Vd);
    return _callSuper(this, Vd, [t]);
  }
  _inherits(Vd, _Bd);
  return _createClass(Vd, [{
    key: "load",
    value: function load(t, e, n, i) {
      var _this96 = this;
      void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      var r = Dd.get(t);
      if (void 0 !== r) return this.manager.itemStart(t), setTimeout(function () {
        e && e(r), _this96.manager.itemEnd(t);
      }, 0), r;
      if (void 0 !== zd[t]) return void zd[t].push({
        onLoad: e,
        onProgress: n,
        onError: i
      });
      zd[t] = [], zd[t].push({
        onLoad: e,
        onProgress: n,
        onError: i
      });
      var s = new Request(t, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin"
        }),
        a = this.mimeType,
        o = this.responseType;
      fetch(s).then(function (e) {
        if (200 === e.status || 0 === e.status) {
          if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
          var _n244 = zd[t],
            _i186 = e.body.getReader(),
            _r141 = e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
            _s89 = _r141 ? parseInt(_r141) : 0,
            _a69 = 0 !== _s89;
          var _o53 = 0;
          var _l32 = new ReadableStream({
            start: function start(t) {
              !function e() {
                _i186.read().then(function (_ref3) {
                  var i = _ref3.done,
                    r = _ref3.value;
                  if (i) t.close();else {
                    _o53 += r.byteLength;
                    var _i187 = new ProgressEvent("progress", {
                      lengthComputable: _a69,
                      loaded: _o53,
                      total: _s89
                    });
                    for (var _t279 = 0, _e267 = _n244.length; _t279 < _e267; _t279++) {
                      var _e268 = _n244[_t279];
                      _e268.onProgress && _e268.onProgress(_i187);
                    }
                    t.enqueue(r), e();
                  }
                });
              }();
            }
          });
          return new Response(_l32);
        }
        throw new Hd("fetch for \"".concat(e.url, "\" responded with ").concat(e.status, ": ").concat(e.statusText), e);
      }).then(function (t) {
        switch (o) {
          case "arraybuffer":
            return t.arrayBuffer();
          case "blob":
            return t.blob();
          case "document":
            return t.text().then(function (t) {
              return new DOMParser().parseFromString(t, a);
            });
          case "json":
            return t.json();
          default:
            if (void 0 === a) return t.text();
            {
              var _e269 = /charset="?([^;"\s]*)"?/i.exec(a),
                _n245 = _e269 && _e269[1] ? _e269[1].toLowerCase() : void 0,
                _i188 = new TextDecoder(_n245);
              return t.arrayBuffer().then(function (t) {
                return _i188.decode(t);
              });
            }
        }
      }).then(function (e) {
        Dd.add(t, e);
        var n = zd[t];
        delete zd[t];
        for (var _t280 = 0, _i189 = n.length; _t280 < _i189; _t280++) {
          var _i190 = n[_t280];
          _i190.onLoad && _i190.onLoad(e);
        }
      }).catch(function (e) {
        var n = zd[t];
        if (void 0 === n) throw _this96.manager.itemError(t), e;
        delete zd[t];
        for (var _t281 = 0, _i191 = n.length; _t281 < _i191; _t281++) {
          var _i192 = n[_t281];
          _i192.onError && _i192.onError(e);
        }
        _this96.manager.itemError(t);
      }).finally(function () {
        _this96.manager.itemEnd(t);
      }), this.manager.itemStart(t);
    }
  }, {
    key: "setResponseType",
    value: function setResponseType(t) {
      return this.responseType = t, this;
    }
  }, {
    key: "setMimeType",
    value: function setMimeType(t) {
      return this.mimeType = t, this;
    }
  }]);
}(Bd);
var kd = exports.AnimationLoader = /*#__PURE__*/function (_Bd2) {
  function kd(t) {
    _classCallCheck(this, kd);
    return _callSuper(this, kd, [t]);
  }
  _inherits(kd, _Bd2);
  return _createClass(kd, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
        s = new Vd(this.manager);
      s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, function (n) {
        try {
          e(r.parse(JSON.parse(n)));
        } catch (e) {
          i ? i(e) : console.error(e), r.manager.itemError(t);
        }
      }, n, i);
    }
  }, {
    key: "parse",
    value: function parse(t) {
      var e = [];
      for (var _n246 = 0; _n246 < t.length; _n246++) {
        var _i193 = Ud.parse(t[_n246]);
        e.push(_i193);
      }
      return e;
    }
  }]);
}(Bd);
var Gd = exports.CompressedTextureLoader = /*#__PURE__*/function (_Bd3) {
  function Gd(t) {
    _classCallCheck(this, Gd);
    return _callSuper(this, Gd, [t]);
  }
  _inherits(Gd, _Bd3);
  return _createClass(Gd, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
        s = [],
        a = new Ih(),
        o = new Vd(this.manager);
      o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
      var l = 0;
      function c(c) {
        o.load(t[c], function (t) {
          var n = r.parse(t, !0);
          s[c] = {
            width: n.width,
            height: n.height,
            format: n.format,
            mipmaps: n.mipmaps
          }, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = yt), a.image = s, a.format = n.format, a.needsUpdate = !0, e && e(a));
        }, n, i);
      }
      if (Array.isArray(t)) for (var _e270 = 0, _n247 = t.length; _e270 < _n247; ++_e270) c(_e270);else o.load(t, function (t) {
        var n = r.parse(t, !0);
        if (n.isCubemap) {
          var _t282 = n.mipmaps.length / n.mipmapCount;
          for (var _e271 = 0; _e271 < _t282; _e271++) {
            s[_e271] = {
              mipmaps: []
            };
            for (var _t283 = 0; _t283 < n.mipmapCount; _t283++) s[_e271].mipmaps.push(n.mipmaps[_e271 * n.mipmapCount + _t283]), s[_e271].format = n.format, s[_e271].width = n.width, s[_e271].height = n.height;
          }
          a.image = s;
        } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
        1 === n.mipmapCount && (a.minFilter = yt), a.format = n.format, a.needsUpdate = !0, e && e(a);
      }, n, i);
      return a;
    }
  }]);
}(Bd);
var Wd = exports.ImageLoader = /*#__PURE__*/function (_Bd4) {
  function Wd(t) {
    _classCallCheck(this, Wd);
    return _callSuper(this, Wd, [t]);
  }
  _inherits(Wd, _Bd4);
  return _createClass(Wd, [{
    key: "load",
    value: function load(t, e, n, i) {
      void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      var r = this,
        s = Dd.get(t);
      if (void 0 !== s) return r.manager.itemStart(t), setTimeout(function () {
        e && e(s), r.manager.itemEnd(t);
      }, 0), s;
      var a = si("img");
      function o() {
        c(), Dd.add(t, this), e && e(this), r.manager.itemEnd(t);
      }
      function l(e) {
        c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
      }
      function c() {
        a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1);
      }
      return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a;
    }
  }]);
}(Bd);
var Xd = exports.CubeTextureLoader = /*#__PURE__*/function (_Bd5) {
  function Xd(t) {
    _classCallCheck(this, Xd);
    return _callSuper(this, Xd, [t]);
  }
  _inherits(Xd, _Bd5);
  return _createClass(Xd, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = new ra();
      r.colorSpace = je;
      var s = new Wd(this.manager);
      s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
      var a = 0;
      function o(n) {
        s.load(t[n], function (t) {
          r.images[n] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r));
        }, void 0, i);
      }
      for (var _e272 = 0; _e272 < t.length; ++_e272) o(_e272);
      return r;
    }
  }]);
}(Bd);
var jd = exports.DataTextureLoader = /*#__PURE__*/function (_Bd6) {
  function jd(t) {
    _classCallCheck(this, jd);
    return _callSuper(this, jd, [t]);
  }
  _inherits(jd, _Bd6);
  return _createClass(jd, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
        s = new Oc(),
        a = new Vd(this.manager);
      return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(t, function (t) {
        var n;
        try {
          n = r.parse(t);
        } catch (t) {
          if (void 0 === i) return void console.error(t);
          i(t);
        }
        void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : pt, s.wrapT = void 0 !== n.wrapT ? n.wrapT : pt, s.magFilter = void 0 !== n.magFilter ? n.magFilter : yt, s.minFilter = void 0 !== n.minFilter ? n.minFilter : yt, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace ? s.colorSpace = n.colorSpace : void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = bt), 1 === n.mipmapCount && (s.minFilter = yt), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n);
      }, n, i), s;
    }
  }]);
}(Bd);
var qd = exports.TextureLoader = /*#__PURE__*/function (_Bd7) {
  function qd(t) {
    _classCallCheck(this, qd);
    return _callSuper(this, qd, [t]);
  }
  _inherits(qd, _Bd7);
  return _createClass(qd, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = new Si(),
        s = new Wd(this.manager);
      return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, function (t) {
        r.image = t, r.needsUpdate = !0, void 0 !== e && e(r);
      }, n, i), r;
    }
  }]);
}(Bd);
var Yd = exports.Light = /*#__PURE__*/function (_Ur11) {
  function Yd(t) {
    var _this97;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    _classCallCheck(this, Yd);
    _this97 = _callSuper(this, Yd), _this97.isLight = !0, _this97.type = "Light", _this97.color = new Zr(t), _this97.intensity = e;
    return _this97;
  }
  _inherits(Yd, _Ur11);
  return _createClass(Yd, [{
    key: "dispose",
    value: function dispose() {}
  }, {
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Yd.prototype), "copy", this).call(this, t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(Yd.prototype), "toJSON", this).call(this, t);
      return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e;
    }
  }]);
}(Ur);
var Zd = exports.HemisphereLight = /*#__PURE__*/function (_Yd) {
  function Zd(t, e, n) {
    var _this98;
    _classCallCheck(this, Zd);
    _this98 = _callSuper(this, Zd, [t, n]), _this98.isHemisphereLight = !0, _this98.type = "HemisphereLight", _this98.position.copy(Ur.DEFAULT_UP), _this98.updateMatrix(), _this98.groundColor = new Zr(e);
    return _this98;
  }
  _inherits(Zd, _Yd);
  return _createClass(Zd, [{
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(Zd.prototype), "copy", this).call(this, t, e), this.groundColor.copy(t.groundColor), this;
    }
  }]);
}(Yd);
var Jd = new lr(),
  Kd = new Ii(),
  $d = new Ii();
var Qd = /*#__PURE__*/function () {
  function Qd(t) {
    _classCallCheck(this, Qd);
    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Qn(512, 512), this.map = null, this.mapPass = null, this.matrix = new lr(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new da(), this._frameExtents = new Qn(1, 1), this._viewportCount = 1, this._viewports = [new bi(0, 0, 1, 1)];
  }
  return _createClass(Qd, [{
    key: "getViewportCount",
    value: function getViewportCount() {
      return this._viewportCount;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this._frustum;
    }
  }, {
    key: "updateMatrices",
    value: function updateMatrices(t) {
      var e = this.camera,
        n = this.matrix;
      Kd.setFromMatrixPosition(t.matrixWorld), e.position.copy(Kd), $d.setFromMatrixPosition(t.target.matrixWorld), e.lookAt($d), e.updateMatrixWorld(), Jd.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Jd), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Jd);
    }
  }, {
    key: "getViewport",
    value: function getViewport(t) {
      return this._viewports[t];
    }
  }, {
    key: "getFrameExtents",
    value: function getFrameExtents() {
      return this._frameExtents;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = {};
      return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
    }
  }]);
}();
var tp = /*#__PURE__*/function (_Qd) {
  function tp() {
    var _this99;
    _classCallCheck(this, tp);
    _this99 = _callSuper(this, tp, [new ea(50, 1, .5, 500)]), _this99.isSpotLightShadow = !0, _this99.focus = 1;
    return _this99;
  }
  _inherits(tp, _Qd);
  return _createClass(tp, [{
    key: "updateMatrices",
    value: function updateMatrices(t) {
      var e = this.camera,
        n = 2 * Gn * t.angle * this.focus,
        i = this.mapSize.width / this.mapSize.height,
        r = t.distance || e.far;
      n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), _get(_getPrototypeOf(tp.prototype), "updateMatrices", this).call(this, t);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(tp.prototype), "copy", this).call(this, t), this.focus = t.focus, this;
    }
  }]);
}(Qd);
var ep = exports.SpotLight = /*#__PURE__*/function (_Yd2) {
  function ep(t, e) {
    var _this100;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI / 3;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;
    _classCallCheck(this, ep);
    _this100 = _callSuper(this, ep, [t, e]), _this100.isSpotLight = !0, _this100.type = "SpotLight", _this100.position.copy(Ur.DEFAULT_UP), _this100.updateMatrix(), _this100.target = new Ur(), _this100.distance = n, _this100.angle = i, _this100.penumbra = r, _this100.decay = s, _this100.map = null, _this100.shadow = new tp();
    return _this100;
  }
  _inherits(ep, _Yd2);
  return _createClass(ep, [{
    key: "power",
    get: function get() {
      return this.intensity * Math.PI;
    },
    set: function set(t) {
      this.intensity = t / Math.PI;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(ep.prototype), "copy", this).call(this, t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }]);
}(Yd);
var np = new lr(),
  ip = new Ii(),
  rp = new Ii();
var sp = /*#__PURE__*/function (_Qd2) {
  function sp() {
    var _this101;
    _classCallCheck(this, sp);
    _this101 = _callSuper(this, sp, [new ea(90, 1, .5, 500)]), _this101.isPointLightShadow = !0, _this101._frameExtents = new Qn(4, 2), _this101._viewportCount = 6, _this101._viewports = [new bi(2, 1, 1, 1), new bi(0, 1, 1, 1), new bi(3, 1, 1, 1), new bi(1, 1, 1, 1), new bi(3, 0, 1, 1), new bi(1, 0, 1, 1)], _this101._cubeDirections = [new Ii(1, 0, 0), new Ii(-1, 0, 0), new Ii(0, 0, 1), new Ii(0, 0, -1), new Ii(0, 1, 0), new Ii(0, -1, 0)], _this101._cubeUps = [new Ii(0, 1, 0), new Ii(0, 1, 0), new Ii(0, 1, 0), new Ii(0, 1, 0), new Ii(0, 0, 1), new Ii(0, 0, -1)];
    return _this101;
  }
  _inherits(sp, _Qd2);
  return _createClass(sp, [{
    key: "updateMatrices",
    value: function updateMatrices(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this.camera,
        i = this.matrix,
        r = t.distance || n.far;
      r !== n.far && (n.far = r, n.updateProjectionMatrix()), ip.setFromMatrixPosition(t.matrixWorld), n.position.copy(ip), rp.copy(n.position), rp.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(rp), n.updateMatrixWorld(), i.makeTranslation(-ip.x, -ip.y, -ip.z), np.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(np);
    }
  }]);
}(Qd);
var ap = exports.PointLight = /*#__PURE__*/function (_Yd3) {
  function ap(t, e) {
    var _this102;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;
    _classCallCheck(this, ap);
    _this102 = _callSuper(this, ap, [t, e]), _this102.isPointLight = !0, _this102.type = "PointLight", _this102.distance = n, _this102.decay = i, _this102.shadow = new sp();
    return _this102;
  }
  _inherits(ap, _Yd3);
  return _createClass(ap, [{
    key: "power",
    get: function get() {
      return 4 * this.intensity * Math.PI;
    },
    set: function set(t) {
      this.intensity = t / (4 * Math.PI);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(ap.prototype), "copy", this).call(this, t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
  }]);
}(Yd);
var op = /*#__PURE__*/function (_Qd3) {
  function op() {
    var _this103;
    _classCallCheck(this, op);
    _this103 = _callSuper(this, op, [new wa(-5, 5, 5, -5, .5, 500)]), _this103.isDirectionalLightShadow = !0;
    return _this103;
  }
  _inherits(op, _Qd3);
  return _createClass(op);
}(Qd);
var lp = exports.DirectionalLight = /*#__PURE__*/function (_Yd4) {
  function lp(t, e) {
    var _this104;
    _classCallCheck(this, lp);
    _this104 = _callSuper(this, lp, [t, e]), _this104.isDirectionalLight = !0, _this104.type = "DirectionalLight", _this104.position.copy(Ur.DEFAULT_UP), _this104.updateMatrix(), _this104.target = new Ur(), _this104.shadow = new op();
    return _this104;
  }
  _inherits(lp, _Yd4);
  return _createClass(lp, [{
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(lp.prototype), "copy", this).call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  }]);
}(Yd);
var cp = exports.AmbientLight = /*#__PURE__*/function (_Yd5) {
  function cp(t, e) {
    var _this105;
    _classCallCheck(this, cp);
    _this105 = _callSuper(this, cp, [t, e]), _this105.isAmbientLight = !0, _this105.type = "AmbientLight";
    return _this105;
  }
  _inherits(cp, _Yd5);
  return _createClass(cp);
}(Yd);
var hp = exports.RectAreaLight = /*#__PURE__*/function (_Yd6) {
  function hp(t, e) {
    var _this106;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
    _classCallCheck(this, hp);
    _this106 = _callSuper(this, hp, [t, e]), _this106.isRectAreaLight = !0, _this106.type = "RectAreaLight", _this106.width = n, _this106.height = i;
    return _this106;
  }
  _inherits(hp, _Yd6);
  return _createClass(hp, [{
    key: "power",
    get: function get() {
      return this.intensity * this.width * this.height * Math.PI;
    },
    set: function set(t) {
      this.intensity = t / (this.width * this.height * Math.PI);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(hp.prototype), "copy", this).call(this, t), this.width = t.width, this.height = t.height, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(hp.prototype), "toJSON", this).call(this, t);
      return e.object.width = this.width, e.object.height = this.height, e;
    }
  }]);
}(Yd);
var up = exports.SphericalHarmonics3 = /*#__PURE__*/function () {
  function up() {
    _classCallCheck(this, up);
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (var _t284 = 0; _t284 < 9; _t284++) this.coefficients.push(new Ii());
  }
  return _createClass(up, [{
    key: "set",
    value: function set(t) {
      for (var _e273 = 0; _e273 < 9; _e273++) this.coefficients[_e273].copy(t[_e273]);
      return this;
    }
  }, {
    key: "zero",
    value: function zero() {
      for (var _t285 = 0; _t285 < 9; _t285++) this.coefficients[_t285].set(0, 0, 0);
      return this;
    }
  }, {
    key: "getAt",
    value: function getAt(t, e) {
      var n = t.x,
        i = t.y,
        r = t.z,
        s = this.coefficients;
      return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * i), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * i * 1.092548), e.addScaledVector(s[5], i * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], n * r * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - i * i)), e;
    }
  }, {
    key: "getIrradianceAt",
    value: function getIrradianceAt(t, e) {
      var n = t.x,
        i = t.y,
        r = t.z,
        s = this.coefficients;
      return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * i), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * i), e.addScaledVector(s[5], .858086 * i * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * n * r), e.addScaledVector(s[8], .429043 * (n * n - i * i)), e;
    }
  }, {
    key: "add",
    value: function add(t) {
      for (var _e274 = 0; _e274 < 9; _e274++) this.coefficients[_e274].add(t.coefficients[_e274]);
      return this;
    }
  }, {
    key: "addScaledSH",
    value: function addScaledSH(t, e) {
      for (var _n248 = 0; _n248 < 9; _n248++) this.coefficients[_n248].addScaledVector(t.coefficients[_n248], e);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(t) {
      for (var _e275 = 0; _e275 < 9; _e275++) this.coefficients[_e275].multiplyScalar(t);
      return this;
    }
  }, {
    key: "lerp",
    value: function lerp(t, e) {
      for (var _n249 = 0; _n249 < 9; _n249++) this.coefficients[_n249].lerp(t.coefficients[_n249], e);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      for (var _e276 = 0; _e276 < 9; _e276++) if (!this.coefficients[_e276].equals(t.coefficients[_e276])) return !1;
      return !0;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.set(t.coefficients);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "fromArray",
    value: function fromArray(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this.coefficients;
      for (var _i194 = 0; _i194 < 9; _i194++) n[_i194].fromArray(t, e + 3 * _i194);
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var n = this.coefficients;
      for (var _i195 = 0; _i195 < 9; _i195++) n[_i195].toArray(t, e + 3 * _i195);
      return t;
    }
  }], [{
    key: "getBasisAt",
    value: function getBasisAt(t, e) {
      var n = t.x,
        i = t.y,
        r = t.z;
      e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i);
    }
  }]);
}();
var dp = exports.LightProbe = /*#__PURE__*/function (_Yd7) {
  function dp() {
    var _this107;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new up();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    _classCallCheck(this, dp);
    _this107 = _callSuper(this, dp, [void 0, e]), _this107.isLightProbe = !0, _this107.sh = t;
    return _this107;
  }
  _inherits(dp, _Yd7);
  return _createClass(dp, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(dp.prototype), "copy", this).call(this, t), this.sh.copy(t.sh), this;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(t) {
      return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(dp.prototype), "toJSON", this).call(this, t);
      return e.object.sh = this.sh.toArray(), e;
    }
  }]);
}(Yd);
var pp = exports.MaterialLoader = /*#__PURE__*/function (_Bd8) {
  function pp(t) {
    var _this108;
    _classCallCheck(this, pp);
    _this108 = _callSuper(this, pp, [t]), _this108.textures = {};
    return _this108;
  }
  _inherits(pp, _Bd8);
  return _createClass(pp, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
        s = new Vd(r.manager);
      s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, function (n) {
        try {
          e(r.parse(JSON.parse(n)));
        } catch (e) {
          i ? i(e) : console.error(e), r.manager.itemError(t);
        }
      }, n, i);
    }
  }, {
    key: "parse",
    value: function parse(t) {
      var e = this.textures;
      function n(t) {
        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t];
      }
      var i = pp.createMaterialFromType(t.type);
      if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = t.sheen), void 0 !== t.sheenColor && (i.sheenColor = new Zr().setHex(t.sheenColor)), void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.specularIntensity && (i.specularIntensity = t.specularIntensity), void 0 !== t.specularColor && void 0 !== i.specularColor && i.specularColor.setHex(t.specularColor), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.iridescence && (i.iridescence = t.iridescence), void 0 !== t.iridescenceIOR && (i.iridescenceIOR = t.iridescenceIOR), void 0 !== t.iridescenceThicknessRange && (i.iridescenceThicknessRange = t.iridescenceThicknessRange), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.thickness && (i.thickness = t.thickness), void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(t.attenuationColor), void 0 !== t.anisotropy && (i.anisotropy = t.anisotropy), void 0 !== t.anisotropyRotation && (i.anisotropyRotation = t.anisotropyRotation), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.alphaHash && (i.alphaHash = t.alphaHash), void 0 !== t.depthFunc && (i.depthFunc = t.depthFunc), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.blendSrc && (i.blendSrc = t.blendSrc), void 0 !== t.blendDst && (i.blendDst = t.blendDst), void 0 !== t.blendEquation && (i.blendEquation = t.blendEquation), void 0 !== t.blendSrcAlpha && (i.blendSrcAlpha = t.blendSrcAlpha), void 0 !== t.blendDstAlpha && (i.blendDstAlpha = t.blendDstAlpha), void 0 !== t.blendEquationAlpha && (i.blendEquationAlpha = t.blendEquationAlpha), void 0 !== t.blendColor && void 0 !== i.blendColor && i.blendColor.setHex(t.blendColor), void 0 !== t.blendAlpha && (i.blendAlpha = t.blendAlpha), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), void 0 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.forceSinglePass && (i.forceSinglePass = t.forceSinglePass), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms) for (var _e277 in t.uniforms) {
        var _r142 = t.uniforms[_e277];
        switch (i.uniforms[_e277] = {}, _r142.type) {
          case "t":
            i.uniforms[_e277].value = n(_r142.value);
            break;
          case "c":
            i.uniforms[_e277].value = new Zr().setHex(_r142.value);
            break;
          case "v2":
            i.uniforms[_e277].value = new Qn().fromArray(_r142.value);
            break;
          case "v3":
            i.uniforms[_e277].value = new Ii().fromArray(_r142.value);
            break;
          case "v4":
            i.uniforms[_e277].value = new bi().fromArray(_r142.value);
            break;
          case "m3":
            i.uniforms[_e277].value = new ti().fromArray(_r142.value);
            break;
          case "m4":
            i.uniforms[_e277].value = new lr().fromArray(_r142.value);
            break;
          default:
            i.uniforms[_e277].value = _r142.value;
        }
      }
      if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.glslVersion && (i.glslVersion = t.glslVersion), void 0 !== t.extensions) for (var _e278 in t.extensions) i.extensions[_e278] = t.extensions[_e278];
      if (void 0 !== t.lights && (i.lights = t.lights), void 0 !== t.clipping && (i.clipping = t.clipping), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
        var _e279 = t.normalScale;
        !1 === Array.isArray(_e279) && (_e279 = [_e279, _e279]), i.normalScale = new Qn().fromArray(_e279);
      }
      return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.specularIntensityMap && (i.specularIntensityMap = n(t.specularIntensityMap)), void 0 !== t.specularColorMap && (i.specularColorMap = n(t.specularColorMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = new Qn().fromArray(t.clearcoatNormalScale)), void 0 !== t.iridescenceMap && (i.iridescenceMap = n(t.iridescenceMap)), void 0 !== t.iridescenceThicknessMap && (i.iridescenceThicknessMap = n(t.iridescenceThicknessMap)), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)), void 0 !== t.anisotropyMap && (i.anisotropyMap = n(t.anisotropyMap)), void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)), void 0 !== t.sheenRoughnessMap && (i.sheenRoughnessMap = n(t.sheenRoughnessMap)), i;
    }
  }, {
    key: "setTextures",
    value: function setTextures(t) {
      return this.textures = t, this;
    }
  }], [{
    key: "createMaterialFromType",
    value: function createMaterialFromType(t) {
      return new {
        ShadowMaterial: sd,
        SpriteMaterial: ac,
        RawShaderMaterial: ad,
        ShaderMaterial: Js,
        PointsMaterial: bh,
        MeshPhysicalMaterial: ld,
        MeshStandardMaterial: od,
        MeshPhongMaterial: cd,
        MeshToonMaterial: hd,
        MeshNormalMaterial: ud,
        MeshLambertMaterial: dd,
        MeshDepthMaterial: Bl,
        MeshDistanceMaterial: zl,
        MeshBasicMaterial: Qr,
        MeshMatcapMaterial: pd,
        LineDashedMaterial: md,
        LineBasicMaterial: dh,
        Material: $r
      }[t]();
    }
  }]);
}(Bd);
var mp = exports.LoaderUtils = /*#__PURE__*/function () {
  function mp() {
    _classCallCheck(this, mp);
  }
  return _createClass(mp, null, [{
    key: "decodeText",
    value: function decodeText(t) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
      var e = "";
      for (var _n250 = 0, _i196 = t.length; _n250 < _i196; _n250++) e += String.fromCharCode(t[_n250]);
      try {
        return decodeURIComponent(escape(e));
      } catch (t) {
        return e;
      }
    }
  }, {
    key: "extractUrlBase",
    value: function extractUrlBase(t) {
      var e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.slice(0, e + 1);
    }
  }, {
    key: "resolveURL",
    value: function resolveURL(t, e) {
      return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
    }
  }]);
}();
var fp = exports.InstancedBufferGeometry = /*#__PURE__*/function (_Ts16) {
  function fp() {
    var _this109;
    _classCallCheck(this, fp);
    _this109 = _callSuper(this, fp), _this109.isInstancedBufferGeometry = !0, _this109.type = "InstancedBufferGeometry", _this109.instanceCount = 1 / 0;
    return _this109;
  }
  _inherits(fp, _Ts16);
  return _createClass(fp, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(fp.prototype), "copy", this).call(this, t), this.instanceCount = t.instanceCount, this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var t = _get(_getPrototypeOf(fp.prototype), "toJSON", this).call(this);
      return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t;
    }
  }]);
}(Ts);
var gp = exports.BufferGeometryLoader = /*#__PURE__*/function (_Bd9) {
  function gp(t) {
    _classCallCheck(this, gp);
    return _callSuper(this, gp, [t]);
  }
  _inherits(gp, _Bd9);
  return _createClass(gp, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
        s = new Vd(r.manager);
      s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, function (n) {
        try {
          e(r.parse(JSON.parse(n)));
        } catch (e) {
          i ? i(e) : console.error(e), r.manager.itemError(t);
        }
      }, n, i);
    }
  }, {
    key: "parse",
    value: function parse(t) {
      var e = {},
        n = {};
      function i(t, i) {
        if (void 0 !== e[i]) return e[i];
        var r = t.interleavedBuffers[i],
          s = function (t, e) {
            if (void 0 !== n[e]) return n[e];
            var i = t.arrayBuffers,
              r = i[e],
              s = new Uint32Array(r).buffer;
            return n[e] = s, s;
          }(t, r.buffer),
          a = ri(r.type, s),
          o = new ic(a, r.stride);
        return o.uuid = r.uuid, e[i] = o, o;
      }
      var r = t.isInstancedBufferGeometry ? new fp() : new Ts(),
        s = t.data.index;
      if (void 0 !== s) {
        var _t286 = ri(s.type, s.array);
        r.setIndex(new os(_t286, 1));
      }
      var a = t.data.attributes;
      for (var _e280 in a) {
        var _n251 = a[_e280];
        var _s90 = void 0;
        if (_n251.isInterleavedBufferAttribute) {
          var _e281 = i(t.data, _n251.data);
          _s90 = new sc(_e281, _n251.itemSize, _n251.offset, _n251.normalized);
        } else {
          var _t287 = ri(_n251.type, _n251.array);
          _s90 = new (_n251.isInstancedBufferAttribute ? Hc : os)(_t287, _n251.itemSize, _n251.normalized);
        }
        void 0 !== _n251.name && (_s90.name = _n251.name), void 0 !== _n251.usage && _s90.setUsage(_n251.usage), r.setAttribute(_e280, _s90);
      }
      var o = t.data.morphAttributes;
      if (o) for (var _e282 in o) {
        var _n252 = o[_e282],
          _s91 = [];
        for (var _e283 = 0, _r143 = _n252.length; _e283 < _r143; _e283++) {
          var _r144 = _n252[_e283];
          var _a70 = void 0;
          if (_r144.isInterleavedBufferAttribute) {
            var _e284 = i(t.data, _r144.data);
            _a70 = new sc(_e284, _r144.itemSize, _r144.offset, _r144.normalized);
          } else {
            var _t288 = ri(_r144.type, _r144.array);
            _a70 = new os(_t288, _r144.itemSize, _r144.normalized);
          }
          void 0 !== _r144.name && (_a70.name = _r144.name), _s91.push(_a70);
        }
        r.morphAttributes[_e282] = _s91;
      }
      t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
      var l = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (void 0 !== l) for (var _t289 = 0, _e285 = l.length; _t289 !== _e285; ++_t289) {
        var _e286 = l[_t289];
        r.addGroup(_e286.start, _e286.count, _e286.materialIndex);
      }
      var c = t.data.boundingSphere;
      if (void 0 !== c) {
        var _t290 = new Ii();
        void 0 !== c.center && _t290.fromArray(c.center), r.boundingSphere = new Qi(_t290, c.radius);
      }
      return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r;
    }
  }]);
}(Bd);
var _p = exports.ObjectLoader = /*#__PURE__*/function (_Bd10) {
  function _p(t) {
    _classCallCheck(this, _p);
    return _callSuper(this, _p, [t]);
  }
  _inherits(_p, _Bd10);
  return _createClass(_p, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
        s = "" === this.path ? mp.extractUrlBase(t) : this.path;
      this.resourcePath = this.resourcePath || s;
      var a = new Vd(this.manager);
      a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function (n) {
        var s = null;
        try {
          s = JSON.parse(n);
        } catch (e) {
          return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message);
        }
        var a = s.metadata;
        if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) return void 0 !== i && i(new Error("THREE.ObjectLoader: Can't load " + t)), void console.error("THREE.ObjectLoader: Can't load " + t);
        r.parse(s, e);
      }, n, i);
    }
  }, {
    key: "loadAsync",
    value: function () {
      var _loadAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(t, e) {
        var n, i, r, s, a;
        return _regeneratorRuntime().wrap(function _callee2$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              n = "" === this.path ? mp.extractUrlBase(t) : this.path;
              this.resourcePath = this.resourcePath || n;
              i = new Vd(this.manager);
              i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials);
              _context8.next = 6;
              return i.loadAsync(t, e);
            case 6:
              r = _context8.sent;
              s = JSON.parse(r);
              a = s.metadata;
              if (!(void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase())) {
                _context8.next = 11;
                break;
              }
              throw new Error("THREE.ObjectLoader: Can't load " + t);
            case 11:
              _context8.next = 13;
              return this.parseAsync(s);
            case 13:
              return _context8.abrupt("return", _context8.sent);
            case 14:
            case "end":
              return _context8.stop();
          }
        }, _callee2, this);
      }));
      function loadAsync(_x5, _x6) {
        return _loadAsync.apply(this, arguments);
      }
      return loadAsync;
    }()
  }, {
    key: "parse",
    value: function parse(t, e) {
      var n = this.parseAnimations(t.animations),
        i = this.parseShapes(t.shapes),
        r = this.parseGeometries(t.geometries, i),
        s = this.parseImages(t.images, function () {
          void 0 !== e && e(l);
        }),
        a = this.parseTextures(t.textures, s),
        o = this.parseMaterials(t.materials, a),
        l = this.parseObject(t.object, r, o, a, n),
        c = this.parseSkeletons(t.skeletons, l);
      if (this.bindSkeletons(l, c), void 0 !== e) {
        var _t291 = !1;
        for (var _e287 in s) if (s[_e287].data instanceof HTMLImageElement) {
          _t291 = !0;
          break;
        }
        !1 === _t291 && e(l);
      }
      return l;
    }
  }, {
    key: "parseAsync",
    value: function () {
      var _parseAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(t) {
        var e, n, i, r, s, a, o, l;
        return _regeneratorRuntime().wrap(function _callee3$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              e = this.parseAnimations(t.animations);
              n = this.parseShapes(t.shapes);
              i = this.parseGeometries(t.geometries, n);
              _context9.next = 5;
              return this.parseImagesAsync(t.images);
            case 5:
              r = _context9.sent;
              s = this.parseTextures(t.textures, r);
              a = this.parseMaterials(t.materials, s);
              o = this.parseObject(t.object, i, a, s, e);
              l = this.parseSkeletons(t.skeletons, o);
              return _context9.abrupt("return", (this.bindSkeletons(o, l), o));
            case 11:
            case "end":
              return _context9.stop();
          }
        }, _callee3, this);
      }));
      function parseAsync(_x7) {
        return _parseAsync.apply(this, arguments);
      }
      return parseAsync;
    }()
  }, {
    key: "parseShapes",
    value: function parseShapes(t) {
      var e = {};
      if (void 0 !== t) for (var _n253 = 0, _i197 = t.length; _n253 < _i197; _n253++) {
        var _i198 = new gu().fromJSON(t[_n253]);
        e[_i198.uuid] = _i198;
      }
      return e;
    }
  }, {
    key: "parseSkeletons",
    value: function parseSkeletons(t, e) {
      var n = {},
        i = {};
      if (e.traverse(function (t) {
        t.isBone && (i[t.uuid] = t);
      }), void 0 !== t) for (var _e288 = 0, _r145 = t.length; _e288 < _r145; _e288++) {
        var _r146 = new zc().fromJSON(t[_e288], i);
        n[_r146.uuid] = _r146;
      }
      return n;
    }
  }, {
    key: "parseGeometries",
    value: function parseGeometries(t, e) {
      var n = {};
      if (void 0 !== t) {
        var _i199 = new gp();
        for (var _r147 = 0, _s92 = t.length; _r147 < _s92; _r147++) {
          var _s93 = void 0;
          var _a71 = t[_r147];
          switch (_a71.type) {
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              _s93 = _i199.parse(_a71);
              break;
            default:
              _a71.type in rd ? _s93 = rd[_a71.type].fromJSON(_a71, e) : console.warn("THREE.ObjectLoader: Unsupported geometry type \"".concat(_a71.type, "\""));
          }
          _s93.uuid = _a71.uuid, void 0 !== _a71.name && (_s93.name = _a71.name), void 0 !== _a71.userData && (_s93.userData = _a71.userData), n[_a71.uuid] = _s93;
        }
      }
      return n;
    }
  }, {
    key: "parseMaterials",
    value: function parseMaterials(t, e) {
      var n = {},
        i = {};
      if (void 0 !== t) {
        var _r148 = new pp();
        _r148.setTextures(e);
        for (var _e289 = 0, _s94 = t.length; _e289 < _s94; _e289++) {
          var _s95 = t[_e289];
          void 0 === n[_s95.uuid] && (n[_s95.uuid] = _r148.parse(_s95)), i[_s95.uuid] = n[_s95.uuid];
        }
      }
      return i;
    }
  }, {
    key: "parseAnimations",
    value: function parseAnimations(t) {
      var e = {};
      if (void 0 !== t) for (var _n254 = 0; _n254 < t.length; _n254++) {
        var _i200 = t[_n254],
          _r149 = Ud.parse(_i200);
        e[_r149.uuid] = _r149;
      }
      return e;
    }
  }, {
    key: "parseImages",
    value: function parseImages(t, e) {
      var n = this,
        i = {};
      var r;
      function s(t) {
        if ("string" == typeof t) {
          var _e290 = t;
          return function (t) {
            return n.manager.itemStart(t), r.load(t, function () {
              n.manager.itemEnd(t);
            }, void 0, function () {
              n.manager.itemError(t), n.manager.itemEnd(t);
            });
          }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(_e290) ? _e290 : n.resourcePath + _e290);
        }
        return t.data ? {
          data: ri(t.type, t.data),
          width: t.width,
          height: t.height
        } : null;
      }
      if (void 0 !== t && t.length > 0) {
        var _n255 = new Od(e);
        r = new Wd(_n255), r.setCrossOrigin(this.crossOrigin);
        for (var _e291 = 0, _n256 = t.length; _e291 < _n256; _e291++) {
          var _n257 = t[_e291],
            _r150 = _n257.url;
          if (Array.isArray(_r150)) {
            var _t292 = [];
            for (var _e292 = 0, _n258 = _r150.length; _e292 < _n258; _e292++) {
              var _n259 = s(_r150[_e292]);
              null !== _n259 && (_n259 instanceof HTMLImageElement ? _t292.push(_n259) : _t292.push(new Oc(_n259.data, _n259.width, _n259.height)));
            }
            i[_n257.uuid] = new xi(_t292);
          } else {
            var _t293 = s(_n257.url);
            i[_n257.uuid] = new xi(_t293);
          }
        }
      }
      return i;
    }
  }, {
    key: "parseImagesAsync",
    value: function () {
      var _parseImagesAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(t) {
        var e, n, i, r, _r151, _e293, _i201, _i202, _s96, _t294, _e294, _n260, _n261, _i203, _t295;
        return _regeneratorRuntime().wrap(function _callee5$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _r151 = function _r154() {
                _r151 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(t) {
                  var _n262, _r152;
                  return _regeneratorRuntime().wrap(function _callee4$(_context10) {
                    while (1) switch (_context10.prev = _context10.next) {
                      case 0:
                        if (!("string" == typeof t)) {
                          _context10.next = 5;
                          break;
                        }
                        _n262 = t, _r152 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_n262) ? _n262 : e.resourcePath + _n262;
                        _context10.next = 4;
                        return i.loadAsync(_r152);
                      case 4:
                        return _context10.abrupt("return", _context10.sent);
                      case 5:
                        return _context10.abrupt("return", t.data ? {
                          data: ri(t.type, t.data),
                          width: t.width,
                          height: t.height
                        } : null);
                      case 6:
                      case "end":
                        return _context10.stop();
                    }
                  }, _callee4);
                }));
                return _r151.apply(this, arguments);
              };
              r = function _r153(_x9) {
                return _r151.apply(this, arguments);
              };
              e = this, n = {};
              if (!(void 0 !== t && t.length > 0)) {
                _context11.next = 30;
                break;
              }
              i = new Wd(this.manager), i.setCrossOrigin(this.crossOrigin);
              _e293 = 0, _i201 = t.length;
            case 6:
              if (!(_e293 < _i201)) {
                _context11.next = 30;
                break;
              }
              _i202 = t[_e293], _s96 = _i202.url;
              if (!Array.isArray(_s96)) {
                _context11.next = 23;
                break;
              }
              _t294 = [];
              _e294 = 0, _n260 = _s96.length;
            case 11:
              if (!(_e294 < _n260)) {
                _context11.next = 20;
                break;
              }
              _n261 = _s96[_e294];
              _context11.next = 15;
              return r(_n261);
            case 15:
              _i203 = _context11.sent;
              null !== _i203 && (_i203 instanceof HTMLImageElement ? _t294.push(_i203) : _t294.push(new Oc(_i203.data, _i203.width, _i203.height)));
            case 17:
              _e294++;
              _context11.next = 11;
              break;
            case 20:
              n[_i202.uuid] = new xi(_t294);
              _context11.next = 27;
              break;
            case 23:
              _context11.next = 25;
              return r(_i202.url);
            case 25:
              _t295 = _context11.sent;
              n[_i202.uuid] = new xi(_t295);
            case 27:
              _e293++;
              _context11.next = 6;
              break;
            case 30:
              return _context11.abrupt("return", n);
            case 31:
            case "end":
              return _context11.stop();
          }
        }, _callee5, this);
      }));
      function parseImagesAsync(_x8) {
        return _parseImagesAsync.apply(this, arguments);
      }
      return parseImagesAsync;
    }()
  }, {
    key: "parseTextures",
    value: function parseTextures(t, e) {
      function n(t, e) {
        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]);
      }
      var i = {};
      if (void 0 !== t) for (var r = 0, _s97 = t.length; r < _s97; r++) {
        var _s98 = t[r];
        void 0 === _s98.image && console.warn('THREE.ObjectLoader: No "image" specified for', _s98.uuid), void 0 === e[_s98.image] && console.warn("THREE.ObjectLoader: Undefined image", _s98.image);
        var _a72 = e[_s98.image],
          _o54 = _a72.data;
        var _l33 = void 0;
        Array.isArray(_o54) ? (_l33 = new ra(), 6 === _o54.length && (_l33.needsUpdate = !0)) : (_l33 = _o54 && _o54.data ? new Oc() : new Si(), _o54 && (_l33.needsUpdate = !0)), _l33.source = _a72, _l33.uuid = _s98.uuid, void 0 !== _s98.name && (_l33.name = _s98.name), void 0 !== _s98.mapping && (_l33.mapping = n(_s98.mapping, vp)), void 0 !== _s98.channel && (_l33.channel = _s98.channel), void 0 !== _s98.offset && _l33.offset.fromArray(_s98.offset), void 0 !== _s98.repeat && _l33.repeat.fromArray(_s98.repeat), void 0 !== _s98.center && _l33.center.fromArray(_s98.center), void 0 !== _s98.rotation && (_l33.rotation = _s98.rotation), void 0 !== _s98.wrap && (_l33.wrapS = n(_s98.wrap[0], xp), _l33.wrapT = n(_s98.wrap[1], xp)), void 0 !== _s98.format && (_l33.format = _s98.format), void 0 !== _s98.internalFormat && (_l33.internalFormat = _s98.internalFormat), void 0 !== _s98.type && (_l33.type = _s98.type), void 0 !== _s98.colorSpace && (_l33.colorSpace = _s98.colorSpace), void 0 !== _s98.encoding && (_l33.encoding = _s98.encoding), void 0 !== _s98.minFilter && (_l33.minFilter = n(_s98.minFilter, yp)), void 0 !== _s98.magFilter && (_l33.magFilter = n(_s98.magFilter, yp)), void 0 !== _s98.anisotropy && (_l33.anisotropy = _s98.anisotropy), void 0 !== _s98.flipY && (_l33.flipY = _s98.flipY), void 0 !== _s98.generateMipmaps && (_l33.generateMipmaps = _s98.generateMipmaps), void 0 !== _s98.premultiplyAlpha && (_l33.premultiplyAlpha = _s98.premultiplyAlpha), void 0 !== _s98.unpackAlignment && (_l33.unpackAlignment = _s98.unpackAlignment), void 0 !== _s98.compareFunction && (_l33.compareFunction = _s98.compareFunction), void 0 !== _s98.userData && (_l33.userData = _s98.userData), i[_s98.uuid] = _l33;
      }
      return i;
    }
  }, {
    key: "parseObject",
    value: function parseObject(t, e, n, i, r) {
      var s, a, o;
      function l(t) {
        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t];
      }
      function c(t) {
        if (void 0 !== t) {
          if (Array.isArray(t)) {
            var _e295 = [];
            for (var _i204 = 0, _r155 = t.length; _i204 < _r155; _i204++) {
              var _r156 = t[_i204];
              void 0 === n[_r156] && console.warn("THREE.ObjectLoader: Undefined material", _r156), _e295.push(n[_r156]);
            }
            return _e295;
          }
          return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t];
        }
      }
      function h(t) {
        return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined texture", t), i[t];
      }
      switch (t.type) {
        case "Scene":
          s = new nc(), void 0 !== t.background && (Number.isInteger(t.background) ? s.background = new Zr(t.background) : s.background = h(t.background)), void 0 !== t.environment && (s.environment = h(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new ec(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new tc(t.fog.color, t.fog.density)), "" !== t.fog.name && (s.fog.name = t.fog.name)), void 0 !== t.backgroundBlurriness && (s.backgroundBlurriness = t.backgroundBlurriness), void 0 !== t.backgroundIntensity && (s.backgroundIntensity = t.backgroundIntensity);
          break;
        case "PerspectiveCamera":
          s = new ea(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
          break;
        case "OrthographicCamera":
          s = new wa(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
          break;
        case "AmbientLight":
          s = new cp(t.color, t.intensity);
          break;
        case "DirectionalLight":
          s = new lp(t.color, t.intensity);
          break;
        case "PointLight":
          s = new ap(t.color, t.intensity, t.distance, t.decay);
          break;
        case "RectAreaLight":
          s = new hp(t.color, t.intensity, t.width, t.height);
          break;
        case "SpotLight":
          s = new ep(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
          break;
        case "HemisphereLight":
          s = new Zd(t.color, t.groundColor, t.intensity);
          break;
        case "LightProbe":
          s = new dp().fromJSON(t);
          break;
        case "SkinnedMesh":
          a = l(t.geometry), o = c(t.material), s = new Nc(a, o), void 0 !== t.bindMode && (s.bindMode = t.bindMode), void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (s.skeleton = t.skeleton);
          break;
        case "Mesh":
          a = l(t.geometry), o = c(t.material), s = new Gs(a, o);
          break;
        case "InstancedMesh":
          a = l(t.geometry), o = c(t.material);
          var _e296 = t.count,
            _n263 = t.instanceMatrix,
            _i205 = t.instanceColor;
          s = new Yc(a, o, _e296), s.instanceMatrix = new Hc(new Float32Array(_n263.array), 16), void 0 !== _i205 && (s.instanceColor = new Hc(new Float32Array(_i205.array), _i205.itemSize));
          break;
        case "BatchedMesh":
          a = l(t.geometry), o = c(t.material), s = new uh(t.maxGeometryCount, t.maxVertexCount, t.maxIndexCount, o), s.geometry = a, s.perObjectFrustumCulled = t.perObjectFrustumCulled, s.sortObjects = t.sortObjects, s._drawRanges = t.drawRanges, s._reservedRanges = t.reservedRanges, s._visibility = t.visibility, s._active = t.active, s._bounds = t.bounds.map(function (t) {
            var e = new Di();
            e.min.fromArray(t.boxMin), e.max.fromArray(t.boxMax);
            var n = new Qi();
            return n.radius = t.sphereRadius, n.center.fromArray(t.sphereCenter), {
              boxInitialized: t.boxInitialized,
              box: e,
              sphereInitialized: t.sphereInitialized,
              sphere: n
            };
          }), s._maxGeometryCount = t.maxGeometryCount, s._maxVertexCount = t.maxVertexCount, s._maxIndexCount = t.maxIndexCount, s._geometryInitialized = t.geometryInitialized, s._geometryCount = t.geometryCount, s._matricesTexture = h(t.matricesTexture.uuid);
          break;
        case "LOD":
          s = new Ec();
          break;
        case "Line":
          s = new vh(l(t.geometry), c(t.material));
          break;
        case "LineLoop":
          s = new Sh(l(t.geometry), c(t.material));
          break;
        case "LineSegments":
          s = new Mh(l(t.geometry), c(t.material));
          break;
        case "PointCloud":
        case "Points":
          s = new Rh(l(t.geometry), c(t.material));
          break;
        case "Sprite":
          s = new yc(c(t.material));
          break;
        case "Group":
          s = new Xl();
          break;
        case "Bone":
          s = new Dc();
          break;
        default:
          s = new Ur();
      }
      if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (s.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.up && s.up.fromArray(t.up), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (s.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (s.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.layers && (s.layers.mask = t.layers), void 0 !== t.children) {
        var _a73 = t.children;
        for (var _t296 = 0; _t296 < _a73.length; _t296++) s.add(this.parseObject(_a73[_t296], e, n, i, r));
      }
      if (void 0 !== t.animations) {
        var _e297 = t.animations;
        for (var _t297 = 0; _t297 < _e297.length; _t297++) {
          var _n264 = _e297[_t297];
          s.animations.push(r[_n264]);
        }
      }
      if ("LOD" === t.type) {
        void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);
        var _e298 = t.levels;
        for (var _t298 = 0; _t298 < _e298.length; _t298++) {
          var _n265 = _e298[_t298],
            _i206 = s.getObjectByProperty("uuid", _n265.object);
          void 0 !== _i206 && s.addLevel(_i206, _n265.distance, _n265.hysteresis);
        }
      }
      return s;
    }
  }, {
    key: "bindSkeletons",
    value: function bindSkeletons(t, e) {
      0 !== Object.keys(e).length && t.traverse(function (t) {
        if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
          var _n266 = e[t.skeleton];
          void 0 === _n266 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(_n266, t.bindMatrix);
        }
      });
    }
  }]);
}(Bd);
var vp = {
    UVMapping: at,
    CubeReflectionMapping: ot,
    CubeRefractionMapping: lt,
    EquirectangularReflectionMapping: ct,
    EquirectangularRefractionMapping: ht,
    CubeUVReflectionMapping: ut
  },
  xp = {
    RepeatWrapping: dt,
    ClampToEdgeWrapping: pt,
    MirroredRepeatWrapping: mt
  },
  yp = {
    NearestFilter: ft,
    NearestMipmapNearestFilter: gt,
    NearestMipmapLinearFilter: vt,
    LinearFilter: yt,
    LinearMipmapNearestFilter: Mt,
    LinearMipmapLinearFilter: bt
  };
var Mp = exports.ImageBitmapLoader = /*#__PURE__*/function (_Bd11) {
  function Mp(t) {
    var _this110;
    _classCallCheck(this, Mp);
    _this110 = _callSuper(this, Mp, [t]), _this110.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), _this110.options = {
      premultiplyAlpha: "none"
    };
    return _this110;
  }
  _inherits(Mp, _Bd11);
  return _createClass(Mp, [{
    key: "setOptions",
    value: function setOptions(t) {
      return this.options = t, this;
    }
  }, {
    key: "load",
    value: function load(t, e, n, i) {
      void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      var r = this,
        s = Dd.get(t);
      if (void 0 !== s) return r.manager.itemStart(t), s.then ? void s.then(function (n) {
        e && e(n), r.manager.itemEnd(t);
      }).catch(function (t) {
        i && i(t);
      }) : (setTimeout(function () {
        e && e(s), r.manager.itemEnd(t);
      }, 0), s);
      var a = {};
      a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader;
      var o = fetch(t, a).then(function (t) {
        return t.blob();
      }).then(function (t) {
        return createImageBitmap(t, Object.assign(r.options, {
          colorSpaceConversion: "none"
        }));
      }).then(function (n) {
        return Dd.add(t, n), e && e(n), r.manager.itemEnd(t), n;
      }).catch(function (e) {
        i && i(e), Dd.remove(t), r.manager.itemError(t), r.manager.itemEnd(t);
      });
      Dd.add(t, o), r.manager.itemStart(t);
    }
  }]);
}(Bd);
var Sp;
var bp = exports.AudioContext = /*#__PURE__*/function () {
  function bp() {
    _classCallCheck(this, bp);
  }
  return _createClass(bp, null, [{
    key: "getContext",
    value: function getContext() {
      return void 0 === Sp && (Sp = new (window.AudioContext || window.webkitAudioContext)()), Sp;
    }
  }, {
    key: "setContext",
    value: function setContext(t) {
      Sp = t;
    }
  }]);
}();
var Ep = exports.AudioLoader = /*#__PURE__*/function (_Bd12) {
  function Ep(t) {
    _classCallCheck(this, Ep);
    return _callSuper(this, Ep, [t]);
  }
  _inherits(Ep, _Bd12);
  return _createClass(Ep, [{
    key: "load",
    value: function load(t, e, n, i) {
      var r = this,
        s = new Vd(this.manager);
      function a(e) {
        i ? i(e) : console.error(e), r.manager.itemError(t);
      }
      s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, function (t) {
        try {
          var _n267 = t.slice(0);
          bp.getContext().decodeAudioData(_n267, function (t) {
            e(t);
          }).catch(a);
        } catch (t) {
          a(t);
        }
      }, n, i);
    }
  }]);
}(Bd);
var Tp = new lr(),
  wp = new lr(),
  Ap = new lr();
var Rp = exports.StereoCamera = /*#__PURE__*/function () {
  function Rp() {
    _classCallCheck(this, Rp);
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ea(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ea(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  return _createClass(Rp, [{
    key: "update",
    value: function update(t) {
      var e = this._cache;
      if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
        e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep, Ap.copy(t.projectionMatrix);
        var _n268 = e.eyeSep / 2,
          _i207 = _n268 * e.near / e.focus,
          r = e.near * Math.tan(kn * e.fov * .5) / e.zoom;
        var _s99, _a74;
        wp.elements[12] = -_n268, Tp.elements[12] = _n268, _s99 = -r * e.aspect + _i207, _a74 = r * e.aspect + _i207, Ap.elements[0] = 2 * e.near / (_a74 - _s99), Ap.elements[8] = (_a74 + _s99) / (_a74 - _s99), this.cameraL.projectionMatrix.copy(Ap), _s99 = -r * e.aspect - _i207, _a74 = r * e.aspect - _i207, Ap.elements[0] = 2 * e.near / (_a74 - _s99), Ap.elements[8] = (_a74 + _s99) / (_a74 - _s99), this.cameraR.projectionMatrix.copy(Ap);
      }
      this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(wp), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Tp);
    }
  }]);
}();
var Cp = exports.Clock = /*#__PURE__*/function () {
  function Cp() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    _classCallCheck(this, Cp);
    this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  return _createClass(Cp, [{
    key: "start",
    value: function start() {
      this.startTime = Pp(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.getElapsedTime(), this.running = !1, this.autoStart = !1;
    }
  }, {
    key: "getElapsedTime",
    value: function getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      var t = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        var _e299 = Pp();
        t = (_e299 - this.oldTime) / 1e3, this.oldTime = _e299, this.elapsedTime += t;
      }
      return t;
    }
  }]);
}();
function Pp() {
  return ("undefined" == typeof performance ? Date : performance).now();
}
var Lp = new Ii(),
  Ip = new Li(),
  Up = new Ii(),
  Np = new Ii();
var Dp = exports.AudioListener = /*#__PURE__*/function (_Ur12) {
  function Dp() {
    var _this111;
    _classCallCheck(this, Dp);
    _this111 = _callSuper(this, Dp), _this111.type = "AudioListener", _this111.context = bp.getContext(), _this111.gain = _this111.context.createGain(), _this111.gain.connect(_this111.context.destination), _this111.filter = null, _this111.timeDelta = 0, _this111._clock = new Cp();
    return _this111;
  }
  _inherits(Dp, _Ur12);
  return _createClass(Dp, [{
    key: "getInput",
    value: function getInput() {
      return this.gain;
    }
  }, {
    key: "removeFilter",
    value: function removeFilter() {
      return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    }
  }, {
    key: "getFilter",
    value: function getFilter() {
      return this.filter;
    }
  }, {
    key: "setFilter",
    value: function setFilter(t) {
      return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    }
  }, {
    key: "getMasterVolume",
    value: function getMasterVolume() {
      return this.gain.gain.value;
    }
  }, {
    key: "setMasterVolume",
    value: function setMasterVolume(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      _get(_getPrototypeOf(Dp.prototype), "updateMatrixWorld", this).call(this, t);
      var e = this.context.listener,
        n = this.up;
      if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Lp, Ip, Up), Np.set(0, 0, -1).applyQuaternion(Ip), e.positionX) {
        var _t299 = this.context.currentTime + this.timeDelta;
        e.positionX.linearRampToValueAtTime(Lp.x, _t299), e.positionY.linearRampToValueAtTime(Lp.y, _t299), e.positionZ.linearRampToValueAtTime(Lp.z, _t299), e.forwardX.linearRampToValueAtTime(Np.x, _t299), e.forwardY.linearRampToValueAtTime(Np.y, _t299), e.forwardZ.linearRampToValueAtTime(Np.z, _t299), e.upX.linearRampToValueAtTime(n.x, _t299), e.upY.linearRampToValueAtTime(n.y, _t299), e.upZ.linearRampToValueAtTime(n.z, _t299);
      } else e.setPosition(Lp.x, Lp.y, Lp.z), e.setOrientation(Np.x, Np.y, Np.z, n.x, n.y, n.z);
    }
  }]);
}(Ur);
var Op = exports.Audio = /*#__PURE__*/function (_Ur13) {
  function Op(t) {
    var _this112;
    _classCallCheck(this, Op);
    _this112 = _callSuper(this, Op), _this112.type = "Audio", _this112.listener = t, _this112.context = t.context, _this112.gain = _this112.context.createGain(), _this112.gain.connect(t.getInput()), _this112.autoplay = !1, _this112.buffer = null, _this112.detune = 0, _this112.loop = !1, _this112.loopStart = 0, _this112.loopEnd = 0, _this112.offset = 0, _this112.duration = void 0, _this112.playbackRate = 1, _this112.isPlaying = !1, _this112.hasPlaybackControl = !0, _this112.source = null, _this112.sourceType = "empty", _this112._startedAt = 0, _this112._progress = 0, _this112._connected = !1, _this112.filters = [];
    return _this112;
  }
  _inherits(Op, _Ur13);
  return _createClass(Op, [{
    key: "getOutput",
    value: function getOutput() {
      return this.gain;
    }
  }, {
    key: "setNodeSource",
    value: function setNodeSource(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
    }
  }, {
    key: "setMediaElementSource",
    value: function setMediaElementSource(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
    }
  }, {
    key: "setMediaStreamSource",
    value: function setMediaStreamSource(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
  }, {
    key: "play",
    value: function play() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
      if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
      this._startedAt = this.context.currentTime + t;
      var e = this.context.createBufferSource();
      return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
  }, {
    key: "pause",
    value: function pause() {
      if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!1 !== this.hasPlaybackControl) return this._progress = 0, null !== this.source && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (var _t300 = 1, _e300 = this.filters.length; _t300 < _e300; _t300++) this.filters[_t300 - 1].connect(this.filters[_t300]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else this.source.connect(this.getOutput());
      return this._connected = !0, this;
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (!1 !== this._connected) {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (var _t301 = 1, _e301 = this.filters.length; _t301 < _e301; _t301++) this.filters[_t301 - 1].disconnect(this.filters[_t301]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this._connected = !1, this;
      }
    }
  }, {
    key: "getFilters",
    value: function getFilters() {
      return this.filters;
    }
  }, {
    key: "setFilters",
    value: function setFilters(t) {
      return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this;
    }
  }, {
    key: "setDetune",
    value: function setDetune(t) {
      return this.detune = t, !0 === this.isPlaying && void 0 !== this.source.detune && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
    }
  }, {
    key: "getDetune",
    value: function getDetune() {
      return this.detune;
    }
  }, {
    key: "getFilter",
    value: function getFilter() {
      return this.getFilters()[0];
    }
  }, {
    key: "setFilter",
    value: function setFilter(t) {
      return this.setFilters(t ? [t] : []);
    }
  }, {
    key: "setPlaybackRate",
    value: function setPlaybackRate(t) {
      if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
  }, {
    key: "getPlaybackRate",
    value: function getPlaybackRate() {
      return this.playbackRate;
    }
  }, {
    key: "onEnded",
    value: function onEnded() {
      this.isPlaying = !1;
    }
  }, {
    key: "getLoop",
    value: function getLoop() {
      return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    }
  }, {
    key: "setLoop",
    value: function setLoop(t) {
      if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
  }, {
    key: "setLoopStart",
    value: function setLoopStart(t) {
      return this.loopStart = t, this;
    }
  }, {
    key: "setLoopEnd",
    value: function setLoopEnd(t) {
      return this.loopEnd = t, this;
    }
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this.gain.gain.value;
    }
  }, {
    key: "setVolume",
    value: function setVolume(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this;
    }
  }]);
}(Ur);
var Fp = new Ii(),
  Bp = new Li(),
  zp = new Ii(),
  Hp = new Ii();
var Vp = exports.PositionalAudio = /*#__PURE__*/function (_Op) {
  function Vp(t) {
    var _this113;
    _classCallCheck(this, Vp);
    _this113 = _callSuper(this, Vp, [t]), _this113.panner = _this113.context.createPanner(), _this113.panner.panningModel = "HRTF", _this113.panner.connect(_this113.gain);
    return _this113;
  }
  _inherits(Vp, _Op);
  return _createClass(Vp, [{
    key: "connect",
    value: function connect() {
      _get(_getPrototypeOf(Vp.prototype), "connect", this).call(this), this.panner.connect(this.gain);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      _get(_getPrototypeOf(Vp.prototype), "disconnect", this).call(this), this.panner.disconnect(this.gain);
    }
  }, {
    key: "getOutput",
    value: function getOutput() {
      return this.panner;
    }
  }, {
    key: "getRefDistance",
    value: function getRefDistance() {
      return this.panner.refDistance;
    }
  }, {
    key: "setRefDistance",
    value: function setRefDistance(t) {
      return this.panner.refDistance = t, this;
    }
  }, {
    key: "getRolloffFactor",
    value: function getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
  }, {
    key: "setRolloffFactor",
    value: function setRolloffFactor(t) {
      return this.panner.rolloffFactor = t, this;
    }
  }, {
    key: "getDistanceModel",
    value: function getDistanceModel() {
      return this.panner.distanceModel;
    }
  }, {
    key: "setDistanceModel",
    value: function setDistanceModel(t) {
      return this.panner.distanceModel = t, this;
    }
  }, {
    key: "getMaxDistance",
    value: function getMaxDistance() {
      return this.panner.maxDistance;
    }
  }, {
    key: "setMaxDistance",
    value: function setMaxDistance(t) {
      return this.panner.maxDistance = t, this;
    }
  }, {
    key: "setDirectionalCone",
    value: function setDirectionalCone(t, e, n) {
      return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      if (_get(_getPrototypeOf(Vp.prototype), "updateMatrixWorld", this).call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
      this.matrixWorld.decompose(Fp, Bp, zp), Hp.set(0, 0, 1).applyQuaternion(Bp);
      var e = this.panner;
      if (e.positionX) {
        var _t302 = this.context.currentTime + this.listener.timeDelta;
        e.positionX.linearRampToValueAtTime(Fp.x, _t302), e.positionY.linearRampToValueAtTime(Fp.y, _t302), e.positionZ.linearRampToValueAtTime(Fp.z, _t302), e.orientationX.linearRampToValueAtTime(Hp.x, _t302), e.orientationY.linearRampToValueAtTime(Hp.y, _t302), e.orientationZ.linearRampToValueAtTime(Hp.z, _t302);
      } else e.setPosition(Fp.x, Fp.y, Fp.z), e.setOrientation(Hp.x, Hp.y, Hp.z);
    }
  }]);
}(Op);
var kp = exports.AudioAnalyser = /*#__PURE__*/function () {
  function kp(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2048;
    _classCallCheck(this, kp);
    this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
  }
  return _createClass(kp, [{
    key: "getFrequencyData",
    value: function getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }
  }, {
    key: "getAverageFrequency",
    value: function getAverageFrequency() {
      var t = 0;
      var e = this.getFrequencyData();
      for (var _n269 = 0; _n269 < e.length; _n269++) t += e[_n269];
      return t / e.length;
    }
  }]);
}();
var Gp = exports.PropertyMixer = /*#__PURE__*/function () {
  function Gp(t, e, n) {
    _classCallCheck(this, Gp);
    var i, r, s;
    switch (this.binding = t, this.valueSize = n, e) {
      case "quaternion":
        i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
        break;
      default:
        i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  return _createClass(Gp, [{
    key: "accumulate",
    value: function accumulate(t, e) {
      var n = this.buffer,
        i = this.valueSize,
        r = t * i + i;
      var s = this.cumulativeWeight;
      if (0 === s) {
        for (var _t303 = 0; _t303 !== i; ++_t303) n[r + _t303] = n[_t303];
        s = e;
      } else {
        s += e;
        var _t304 = e / s;
        this._mixBufferRegion(n, r, 0, _t304, i);
      }
      this.cumulativeWeight = s;
    }
  }, {
    key: "accumulateAdditive",
    value: function accumulateAdditive(t) {
      var e = this.buffer,
        n = this.valueSize,
        i = n * this._addIndex;
      0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t;
    }
  }, {
    key: "apply",
    value: function apply(t) {
      var e = this.valueSize,
        n = this.buffer,
        i = t * e + e,
        r = this.cumulativeWeight,
        s = this.cumulativeWeightAdditive,
        a = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
        var _t305 = e * this._origIndex;
        this._mixBufferRegion(n, i, _t305, 1 - r, e);
      }
      s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
      for (var _t306 = e, _r157 = e + e; _t306 !== _r157; ++_t306) if (n[_t306] !== n[_t306 + e]) {
        a.setValue(n, i);
        break;
      }
    }
  }, {
    key: "saveOriginalState",
    value: function saveOriginalState() {
      var t = this.binding,
        e = this.buffer,
        n = this.valueSize,
        i = n * this._origIndex;
      t.getValue(e, i);
      for (var _t307 = n, r = i; _t307 !== r; ++_t307) e[_t307] = e[i + _t307 % n];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
  }, {
    key: "restoreOriginalState",
    value: function restoreOriginalState() {
      var t = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t);
    }
  }, {
    key: "_setAdditiveIdentityNumeric",
    value: function _setAdditiveIdentityNumeric() {
      var t = this._addIndex * this.valueSize,
        e = t + this.valueSize;
      for (var _n270 = t; _n270 < e; _n270++) this.buffer[_n270] = 0;
    }
  }, {
    key: "_setAdditiveIdentityQuaternion",
    value: function _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
  }, {
    key: "_setAdditiveIdentityOther",
    value: function _setAdditiveIdentityOther() {
      var t = this._origIndex * this.valueSize,
        e = this._addIndex * this.valueSize;
      for (var _n271 = 0; _n271 < this.valueSize; _n271++) this.buffer[e + _n271] = this.buffer[t + _n271];
    }
  }, {
    key: "_select",
    value: function _select(t, e, n, i, r) {
      if (i >= .5) for (var _i208 = 0; _i208 !== r; ++_i208) t[e + _i208] = t[n + _i208];
    }
  }, {
    key: "_slerp",
    value: function _slerp(t, e, n, i) {
      Li.slerpFlat(t, e, t, e, t, n, i);
    }
  }, {
    key: "_slerpAdditive",
    value: function _slerpAdditive(t, e, n, i, r) {
      var s = this._workIndex * r;
      Li.multiplyQuaternionsFlat(t, s, t, e, t, n), Li.slerpFlat(t, e, t, e, t, s, i);
    }
  }, {
    key: "_lerp",
    value: function _lerp(t, e, n, i, r) {
      var s = 1 - i;
      for (var _a75 = 0; _a75 !== r; ++_a75) {
        var _r158 = e + _a75;
        t[_r158] = t[_r158] * s + t[n + _a75] * i;
      }
    }
  }, {
    key: "_lerpAdditive",
    value: function _lerpAdditive(t, e, n, i, r) {
      for (var _s100 = 0; _s100 !== r; ++_s100) {
        var _r159 = e + _s100;
        t[_r159] = t[_r159] + t[n + _s100] * i;
      }
    }
  }]);
}();
var Wp = "\\[\\]\\.:\\/",
  Xp = new RegExp("[" + Wp + "]", "g"),
  jp = "[^" + Wp + "]",
  qp = "[^" + Wp.replace("\\.", "") + "]",
  Yp = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", jp) + /(WCOD+)?/.source.replace("WCOD", qp) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", jp) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", jp) + "$"),
  Zp = ["material", "materials", "bones", "map"];
var Jp = exports.PropertyBinding = /*#__PURE__*/function () {
  function Jp(t, e, n) {
    _classCallCheck(this, Jp);
    this.path = e, this.parsedPath = n || Jp.parseTrackName(e), this.node = Jp.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  return _createClass(Jp, [{
    key: "_getValue_unavailable",
    value: function _getValue_unavailable() {}
  }, {
    key: "_setValue_unavailable",
    value: function _setValue_unavailable() {}
  }, {
    key: "_getValue_direct",
    value: function _getValue_direct(t, e) {
      t[e] = this.targetObject[this.propertyName];
    }
  }, {
    key: "_getValue_array",
    value: function _getValue_array(t, e) {
      var n = this.resolvedProperty;
      for (var _i209 = 0, r = n.length; _i209 !== r; ++_i209) t[e++] = n[_i209];
    }
  }, {
    key: "_getValue_arrayElement",
    value: function _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }
  }, {
    key: "_getValue_toArray",
    value: function _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e);
    }
  }, {
    key: "_setValue_direct",
    value: function _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e];
    }
  }, {
    key: "_setValue_direct_setNeedsUpdate",
    value: function _setValue_direct_setNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
    }
  }, {
    key: "_setValue_direct_setMatrixWorldNeedsUpdate",
    value: function _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "_setValue_array",
    value: function _setValue_array(t, e) {
      var n = this.resolvedProperty;
      for (var _i210 = 0, r = n.length; _i210 !== r; ++_i210) n[_i210] = t[e++];
    }
  }, {
    key: "_setValue_array_setNeedsUpdate",
    value: function _setValue_array_setNeedsUpdate(t, e) {
      var n = this.resolvedProperty;
      for (var _i211 = 0, r = n.length; _i211 !== r; ++_i211) n[_i211] = t[e++];
      this.targetObject.needsUpdate = !0;
    }
  }, {
    key: "_setValue_array_setMatrixWorldNeedsUpdate",
    value: function _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      var n = this.resolvedProperty;
      for (var _i212 = 0, r = n.length; _i212 !== r; ++_i212) n[_i212] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "_setValue_arrayElement",
    value: function _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }
  }, {
    key: "_setValue_arrayElement_setNeedsUpdate",
    value: function _setValue_arrayElement_setNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
    }
  }, {
    key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
    value: function _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "_setValue_fromArray",
    value: function _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e);
    }
  }, {
    key: "_setValue_fromArray_setNeedsUpdate",
    value: function _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
    }
  }, {
    key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
    value: function _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
    }
  }, {
    key: "_getValue_unbound",
    value: function _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e);
    }
  }, {
    key: "_setValue_unbound",
    value: function _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e);
    }
  }, {
    key: "bind",
    value: function bind() {
      var t = this.node;
      var e = this.parsedPath,
        n = e.objectName,
        i = e.propertyName;
      var r = e.propertyIndex;
      if (t || (t = Jp.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      if (n) {
        var _i213 = e.objectIndex;
        switch (n) {
          case "materials":
            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            t = t.skeleton.bones;
            for (var _e302 = 0; _e302 < t.length; _e302++) if (t[_e302].name === _i213) {
              _i213 = _e302;
              break;
            }
            break;
          case "map":
            if ("map" in t) {
              t = t.map;
              break;
            }
            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            t = t.material.map;
            break;
          default:
            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            t = t[n];
        }
        if (void 0 !== _i213) {
          if (void 0 === t[_i213]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          t = t[_i213];
        }
      }
      var s = t[i];
      if (void 0 === s) {
        var _n272 = e.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + _n272 + "." + i + " but it wasn't found.", t);
      }
      var a = this.Versioning.None;
      this.targetObject = t, void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
      var o = this.BindingType.Direct;
      if (void 0 !== r) {
        if ("morphTargetInfluences" === i) {
          if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
        }
        o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r;
      } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
      this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a];
    }
  }, {
    key: "unbind",
    value: function unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }], [{
    key: "create",
    value: function create(t, e, n) {
      return t && t.isAnimationObjectGroup ? new Jp.Composite(t, e, n) : new Jp(t, e, n);
    }
  }, {
    key: "sanitizeNodeName",
    value: function sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(Xp, "");
    }
  }, {
    key: "parseTrackName",
    value: function parseTrackName(t) {
      var e = Yp.exec(t);
      if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      var n = {
          nodeName: e[2],
          objectName: e[3],
          objectIndex: e[4],
          propertyName: e[5],
          propertyIndex: e[6]
        },
        i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (void 0 !== i && -1 !== i) {
        var _t308 = n.nodeName.substring(i + 1);
        -1 !== Zp.indexOf(_t308) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = _t308);
      }
      if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
      return n;
    }
  }, {
    key: "findNode",
    value: function findNode(t, e) {
      if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
      if (t.skeleton) {
        var _n273 = t.skeleton.getBoneByName(e);
        if (void 0 !== _n273) return _n273;
      }
      if (t.children) {
        var _n274 = function _n274(t) {
            for (var _i215 = 0; _i215 < t.length; _i215++) {
              var r = t[_i215];
              if (r.name === e || r.uuid === e) return r;
              var _s101 = _n274(r.children);
              if (_s101) return _s101;
            }
            return null;
          },
          _i214 = _n274(t.children);
        if (_i214) return _i214;
      }
      return null;
    }
  }]);
}();
Jp.Composite = /*#__PURE__*/function () {
  function _class(t, e, n) {
    _classCallCheck(this, _class);
    var i = n || Jp.parseTrackName(e);
    this._targetGroup = t, this._bindings = t.subscribe_(e, i);
  }
  return _createClass(_class, [{
    key: "getValue",
    value: function getValue(t, e) {
      this.bind();
      var n = this._targetGroup.nCachedObjects_,
        i = this._bindings[n];
      void 0 !== i && i.getValue(t, e);
    }
  }, {
    key: "setValue",
    value: function setValue(t, e) {
      var n = this._bindings;
      for (var _i216 = this._targetGroup.nCachedObjects_, r = n.length; _i216 !== r; ++_i216) n[_i216].setValue(t, e);
    }
  }, {
    key: "bind",
    value: function bind() {
      var t = this._bindings;
      for (var _e303 = this._targetGroup.nCachedObjects_, _n275 = t.length; _e303 !== _n275; ++_e303) t[_e303].bind();
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var t = this._bindings;
      for (var _e304 = this._targetGroup.nCachedObjects_, _n276 = t.length; _e304 !== _n276; ++_e304) t[_e304].unbind();
    }
  }]);
}(), Jp.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
}, Jp.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
}, Jp.prototype.GetterByBindingType = [Jp.prototype._getValue_direct, Jp.prototype._getValue_array, Jp.prototype._getValue_arrayElement, Jp.prototype._getValue_toArray], Jp.prototype.SetterByBindingTypeAndVersioning = [[Jp.prototype._setValue_direct, Jp.prototype._setValue_direct_setNeedsUpdate, Jp.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Jp.prototype._setValue_array, Jp.prototype._setValue_array_setNeedsUpdate, Jp.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Jp.prototype._setValue_arrayElement, Jp.prototype._setValue_arrayElement_setNeedsUpdate, Jp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Jp.prototype._setValue_fromArray, Jp.prototype._setValue_fromArray_setNeedsUpdate, Jp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
var Kp = exports.AnimationObjectGroup = /*#__PURE__*/function () {
  function Kp() {
    _classCallCheck(this, Kp);
    this.isAnimationObjectGroup = !0, this.uuid = Wn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    var t = {};
    this._indicesByUUID = t;
    for (var _e305 = 0, _n277 = arguments.length; _e305 !== _n277; ++_e305) t[arguments[_e305].uuid] = _e305;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    var e = this;
    this.stats = {
      objects: {
        get total() {
          return e._objects.length;
        },
        get inUse() {
          return this.total - e.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return e._bindings.length;
      }
    };
  }
  return _createClass(Kp, [{
    key: "add",
    value: function add() {
      var t = this._objects,
        e = this._indicesByUUID,
        n = this._paths,
        i = this._parsedPaths,
        r = this._bindings,
        s = r.length;
      var a,
        o = t.length,
        l = this.nCachedObjects_;
      for (var _c25 = 0, _h13 = arguments.length; _c25 !== _h13; ++_c25) {
        var _h14 = arguments[_c25],
          _u14 = _h14.uuid;
        var _d18 = e[_u14];
        if (void 0 === _d18) {
          _d18 = o++, e[_u14] = _d18, t.push(_h14);
          for (var _t309 = 0, _e306 = s; _t309 !== _e306; ++_t309) r[_t309].push(new Jp(_h14, n[_t309], i[_t309]));
        } else if (_d18 < l) {
          a = t[_d18];
          var _o55 = --l,
            _c26 = t[_o55];
          e[_c26.uuid] = _d18, t[_d18] = _c26, e[_u14] = _o55, t[_o55] = _h14;
          for (var _t310 = 0, _e307 = s; _t310 !== _e307; ++_t310) {
            var _e308 = r[_t310],
              _s102 = _e308[_o55];
            var _a76 = _e308[_d18];
            _e308[_d18] = _s102, void 0 === _a76 && (_a76 = new Jp(_h14, n[_t310], i[_t310])), _e308[_o55] = _a76;
          }
        } else t[_d18] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
      this.nCachedObjects_ = l;
    }
  }, {
    key: "remove",
    value: function remove() {
      var t = this._objects,
        e = this._indicesByUUID,
        n = this._bindings,
        i = n.length;
      var r = this.nCachedObjects_;
      for (var _s103 = 0, _a77 = arguments.length; _s103 !== _a77; ++_s103) {
        var _a78 = arguments[_s103],
          _o56 = _a78.uuid,
          _l34 = e[_o56];
        if (void 0 !== _l34 && _l34 >= r) {
          var _s104 = r++,
            _c27 = t[_s104];
          e[_c27.uuid] = _l34, t[_l34] = _c27, e[_o56] = _s104, t[_s104] = _a78;
          for (var _t311 = 0, _e309 = i; _t311 !== _e309; ++_t311) {
            var _e310 = n[_t311],
              _i217 = _e310[_s104],
              _r160 = _e310[_l34];
            _e310[_l34] = _i217, _e310[_s104] = _r160;
          }
        }
      }
      this.nCachedObjects_ = r;
    }
  }, {
    key: "uncache",
    value: function uncache() {
      var t = this._objects,
        e = this._indicesByUUID,
        n = this._bindings,
        i = n.length;
      var r = this.nCachedObjects_,
        s = t.length;
      for (var _a79 = 0, _o57 = arguments.length; _a79 !== _o57; ++_a79) {
        var _o58 = arguments[_a79].uuid,
          _l35 = e[_o58];
        if (void 0 !== _l35) if (delete e[_o58], _l35 < r) {
          var _a80 = --r,
            _o59 = t[_a80],
            _c28 = --s,
            _h15 = t[_c28];
          e[_o59.uuid] = _l35, t[_l35] = _o59, e[_h15.uuid] = _a80, t[_a80] = _h15, t.pop();
          for (var _t312 = 0, _e311 = i; _t312 !== _e311; ++_t312) {
            var _e312 = n[_t312],
              _i218 = _e312[_a80],
              _r161 = _e312[_c28];
            _e312[_l35] = _i218, _e312[_a80] = _r161, _e312.pop();
          }
        } else {
          var _r162 = --s,
            _a81 = t[_r162];
          _r162 > 0 && (e[_a81.uuid] = _l35), t[_l35] = _a81, t.pop();
          for (var _t313 = 0, _e313 = i; _t313 !== _e313; ++_t313) {
            var _e314 = n[_t313];
            _e314[_l35] = _e314[_r162], _e314.pop();
          }
        }
      }
      this.nCachedObjects_ = r;
    }
  }, {
    key: "subscribe_",
    value: function subscribe_(t, e) {
      var n = this._bindingsIndicesByPath;
      var i = n[t];
      var r = this._bindings;
      if (void 0 !== i) return r[i];
      var s = this._paths,
        a = this._parsedPaths,
        o = this._objects,
        l = o.length,
        c = this.nCachedObjects_,
        h = new Array(l);
      i = r.length, n[t] = i, s.push(t), a.push(e), r.push(h);
      for (var _n278 = c, _i219 = o.length; _n278 !== _i219; ++_n278) {
        var _i220 = o[_n278];
        h[_n278] = new Jp(_i220, t, e);
      }
      return h;
    }
  }, {
    key: "unsubscribe_",
    value: function unsubscribe_(t) {
      var e = this._bindingsIndicesByPath,
        n = e[t];
      if (void 0 !== n) {
        var _i221 = this._paths,
          r = this._parsedPaths,
          _s105 = this._bindings,
          _a82 = _s105.length - 1,
          _o60 = _s105[_a82];
        e[t[_a82]] = n, _s105[n] = _o60, _s105.pop(), r[n] = r[_a82], r.pop(), _i221[n] = _i221[_a82], _i221.pop();
      }
    }
  }]);
}();
var $p = exports.AnimationAction = /*#__PURE__*/function () {
  function $p(t, e) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : e.blendMode;
    _classCallCheck(this, $p);
    this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
    var r = e.tracks,
      s = r.length,
      a = new Array(s),
      o = {
        endingStart: Le,
        endingEnd: Le
      };
    for (var _t314 = 0; _t314 !== s; ++_t314) {
      var _e315 = r[_t314].createInterpolant(null);
      a[_t314] = _e315, _e315.settings = o;
    }
    this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  return _createClass($p, [{
    key: "play",
    value: function play() {
      return this._mixer._activateAction(this), this;
    }
  }, {
    key: "stop",
    value: function stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
  }, {
    key: "reset",
    value: function reset() {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
  }, {
    key: "isRunning",
    value: function isRunning() {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
    }
  }, {
    key: "isScheduled",
    value: function isScheduled() {
      return this._mixer._isActiveAction(this);
    }
  }, {
    key: "startAt",
    value: function startAt(t) {
      return this._startTime = t, this;
    }
  }, {
    key: "setLoop",
    value: function setLoop(t, e) {
      return this.loop = t, this.repetitions = e, this;
    }
  }, {
    key: "setEffectiveWeight",
    value: function setEffectiveWeight(t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    }
  }, {
    key: "getEffectiveWeight",
    value: function getEffectiveWeight() {
      return this._effectiveWeight;
    }
  }, {
    key: "fadeIn",
    value: function fadeIn(t) {
      return this._scheduleFading(t, 0, 1);
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(t) {
      return this._scheduleFading(t, 1, 0);
    }
  }, {
    key: "crossFadeFrom",
    value: function crossFadeFrom(t, e, n) {
      if (t.fadeOut(e), this.fadeIn(e), n) {
        var _n279 = this._clip.duration,
          _i222 = t._clip.duration,
          r = _i222 / _n279,
          _s106 = _n279 / _i222;
        t.warp(1, r, e), this.warp(_s106, 1, e);
      }
      return this;
    }
  }, {
    key: "crossFadeTo",
    value: function crossFadeTo(t, e, n) {
      return t.crossFadeFrom(this, e, n);
    }
  }, {
    key: "stopFading",
    value: function stopFading() {
      var t = this._weightInterpolant;
      return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }
  }, {
    key: "setEffectiveTimeScale",
    value: function setEffectiveTimeScale(t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    }
  }, {
    key: "getEffectiveTimeScale",
    value: function getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
  }, {
    key: "setDuration",
    value: function setDuration(t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping();
    }
  }, {
    key: "syncWith",
    value: function syncWith(t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    }
  }, {
    key: "halt",
    value: function halt(t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    }
  }, {
    key: "warp",
    value: function warp(t, e, n) {
      var i = this._mixer,
        r = i.time,
        s = this.timeScale;
      var a = this._timeScaleInterpolant;
      null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
      var o = a.parameterPositions,
        l = a.sampleValues;
      return o[0] = r, o[1] = r + n, l[0] = t / s, l[1] = e / s, this;
    }
  }, {
    key: "stopWarping",
    value: function stopWarping() {
      var t = this._timeScaleInterpolant;
      return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }
  }, {
    key: "getMixer",
    value: function getMixer() {
      return this._mixer;
    }
  }, {
    key: "getClip",
    value: function getClip() {
      return this._clip;
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this._localRoot || this._mixer._root;
    }
  }, {
    key: "_update",
    value: function _update(t, e, n, i) {
      if (!this.enabled) return void this._updateWeight(t);
      var r = this._startTime;
      if (null !== r) {
        var _i223 = (t - r) * n;
        _i223 < 0 || 0 === n ? e = 0 : (this._startTime = null, e = n * _i223);
      }
      e *= this._updateTimeScale(t);
      var s = this._updateTime(e),
        a = this._updateWeight(t);
      if (a > 0) {
        var _t315 = this._interpolants,
          _e316 = this._propertyBindings;
        if (this.blendMode === De) for (var _n280 = 0, _i224 = _t315.length; _n280 !== _i224; ++_n280) _t315[_n280].evaluate(s), _e316[_n280].accumulateAdditive(a);else for (var _n281 = 0, _r163 = _t315.length; _n281 !== _r163; ++_n281) _t315[_n281].evaluate(s), _e316[_n281].accumulate(i, a);
      }
    }
  }, {
    key: "_updateWeight",
    value: function _updateWeight(t) {
      var e = 0;
      if (this.enabled) {
        e = this.weight;
        var _n282 = this._weightInterpolant;
        if (null !== _n282) {
          var _i225 = _n282.evaluate(t)[0];
          e *= _i225, t > _n282.parameterPositions[1] && (this.stopFading(), 0 === _i225 && (this.enabled = !1));
        }
      }
      return this._effectiveWeight = e, e;
    }
  }, {
    key: "_updateTimeScale",
    value: function _updateTimeScale(t) {
      var e = 0;
      if (!this.paused) {
        e = this.timeScale;
        var _n283 = this._timeScaleInterpolant;
        if (null !== _n283) {
          e *= _n283.evaluate(t)[0], t > _n283.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e);
        }
      }
      return this._effectiveTimeScale = e, e;
    }
  }, {
    key: "_updateTime",
    value: function _updateTime(t) {
      var e = this._clip.duration,
        n = this.loop;
      var i = this.time + t,
        r = this._loopCount;
      var s = 2202 === n;
      if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
      if (2200 === n) {
        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
        t: {
          if (i >= e) i = e;else {
            if (!(i < 0)) {
              this.time = i;
              break t;
            }
            i = 0;
          }
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1
          });
        }
      } else {
        if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= e || i < 0) {
          var _n284 = Math.floor(i / e);
          i -= e * _n284, r += Math.abs(_n284);
          var _a83 = this.repetitions - r;
          if (_a83 <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t > 0 ? 1 : -1
          });else {
            if (1 === _a83) {
              var _e317 = t < 0;
              this._setEndings(_e317, !_e317, s);
            } else this._setEndings(!1, !1, s);
            this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: _n284
            });
          }
        } else this.time = i;
        if (s && 1 == (1 & r)) return e - i;
      }
      return i;
    }
  }, {
    key: "_setEndings",
    value: function _setEndings(t, e, n) {
      var i = this._interpolantSettings;
      n ? (i.endingStart = Ie, i.endingEnd = Ie) : (i.endingStart = t ? this.zeroSlopeAtStart ? Ie : Le : Ue, i.endingEnd = e ? this.zeroSlopeAtEnd ? Ie : Le : Ue);
    }
  }, {
    key: "_scheduleFading",
    value: function _scheduleFading(t, e, n) {
      var i = this._mixer,
        r = i.time;
      var s = this._weightInterpolant;
      null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
      var a = s.parameterPositions,
        o = s.sampleValues;
      return a[0] = r, o[0] = e, a[1] = r + t, o[1] = n, this;
    }
  }]);
}();
var Qp = new Float32Array(1);
var tm = exports.AnimationMixer = /*#__PURE__*/function (_zn7) {
  function tm(t) {
    var _this114;
    _classCallCheck(this, tm);
    _this114 = _callSuper(this, tm), _this114._root = t, _this114._initMemoryManager(), _this114._accuIndex = 0, _this114.time = 0, _this114.timeScale = 1;
    return _this114;
  }
  _inherits(tm, _zn7);
  return _createClass(tm, [{
    key: "_bindAction",
    value: function _bindAction(t, e) {
      var n = t._localRoot || this._root,
        i = t._clip.tracks,
        r = i.length,
        s = t._propertyBindings,
        a = t._interpolants,
        o = n.uuid,
        l = this._bindingsByRootAndName;
      var c = l[o];
      void 0 === c && (c = {}, l[o] = c);
      for (var _t316 = 0; _t316 !== r; ++_t316) {
        var _r164 = i[_t316],
          _l36 = _r164.name;
        var _h16 = c[_l36];
        if (void 0 !== _h16) ++_h16.referenceCount, s[_t316] = _h16;else {
          if (_h16 = s[_t316], void 0 !== _h16) {
            null === _h16._cacheIndex && (++_h16.referenceCount, this._addInactiveBinding(_h16, o, _l36));
            continue;
          }
          var _i226 = e && e._propertyBindings[_t316].binding.parsedPath;
          _h16 = new Gp(Jp.create(n, _l36, _i226), _r164.ValueTypeName, _r164.getValueSize()), ++_h16.referenceCount, this._addInactiveBinding(_h16, o, _l36), s[_t316] = _h16;
        }
        a[_t316].resultBuffer = _h16.buffer;
      }
    }
  }, {
    key: "_activateAction",
    value: function _activateAction(t) {
      if (!this._isActiveAction(t)) {
        if (null === t._cacheIndex) {
          var _e318 = (t._localRoot || this._root).uuid,
            _n285 = t._clip.uuid,
            _i227 = this._actionsByClip[_n285];
          this._bindAction(t, _i227 && _i227.knownActions[0]), this._addInactiveAction(t, _n285, _e318);
        }
        var _e319 = t._propertyBindings;
        for (var _t317 = 0, _n286 = _e319.length; _t317 !== _n286; ++_t317) {
          var _n287 = _e319[_t317];
          0 == _n287.useCount++ && (this._lendBinding(_n287), _n287.saveOriginalState());
        }
        this._lendAction(t);
      }
    }
  }, {
    key: "_deactivateAction",
    value: function _deactivateAction(t) {
      if (this._isActiveAction(t)) {
        var _e320 = t._propertyBindings;
        for (var _t318 = 0, _n288 = _e320.length; _t318 !== _n288; ++_t318) {
          var _n289 = _e320[_t318];
          0 == --_n289.useCount && (_n289.restoreOriginalState(), this._takeBackBinding(_n289));
        }
        this._takeBackAction(t);
      }
    }
  }, {
    key: "_initMemoryManager",
    value: function _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      var t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length;
          },
          get inUse() {
            return t._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return t._bindings.length;
          },
          get inUse() {
            return t._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return t._controlInterpolants.length;
          },
          get inUse() {
            return t._nActiveControlInterpolants;
          }
        }
      };
    }
  }, {
    key: "_isActiveAction",
    value: function _isActiveAction(t) {
      var e = t._cacheIndex;
      return null !== e && e < this._nActiveActions;
    }
  }, {
    key: "_addInactiveAction",
    value: function _addInactiveAction(t, e, n) {
      var i = this._actions,
        r = this._actionsByClip;
      var s = r[e];
      if (void 0 === s) s = {
        knownActions: [t],
        actionByRoot: {}
      }, t._byClipCacheIndex = 0, r[e] = s;else {
        var _e321 = s.knownActions;
        t._byClipCacheIndex = _e321.length, _e321.push(t);
      }
      t._cacheIndex = i.length, i.push(t), s.actionByRoot[n] = t;
    }
  }, {
    key: "_removeInactiveAction",
    value: function _removeInactiveAction(t) {
      var e = this._actions,
        n = e[e.length - 1],
        i = t._cacheIndex;
      n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
      var r = t._clip.uuid,
        s = this._actionsByClip,
        a = s[r],
        o = a.knownActions,
        l = o[o.length - 1],
        c = t._byClipCacheIndex;
      l._byClipCacheIndex = c, o[c] = l, o.pop(), t._byClipCacheIndex = null;
      delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(t);
    }
  }, {
    key: "_removeInactiveBindingsForAction",
    value: function _removeInactiveBindingsForAction(t) {
      var e = t._propertyBindings;
      for (var _t319 = 0, _n290 = e.length; _t319 !== _n290; ++_t319) {
        var _n291 = e[_t319];
        0 == --_n291.referenceCount && this._removeInactiveBinding(_n291);
      }
    }
  }, {
    key: "_lendAction",
    value: function _lendAction(t) {
      var e = this._actions,
        n = t._cacheIndex,
        i = this._nActiveActions++,
        r = e[i];
      t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
    }
  }, {
    key: "_takeBackAction",
    value: function _takeBackAction(t) {
      var e = this._actions,
        n = t._cacheIndex,
        i = --this._nActiveActions,
        r = e[i];
      t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
    }
  }, {
    key: "_addInactiveBinding",
    value: function _addInactiveBinding(t, e, n) {
      var i = this._bindingsByRootAndName,
        r = this._bindings;
      var s = i[e];
      void 0 === s && (s = {}, i[e] = s), s[n] = t, t._cacheIndex = r.length, r.push(t);
    }
  }, {
    key: "_removeInactiveBinding",
    value: function _removeInactiveBinding(t) {
      var e = this._bindings,
        n = t.binding,
        i = n.rootNode.uuid,
        r = n.path,
        s = this._bindingsByRootAndName,
        a = s[i],
        o = e[e.length - 1],
        l = t._cacheIndex;
      o._cacheIndex = l, e[l] = o, e.pop(), delete a[r], 0 === Object.keys(a).length && delete s[i];
    }
  }, {
    key: "_lendBinding",
    value: function _lendBinding(t) {
      var e = this._bindings,
        n = t._cacheIndex,
        i = this._nActiveBindings++,
        r = e[i];
      t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
    }
  }, {
    key: "_takeBackBinding",
    value: function _takeBackBinding(t) {
      var e = this._bindings,
        n = t._cacheIndex,
        i = --this._nActiveBindings,
        r = e[i];
      t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
    }
  }, {
    key: "_lendControlInterpolant",
    value: function _lendControlInterpolant() {
      var t = this._controlInterpolants,
        e = this._nActiveControlInterpolants++;
      var n = t[e];
      return void 0 === n && (n = new bd(new Float32Array(2), new Float32Array(2), 1, Qp), n.__cacheIndex = e, t[e] = n), n;
    }
  }, {
    key: "_takeBackControlInterpolant",
    value: function _takeBackControlInterpolant(t) {
      var e = this._controlInterpolants,
        n = t.__cacheIndex,
        i = --this._nActiveControlInterpolants,
        r = e[i];
      t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r;
    }
  }, {
    key: "clipAction",
    value: function clipAction(t, e, n) {
      var i = e || this._root,
        r = i.uuid;
      var s = "string" == typeof t ? Ud.findByName(i, t) : t;
      var a = null !== s ? s.uuid : t,
        o = this._actionsByClip[a];
      var l = null;
      if (void 0 === n && (n = null !== s ? s.blendMode : Ne), void 0 !== o) {
        var _t320 = o.actionByRoot[r];
        if (void 0 !== _t320 && _t320.blendMode === n) return _t320;
        l = o.knownActions[0], null === s && (s = l._clip);
      }
      if (null === s) return null;
      var c = new $p(this, s, e, n);
      return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
    }
  }, {
    key: "existingAction",
    value: function existingAction(t, e) {
      var n = e || this._root,
        i = n.uuid,
        r = "string" == typeof t ? Ud.findByName(n, t) : t,
        s = r ? r.uuid : t,
        a = this._actionsByClip[s];
      return void 0 !== a && a.actionByRoot[i] || null;
    }
  }, {
    key: "stopAllAction",
    value: function stopAllAction() {
      var t = this._actions;
      for (var _e322 = this._nActiveActions - 1; _e322 >= 0; --_e322) t[_e322].stop();
      return this;
    }
  }, {
    key: "update",
    value: function update(t) {
      t *= this.timeScale;
      var e = this._actions,
        n = this._nActiveActions,
        i = this.time += t,
        r = Math.sign(t),
        s = this._accuIndex ^= 1;
      for (var _a84 = 0; _a84 !== n; ++_a84) {
        e[_a84]._update(i, t, r, s);
      }
      var a = this._bindings,
        o = this._nActiveBindings;
      for (var _t321 = 0; _t321 !== o; ++_t321) a[_t321].apply(s);
      return this;
    }
  }, {
    key: "setTime",
    value: function setTime(t) {
      this.time = 0;
      for (var _t322 = 0; _t322 < this._actions.length; _t322++) this._actions[_t322].time = 0;
      return this.update(t);
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this._root;
    }
  }, {
    key: "uncacheClip",
    value: function uncacheClip(t) {
      var e = this._actions,
        n = t.uuid,
        i = this._actionsByClip,
        r = i[n];
      if (void 0 !== r) {
        var _t323 = r.knownActions;
        for (var _n292 = 0, _i228 = _t323.length; _n292 !== _i228; ++_n292) {
          var _i229 = _t323[_n292];
          this._deactivateAction(_i229);
          var _r165 = _i229._cacheIndex,
            _s107 = e[e.length - 1];
          _i229._cacheIndex = null, _i229._byClipCacheIndex = null, _s107._cacheIndex = _r165, e[_r165] = _s107, e.pop(), this._removeInactiveBindingsForAction(_i229);
        }
        delete i[n];
      }
    }
  }, {
    key: "uncacheRoot",
    value: function uncacheRoot(t) {
      var e = t.uuid,
        n = this._actionsByClip;
      for (var _t324 in n) {
        var _i230 = n[_t324].actionByRoot[e];
        void 0 !== _i230 && (this._deactivateAction(_i230), this._removeInactiveAction(_i230));
      }
      var i = this._bindingsByRootAndName[e];
      if (void 0 !== i) for (var _t325 in i) {
        var _e323 = i[_t325];
        _e323.restoreOriginalState(), this._removeInactiveBinding(_e323);
      }
    }
  }, {
    key: "uncacheAction",
    value: function uncacheAction(t, e) {
      var n = this.existingAction(t, e);
      null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
    }
  }]);
}(zn);
var em = exports.Uniform = /*#__PURE__*/function () {
  function em(t) {
    _classCallCheck(this, em);
    this.value = t;
  }
  return _createClass(em, [{
    key: "clone",
    value: function clone() {
      return new em(void 0 === this.value.clone ? this.value : this.value.clone());
    }
  }]);
}();
var nm = 0;
var im = exports.UniformsGroup = /*#__PURE__*/function (_zn8) {
  function im() {
    var _this115;
    _classCallCheck(this, im);
    _this115 = _callSuper(this, im), _this115.isUniformsGroup = !0, Object.defineProperty(_assertThisInitialized(_this115), "id", {
      value: nm++
    }), _this115.name = "", _this115.usage = Tn, _this115.uniforms = [];
    return _this115;
  }
  _inherits(im, _zn8);
  return _createClass(im, [{
    key: "add",
    value: function add(t) {
      return this.uniforms.push(t), this;
    }
  }, {
    key: "remove",
    value: function remove(t) {
      var e = this.uniforms.indexOf(t);
      return -1 !== e && this.uniforms.splice(e, 1), this;
    }
  }, {
    key: "setName",
    value: function setName(t) {
      return this.name = t, this;
    }
  }, {
    key: "setUsage",
    value: function setUsage(t) {
      return this.usage = t, this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      return this.dispatchEvent({
        type: "dispose"
      }), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      this.name = t.name, this.usage = t.usage;
      var e = t.uniforms;
      this.uniforms.length = 0;
      for (var _t326 = 0, _n293 = e.length; _t326 < _n293; _t326++) {
        var _n294 = Array.isArray(e[_t326]) ? e[_t326] : [e[_t326]];
        for (var _t327 = 0; _t327 < _n294.length; _t327++) this.uniforms.push(_n294[_t327].clone());
      }
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}(zn);
var rm = exports.InstancedInterleavedBuffer = /*#__PURE__*/function (_ic) {
  function rm(t, e) {
    var _this116;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    _classCallCheck(this, rm);
    _this116 = _callSuper(this, rm, [t, e]), _this116.isInstancedInterleavedBuffer = !0, _this116.meshPerAttribute = n;
    return _this116;
  }
  _inherits(rm, _ic);
  return _createClass(rm, [{
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(rm.prototype), "copy", this).call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
  }, {
    key: "clone",
    value: function clone(t) {
      var e = _get(_getPrototypeOf(rm.prototype), "clone", this).call(this, t);
      return e.meshPerAttribute = this.meshPerAttribute, e;
    }
  }, {
    key: "toJSON",
    value: function toJSON(t) {
      var e = _get(_getPrototypeOf(rm.prototype), "toJSON", this).call(this, t);
      return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e;
    }
  }]);
}(ic);
var sm = exports.GLBufferAttribute = /*#__PURE__*/function () {
  function sm(t, e, n, i, r) {
    _classCallCheck(this, sm);
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0;
  }
  return _createClass(sm, [{
    key: "needsUpdate",
    set: function set(t) {
      !0 === t && this.version++;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(t) {
      return this.buffer = t, this;
    }
  }, {
    key: "setType",
    value: function setType(t, e) {
      return this.type = t, this.elementSize = e, this;
    }
  }, {
    key: "setItemSize",
    value: function setItemSize(t) {
      return this.itemSize = t, this;
    }
  }, {
    key: "setCount",
    value: function setCount(t) {
      return this.count = t, this;
    }
  }]);
}();
var am = exports.Raycaster = /*#__PURE__*/function () {
  function am(t, e) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1 / 0;
    _classCallCheck(this, am);
    this.ray = new or(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new xr(), this.params = {
      Mesh: {},
      Line: {
        threshold: 1
      },
      LOD: {},
      Points: {
        threshold: 1
      },
      Sprite: {}
    };
  }
  return _createClass(am, [{
    key: "set",
    value: function set(t, e) {
      this.ray.set(t, e);
    }
  }, {
    key: "setFromCamera",
    value: function setFromCamera(t, e) {
      e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
    }
  }, {
    key: "intersectObject",
    value: function intersectObject(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return lm(t, this, n, e), n.sort(om), n;
    }
  }, {
    key: "intersectObjects",
    value: function intersectObjects(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      for (var _i231 = 0, r = t.length; _i231 < r; _i231++) lm(t[_i231], this, n, e);
      return n.sort(om), n;
    }
  }]);
}();
function om(t, e) {
  return t.distance - e.distance;
}
function lm(t, e, n, i) {
  if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
    var _i232 = t.children;
    for (var _t328 = 0, r = _i232.length; _t328 < r; _t328++) lm(_i232[_t328], e, n, !0);
  }
}
var cm = exports.Spherical = /*#__PURE__*/function () {
  function cm() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    _classCallCheck(this, cm);
    return this.radius = t, this.phi = e, this.theta = n, this;
  }
  return _createClass(cm, [{
    key: "set",
    value: function set(t, e, n) {
      return this.radius = t, this.phi = e, this.theta = n, this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    }
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      var t = 1e-6;
      return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
  }, {
    key: "setFromCartesianCoords",
    value: function setFromCartesianCoords(t, e, n) {
      return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Xn(e / this.radius, -1, 1))), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var hm = exports.Cylindrical = /*#__PURE__*/function () {
  function hm() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    _classCallCheck(this, hm);
    return this.radius = t, this.theta = e, this.y = n, this;
  }
  return _createClass(hm, [{
    key: "set",
    value: function set(t, e, n) {
      return this.radius = t, this.theta = e, this.y = n, this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
  }, {
    key: "setFromCartesianCoords",
    value: function setFromCartesianCoords(t, e, n) {
      return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var um = new Qn();
var dm = exports.Box2 = /*#__PURE__*/function () {
  function dm() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Qn(1 / 0, 1 / 0);
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Qn(-1 / 0, -1 / 0);
    _classCallCheck(this, dm);
    this.isBox2 = !0, this.min = t, this.max = e;
  }
  return _createClass(dm, [{
    key: "set",
    value: function set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(t) {
      this.makeEmpty();
      for (var _e324 = 0, _n295 = t.length; _e324 < _n295; _e324++) this.expandByPoint(t[_e324]);
      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(t, e) {
      var n = um.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
  }, {
    key: "getCenter",
    value: function getCenter(t) {
      return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
    }
  }, {
    key: "getSize",
    value: function getSize(t) {
      return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
    }
  }, {
    key: "containsBox",
    value: function containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
    }
  }, {
    key: "getParameter",
    value: function getParameter(t, e) {
      return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(t) {
      return this.clampPoint(t, um).distanceTo(t);
    }
  }, {
    key: "intersect",
    value: function intersect(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    }
  }, {
    key: "union",
    value: function union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
  }, {
    key: "translate",
    value: function translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }]);
}();
var pm = new Ii(),
  mm = new Ii();
var fm = exports.Line3 = /*#__PURE__*/function () {
  function fm() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii();
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii();
    _classCallCheck(this, fm);
    this.start = t, this.end = e;
  }
  return _createClass(fm, [{
    key: "set",
    value: function set(t, e) {
      return this.start.copy(t), this.end.copy(e), this;
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return this.start.copy(t.start), this.end.copy(t.end), this;
    }
  }, {
    key: "getCenter",
    value: function getCenter(t) {
      return t.addVectors(this.start, this.end).multiplyScalar(.5);
    }
  }, {
    key: "delta",
    value: function delta(t) {
      return t.subVectors(this.end, this.start);
    }
  }, {
    key: "distanceSq",
    value: function distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
  }, {
    key: "distance",
    value: function distance() {
      return this.start.distanceTo(this.end);
    }
  }, {
    key: "at",
    value: function at(t, e) {
      return this.delta(e).multiplyScalar(t).add(this.start);
    }
  }, {
    key: "closestPointToPointParameter",
    value: function closestPointToPointParameter(t, e) {
      pm.subVectors(t, this.start), mm.subVectors(this.end, this.start);
      var n = mm.dot(mm);
      var i = mm.dot(pm) / n;
      return e && (i = Xn(i, 0, 1)), i;
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(t, e, n) {
      var i = this.closestPointToPointParameter(t, e);
      return this.delta(n).multiplyScalar(i).add(this.start);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
    }
  }, {
    key: "equals",
    value: function equals(t) {
      return t.start.equals(this.start) && t.end.equals(this.end);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var gm = new Ii();
var _m = exports.SpotLightHelper = /*#__PURE__*/function (_Ur14) {
  function _m(t, e) {
    var _this117;
    _classCallCheck(this, _m);
    _this117 = _callSuper(this, _m), _this117.light = t, _this117.matrix = t.matrixWorld, _this117.matrixAutoUpdate = !1, _this117.color = e, _this117.type = "SpotLightHelper";
    var n = new Ts(),
      i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (var _t329 = 0, _e325 = 1, _n296 = 32; _t329 < _n296; _t329++, _e325++) {
      var _r166 = _t329 / _n296 * Math.PI * 2,
        _s108 = _e325 / _n296 * Math.PI * 2;
      i.push(Math.cos(_r166), Math.sin(_r166), 1, Math.cos(_s108), Math.sin(_s108), 1);
    }
    n.setAttribute("position", new gs(i, 3));
    var r = new dh({
      fog: !1,
      toneMapped: !1
    });
    _this117.cone = new Mh(n, r), _this117.add(_this117.cone), _this117.update();
    return _this117;
  }
  _inherits(_m, _Ur14);
  return _createClass(_m, [{
    key: "dispose",
    value: function dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
      var t = this.light.distance ? this.light.distance : 1e3,
        e = t * Math.tan(this.light.angle);
      this.cone.scale.set(e, e, t), gm.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(gm), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }
  }]);
}(Ur);
var vm = new Ii(),
  xm = new lr(),
  ym = new lr();
var Mm = exports.SkeletonHelper = /*#__PURE__*/function (_Mh) {
  function Mm(t) {
    var _this118;
    _classCallCheck(this, Mm);
    var e = Sm(t),
      n = new Ts(),
      i = [],
      r = [],
      s = new Zr(0, 0, 1),
      a = new Zr(0, 1, 0);
    for (var _t330 = 0; _t330 < e.length; _t330++) {
      var _n297 = e[_t330];
      _n297.parent && _n297.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b));
    }
    n.setAttribute("position", new gs(i, 3)), n.setAttribute("color", new gs(r, 3));
    _this118 = _callSuper(this, Mm, [n, new dh({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0
    })]), _this118.isSkeletonHelper = !0, _this118.type = "SkeletonHelper", _this118.root = t, _this118.bones = e, _this118.matrix = t.matrixWorld, _this118.matrixAutoUpdate = !1;
    return _this118;
  }
  _inherits(Mm, _Mh);
  return _createClass(Mm, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      var e = this.bones,
        n = this.geometry,
        i = n.getAttribute("position");
      ym.copy(this.root.matrixWorld).invert();
      for (var _t331 = 0, _n298 = 0; _t331 < e.length; _t331++) {
        var r = e[_t331];
        r.parent && r.parent.isBone && (xm.multiplyMatrices(ym, r.matrixWorld), vm.setFromMatrixPosition(xm), i.setXYZ(_n298, vm.x, vm.y, vm.z), xm.multiplyMatrices(ym, r.parent.matrixWorld), vm.setFromMatrixPosition(xm), i.setXYZ(_n298 + 1, vm.x, vm.y, vm.z), _n298 += 2);
      }
      n.getAttribute("position").needsUpdate = !0, _get(_getPrototypeOf(Mm.prototype), "updateMatrixWorld", this).call(this, t);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }]);
}(Mh);
function Sm(t) {
  var e = [];
  !0 === t.isBone && e.push(t);
  for (var _n299 = 0; _n299 < t.children.length; _n299++) e.push.apply(e, Sm(t.children[_n299]));
  return e;
}
var bm = exports.PointLightHelper = /*#__PURE__*/function (_Gs4) {
  function bm(t, e, n) {
    var _this119;
    _classCallCheck(this, bm);
    _this119 = _callSuper(this, bm, [new Ku(e, 4, 2), new Qr({
      wireframe: !0,
      fog: !1,
      toneMapped: !1
    })]), _this119.light = t, _this119.color = n, _this119.type = "PointLightHelper", _this119.matrix = _this119.light.matrixWorld, _this119.matrixAutoUpdate = !1, _this119.update();
    return _this119;
  }
  _inherits(bm, _Gs4);
  return _createClass(bm, [{
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }
  }]);
}(Gs);
var Em = new Ii(),
  Tm = new Zr(),
  wm = new Zr();
var Am = exports.HemisphereLightHelper = /*#__PURE__*/function (_Ur15) {
  function Am(t, e, n) {
    var _this120;
    _classCallCheck(this, Am);
    _this120 = _callSuper(this, Am), _this120.light = t, _this120.matrix = t.matrixWorld, _this120.matrixAutoUpdate = !1, _this120.color = n, _this120.type = "HemisphereLightHelper";
    var i = new Yu(e);
    i.rotateY(.5 * Math.PI), _this120.material = new Qr({
      wireframe: !0,
      fog: !1,
      toneMapped: !1
    }), void 0 === _this120.color && (_this120.material.vertexColors = !0);
    var r = i.getAttribute("position"),
      s = new Float32Array(3 * r.count);
    i.setAttribute("color", new os(s, 3)), _this120.add(new Gs(i, _this120.material)), _this120.update();
    return _this120;
  }
  _inherits(Am, _Ur15);
  return _createClass(Am, [{
    key: "dispose",
    value: function dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      var t = this.children[0];
      if (void 0 !== this.color) this.material.color.set(this.color);else {
        var _e326 = t.geometry.getAttribute("color");
        Tm.copy(this.light.color), wm.copy(this.light.groundColor);
        for (var _t332 = 0, _n300 = _e326.count; _t332 < _n300; _t332++) {
          var _i233 = _t332 < _n300 / 2 ? Tm : wm;
          _e326.setXYZ(_t332, _i233.r, _i233.g, _i233.b);
        }
        _e326.needsUpdate = !0;
      }
      this.light.updateWorldMatrix(!0, !1), t.lookAt(Em.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  }]);
}(Ur);
var Rm = exports.GridHelper = /*#__PURE__*/function (_Mh2) {
  function Rm() {
    var _this121;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4473924;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8947848;
    _classCallCheck(this, Rm);
    n = new Zr(n), i = new Zr(i);
    var r = e / 2,
      s = t / e,
      a = t / 2,
      o = [],
      l = [];
    for (var _t333 = 0, _c29 = 0, _h17 = -a; _t333 <= e; _t333++, _h17 += s) {
      o.push(-a, 0, _h17, a, 0, _h17), o.push(_h17, 0, -a, _h17, 0, a);
      var _e327 = _t333 === r ? n : i;
      _e327.toArray(l, _c29), _c29 += 3, _e327.toArray(l, _c29), _c29 += 3, _e327.toArray(l, _c29), _c29 += 3, _e327.toArray(l, _c29), _c29 += 3;
    }
    var c = new Ts();
    c.setAttribute("position", new gs(o, 3)), c.setAttribute("color", new gs(l, 3));
    _this121 = _callSuper(this, Rm, [c, new dh({
      vertexColors: !0,
      toneMapped: !1
    })]), _this121.type = "GridHelper";
    return _this121;
  }
  _inherits(Rm, _Mh2);
  return _createClass(Rm, [{
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }]);
}(Mh);
var Cm = exports.PolarGridHelper = /*#__PURE__*/function (_Mh3) {
  function Cm() {
    var _this122;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 64;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 4473924;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 8947848;
    _classCallCheck(this, Cm);
    r = new Zr(r), s = new Zr(s);
    var a = [],
      o = [];
    if (e > 1) for (var _n301 = 0; _n301 < e; _n301++) {
      var _i234 = _n301 / e * (2 * Math.PI),
        _l37 = Math.sin(_i234) * t,
        _c30 = Math.cos(_i234) * t;
      a.push(0, 0, 0), a.push(_l37, 0, _c30);
      var _h18 = 1 & _n301 ? r : s;
      o.push(_h18.r, _h18.g, _h18.b), o.push(_h18.r, _h18.g, _h18.b);
    }
    for (var _e328 = 0; _e328 < n; _e328++) {
      var _l38 = 1 & _e328 ? r : s,
        _c31 = t - t / n * _e328;
      for (var _t334 = 0; _t334 < i; _t334++) {
        var _e329 = _t334 / i * (2 * Math.PI),
          _n302 = Math.sin(_e329) * _c31,
          _r167 = Math.cos(_e329) * _c31;
        a.push(_n302, 0, _r167), o.push(_l38.r, _l38.g, _l38.b), _e329 = (_t334 + 1) / i * (2 * Math.PI), _n302 = Math.sin(_e329) * _c31, _r167 = Math.cos(_e329) * _c31, a.push(_n302, 0, _r167), o.push(_l38.r, _l38.g, _l38.b);
      }
    }
    var l = new Ts();
    l.setAttribute("position", new gs(a, 3)), l.setAttribute("color", new gs(o, 3));
    _this122 = _callSuper(this, Cm, [l, new dh({
      vertexColors: !0,
      toneMapped: !1
    })]), _this122.type = "PolarGridHelper";
    return _this122;
  }
  _inherits(Cm, _Mh3);
  return _createClass(Cm, [{
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }]);
}(Mh);
var Pm = new Ii(),
  Lm = new Ii(),
  Im = new Ii();
var Um = exports.DirectionalLightHelper = /*#__PURE__*/function (_Ur16) {
  function Um(t, e, n) {
    var _this123;
    _classCallCheck(this, Um);
    _this123 = _callSuper(this, Um), _this123.light = t, _this123.matrix = t.matrixWorld, _this123.matrixAutoUpdate = !1, _this123.color = n, _this123.type = "DirectionalLightHelper", void 0 === e && (e = 1);
    var i = new Ts();
    i.setAttribute("position", new gs([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
    var r = new dh({
      fog: !1,
      toneMapped: !1
    });
    _this123.lightPlane = new vh(i, r), _this123.add(_this123.lightPlane), i = new Ts(), i.setAttribute("position", new gs([0, 0, 0, 0, 0, 1], 3)), _this123.targetLine = new vh(i, r), _this123.add(_this123.targetLine), _this123.update();
    return _this123;
  }
  _inherits(Um, _Ur16);
  return _createClass(Um, [{
    key: "dispose",
    value: function dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Pm.setFromMatrixPosition(this.light.matrixWorld), Lm.setFromMatrixPosition(this.light.target.matrixWorld), Im.subVectors(Lm, Pm), this.lightPlane.lookAt(Lm), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Lm), this.targetLine.scale.z = Im.length();
    }
  }]);
}(Ur);
var Nm = new Ii(),
  Dm = new Ks();
var Om = exports.CameraHelper = /*#__PURE__*/function (_Mh4) {
  function Om(t) {
    var _this124;
    _classCallCheck(this, Om);
    var e = new Ts(),
      n = new dh({
        color: 16777215,
        vertexColors: !0,
        toneMapped: !1
      }),
      i = [],
      r = [],
      s = {};
    function a(t, e) {
      o(t), o(e);
    }
    function o(t) {
      i.push(0, 0, 0), r.push(0, 0, 0), void 0 === s[t] && (s[t] = []), s[t].push(i.length / 3 - 1);
    }
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), e.setAttribute("position", new gs(i, 3)), e.setAttribute("color", new gs(r, 3)), _this124 = _callSuper(this, Om, [e, n]), _this124.type = "CameraHelper", _this124.camera = t, _this124.camera.updateProjectionMatrix && _this124.camera.updateProjectionMatrix(), _this124.matrix = t.matrixWorld, _this124.matrixAutoUpdate = !1, _this124.pointMap = s, _this124.update();
    var l = new Zr(16755200),
      c = new Zr(16711680),
      h = new Zr(43775),
      u = new Zr(16777215),
      d = new Zr(3355443);
    _this124.setColors(l, c, h, u, d);
    return _this124;
  }
  _inherits(Om, _Mh4);
  return _createClass(Om, [{
    key: "setColors",
    value: function setColors(t, e, n, i, r) {
      var s = this.geometry.getAttribute("color");
      s.setXYZ(0, t.r, t.g, t.b), s.setXYZ(1, t.r, t.g, t.b), s.setXYZ(2, t.r, t.g, t.b), s.setXYZ(3, t.r, t.g, t.b), s.setXYZ(4, t.r, t.g, t.b), s.setXYZ(5, t.r, t.g, t.b), s.setXYZ(6, t.r, t.g, t.b), s.setXYZ(7, t.r, t.g, t.b), s.setXYZ(8, t.r, t.g, t.b), s.setXYZ(9, t.r, t.g, t.b), s.setXYZ(10, t.r, t.g, t.b), s.setXYZ(11, t.r, t.g, t.b), s.setXYZ(12, t.r, t.g, t.b), s.setXYZ(13, t.r, t.g, t.b), s.setXYZ(14, t.r, t.g, t.b), s.setXYZ(15, t.r, t.g, t.b), s.setXYZ(16, t.r, t.g, t.b), s.setXYZ(17, t.r, t.g, t.b), s.setXYZ(18, t.r, t.g, t.b), s.setXYZ(19, t.r, t.g, t.b), s.setXYZ(20, t.r, t.g, t.b), s.setXYZ(21, t.r, t.g, t.b), s.setXYZ(22, t.r, t.g, t.b), s.setXYZ(23, t.r, t.g, t.b), s.setXYZ(24, e.r, e.g, e.b), s.setXYZ(25, e.r, e.g, e.b), s.setXYZ(26, e.r, e.g, e.b), s.setXYZ(27, e.r, e.g, e.b), s.setXYZ(28, e.r, e.g, e.b), s.setXYZ(29, e.r, e.g, e.b), s.setXYZ(30, e.r, e.g, e.b), s.setXYZ(31, e.r, e.g, e.b), s.setXYZ(32, n.r, n.g, n.b), s.setXYZ(33, n.r, n.g, n.b), s.setXYZ(34, n.r, n.g, n.b), s.setXYZ(35, n.r, n.g, n.b), s.setXYZ(36, n.r, n.g, n.b), s.setXYZ(37, n.r, n.g, n.b), s.setXYZ(38, i.r, i.g, i.b), s.setXYZ(39, i.r, i.g, i.b), s.setXYZ(40, r.r, r.g, r.b), s.setXYZ(41, r.r, r.g, r.b), s.setXYZ(42, r.r, r.g, r.b), s.setXYZ(43, r.r, r.g, r.b), s.setXYZ(44, r.r, r.g, r.b), s.setXYZ(45, r.r, r.g, r.b), s.setXYZ(46, r.r, r.g, r.b), s.setXYZ(47, r.r, r.g, r.b), s.setXYZ(48, r.r, r.g, r.b), s.setXYZ(49, r.r, r.g, r.b), s.needsUpdate = !0;
    }
  }, {
    key: "update",
    value: function update() {
      var t = this.geometry,
        e = this.pointMap;
      Dm.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Fm("c", e, t, Dm, 0, 0, -1), Fm("t", e, t, Dm, 0, 0, 1), Fm("n1", e, t, Dm, -1, -1, -1), Fm("n2", e, t, Dm, 1, -1, -1), Fm("n3", e, t, Dm, -1, 1, -1), Fm("n4", e, t, Dm, 1, 1, -1), Fm("f1", e, t, Dm, -1, -1, 1), Fm("f2", e, t, Dm, 1, -1, 1), Fm("f3", e, t, Dm, -1, 1, 1), Fm("f4", e, t, Dm, 1, 1, 1), Fm("u1", e, t, Dm, .7, 1.1, -1), Fm("u2", e, t, Dm, -.7, 1.1, -1), Fm("u3", e, t, Dm, 0, 2, -1), Fm("cf1", e, t, Dm, -1, 0, 1), Fm("cf2", e, t, Dm, 1, 0, 1), Fm("cf3", e, t, Dm, 0, -1, 1), Fm("cf4", e, t, Dm, 0, 1, 1), Fm("cn1", e, t, Dm, -1, 0, -1), Fm("cn2", e, t, Dm, 1, 0, -1), Fm("cn3", e, t, Dm, 0, -1, -1), Fm("cn4", e, t, Dm, 0, 1, -1), t.getAttribute("position").needsUpdate = !0;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }]);
}(Mh);
function Fm(t, e, n, i, r, s, a) {
  Nm.set(r, s, a).unproject(i);
  var o = e[t];
  if (void 0 !== o) {
    var _t335 = n.getAttribute("position");
    for (var _e330 = 0, _n303 = o.length; _e330 < _n303; _e330++) _t335.setXYZ(o[_e330], Nm.x, Nm.y, Nm.z);
  }
}
var Bm = new Di();
var zm = exports.BoxHelper = /*#__PURE__*/function (_Mh5) {
  function zm(t) {
    var _this125;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16776960;
    _classCallCheck(this, zm);
    var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
      i = new Float32Array(24),
      r = new Ts();
    r.setIndex(new os(n, 1)), r.setAttribute("position", new os(i, 3)), _this125 = _callSuper(this, zm, [r, new dh({
      color: e,
      toneMapped: !1
    })]), _this125.object = t, _this125.type = "BoxHelper", _this125.matrixAutoUpdate = !1, _this125.update();
    return _this125;
  }
  _inherits(zm, _Mh5);
  return _createClass(zm, [{
    key: "update",
    value: function update(t) {
      if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Bm.setFromObject(this.object), Bm.isEmpty()) return;
      var e = Bm.min,
        n = Bm.max,
        i = this.geometry.attributes.position,
        r = i.array;
      r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
    }
  }, {
    key: "setFromObject",
    value: function setFromObject(t) {
      return this.object = t, this.update(), this;
    }
  }, {
    key: "copy",
    value: function copy(t, e) {
      return _get(_getPrototypeOf(zm.prototype), "copy", this).call(this, t, e), this.object = t.object, this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }]);
}(Mh);
var Hm = exports.Box3Helper = /*#__PURE__*/function (_Mh6) {
  function Hm(t) {
    var _this126;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16776960;
    _classCallCheck(this, Hm);
    var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
      i = new Ts();
    i.setIndex(new os(n, 1)), i.setAttribute("position", new gs([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), _this126 = _callSuper(this, Hm, [i, new dh({
      color: e,
      toneMapped: !1
    })]), _this126.box = t, _this126.type = "Box3Helper", _this126.geometry.computeBoundingSphere();
    return _this126;
  }
  _inherits(Hm, _Mh6);
  return _createClass(Hm, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      var e = this.box;
      e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), _get(_getPrototypeOf(Hm.prototype), "updateMatrixWorld", this).call(this, t));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }]);
}(Mh);
var Vm = exports.PlaneHelper = /*#__PURE__*/function (_vh3) {
  function Vm(t) {
    var _this127;
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16776960;
    _classCallCheck(this, Vm);
    var i = n,
      r = new Ts();
    r.setAttribute("position", new gs([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), _this127 = _callSuper(this, Vm, [r, new dh({
      color: i,
      toneMapped: !1
    })]), _this127.type = "PlaneHelper", _this127.plane = t, _this127.size = e;
    var s = new Ts();
    s.setAttribute("position", new gs([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), s.computeBoundingSphere(), _this127.add(new Gs(s, new Qr({
      color: i,
      opacity: .2,
      transparent: !0,
      depthWrite: !1,
      toneMapped: !1
    })));
    return _this127;
  }
  _inherits(Vm, _vh3);
  return _createClass(Vm, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(t) {
      this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), _get(_getPrototypeOf(Vm.prototype), "updateMatrixWorld", this).call(this, t);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
  }]);
}(vh);
var km = new Ii();
var Gm, Wm;
var Xm = exports.ArrowHelper = /*#__PURE__*/function (_Ur17) {
  function Xm() {
    var _this128;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ii(0, 0, 1);
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ii(0, 0, 0);
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 16776960;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .2 * n;
    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : .2 * r;
    _classCallCheck(this, Xm);
    _this128 = _callSuper(this, Xm), _this128.type = "ArrowHelper", void 0 === Gm && (Gm = new Ts(), Gm.setAttribute("position", new gs([0, 0, 0, 0, 1, 0], 3)), Wm = new ou(0, .5, 1, 5, 1), Wm.translate(0, -.5, 0)), _this128.position.copy(e), _this128.line = new vh(Gm, new dh({
      color: i,
      toneMapped: !1
    })), _this128.line.matrixAutoUpdate = !1, _this128.add(_this128.line), _this128.cone = new Gs(Wm, new Qr({
      color: i,
      toneMapped: !1
    })), _this128.cone.matrixAutoUpdate = !1, _this128.add(_this128.cone), _this128.setDirection(t), _this128.setLength(n, r, s);
    return _this128;
  }
  _inherits(Xm, _Ur17);
  return _createClass(Xm, [{
    key: "setDirection",
    value: function setDirection(t) {
      if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);else {
        km.set(t.z, 0, -t.x).normalize();
        var _e331 = Math.acos(t.y);
        this.quaternion.setFromAxisAngle(km, _e331);
      }
    }
  }, {
    key: "setLength",
    value: function setLength(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .2 * t;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .2 * e;
      this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix();
    }
  }, {
    key: "setColor",
    value: function setColor(t) {
      this.line.material.color.set(t), this.cone.material.color.set(t);
    }
  }, {
    key: "copy",
    value: function copy(t) {
      return _get(_getPrototypeOf(Xm.prototype), "copy", this).call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
    }
  }]);
}(Ur);
var jm = exports.AxesHelper = /*#__PURE__*/function (_Mh7) {
  function jm() {
    var _this129;
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    _classCallCheck(this, jm);
    var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      n = new Ts();
    n.setAttribute("position", new gs(e, 3)), n.setAttribute("color", new gs([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
    _this129 = _callSuper(this, jm, [n, new dh({
      vertexColors: !0,
      toneMapped: !1
    })]), _this129.type = "AxesHelper";
    return _this129;
  }
  _inherits(jm, _Mh7);
  return _createClass(jm, [{
    key: "setColors",
    value: function setColors(t, e, n) {
      var i = new Zr(),
        r = this.geometry.attributes.color.array;
      return i.set(t), i.toArray(r, 0), i.toArray(r, 3), i.set(e), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }]);
}(Mh);
var qm = exports.ShapePath = /*#__PURE__*/function () {
  function qm() {
    _classCallCheck(this, qm);
    this.type = "ShapePath", this.color = new Zr(), this.subPaths = [], this.currentPath = null;
  }
  return _createClass(qm, [{
    key: "moveTo",
    value: function moveTo(t, e) {
      return this.currentPath = new iu(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
    }
  }, {
    key: "lineTo",
    value: function lineTo(t, e) {
      return this.currentPath.lineTo(t, e), this;
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(t, e, n, i) {
      return this.currentPath.quadraticCurveTo(t, e, n, i), this;
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(t, e, n, i, r, s) {
      return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this;
    }
  }, {
    key: "splineThru",
    value: function splineThru(t) {
      return this.currentPath.splineThru(t), this;
    }
  }, {
    key: "toShapes",
    value: function toShapes(t) {
      function e(t, e) {
        var n = e.length;
        var i = !1;
        for (var _r168 = n - 1, _s109 = 0; _s109 < n; _r168 = _s109++) {
          var _n304 = e[_r168],
            _a85 = e[_s109],
            _o61 = _a85.x - _n304.x,
            _l39 = _a85.y - _n304.y;
          if (Math.abs(_l39) > Number.EPSILON) {
            if (_l39 < 0 && (_n304 = e[_s109], _o61 = -_o61, _a85 = e[_r168], _l39 = -_l39), t.y < _n304.y || t.y > _a85.y) continue;
            if (t.y === _n304.y) {
              if (t.x === _n304.x) return !0;
            } else {
              var _e332 = _l39 * (t.x - _n304.x) - _o61 * (t.y - _n304.y);
              if (0 === _e332) return !0;
              if (_e332 < 0) continue;
              i = !i;
            }
          } else {
            if (t.y !== _n304.y) continue;
            if (_a85.x <= t.x && t.x <= _n304.x || _n304.x <= t.x && t.x <= _a85.x) return !0;
          }
        }
        return i;
      }
      var n = ku.isClockWise,
        i = this.subPaths;
      if (0 === i.length) return [];
      var r, s, a;
      var o = [];
      if (1 === i.length) return s = i[0], a = new gu(), a.curves = s.curves, o.push(a), o;
      var l = !n(i[0].getPoints());
      l = t ? !l : l;
      var c = [],
        h = [];
      var u,
        d,
        p = [],
        m = 0;
      h[m] = void 0, p[m] = [];
      for (var _e333 = 0, _a86 = i.length; _e333 < _a86; _e333++) s = i[_e333], u = s.getPoints(), r = n(u), r = t ? !r : r, r ? (!l && h[m] && m++, h[m] = {
        s: new gu(),
        p: u
      }, h[m].s.curves = s.curves, l && m++, p[m] = []) : p[m].push({
        h: s,
        p: u[0]
      });
      if (!h[0]) return function (t) {
        var e = [];
        for (var _n305 = 0, _i235 = t.length; _n305 < _i235; _n305++) {
          var _i236 = t[_n305],
            _r169 = new gu();
          _r169.curves = _i236.curves, e.push(_r169);
        }
        return e;
      }(i);
      if (h.length > 1) {
        var _t336 = !1,
          _n306 = 0;
        for (var _t337 = 0, _e334 = h.length; _t337 < _e334; _t337++) c[_t337] = [];
        for (var _i237 = 0, _r170 = h.length; _i237 < _r170; _i237++) {
          var _r171 = p[_i237];
          for (var _s110 = 0; _s110 < _r171.length; _s110++) {
            var _a87 = _r171[_s110];
            var _o62 = !0;
            for (var _r172 = 0; _r172 < h.length; _r172++) e(_a87.p, h[_r172].p) && (_i237 !== _r172 && _n306++, _o62 ? (_o62 = !1, c[_r172].push(_a87)) : _t336 = !0);
            _o62 && c[_i237].push(_a87);
          }
        }
        _n306 > 0 && !1 === _t336 && (p = c);
      }
      for (var _t338 = 0, _e335 = h.length; _t338 < _e335; _t338++) {
        a = h[_t338].s, o.push(a), d = p[_t338];
        for (var _t339 = 0, _e336 = d.length; _t339 < _e336; _t339++) a.holes.push(d[_t339].h);
      }
      return o;
    }
  }]);
}();
"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
  detail: {
    revision: t
  }
})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = t);
},{}],"C:/Users/hazem/AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "61805" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["C:/Users/hazem/AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","three.module.min.js"], null)
//# sourceMappingURL=/three.module.min.fd6016d4.js.map